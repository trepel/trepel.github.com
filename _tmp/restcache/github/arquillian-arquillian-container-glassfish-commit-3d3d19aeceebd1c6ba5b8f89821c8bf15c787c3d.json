{"commit":{"parents":[{"id":"5e3113ca8292ff9f571708e705c8dce2c72e46da"}],"added":["glassfish-remote-3.1/README.txt","glassfish-remote-3.1/src/main/java/org/jboss/arquillian/container/glassfish/remote_3_1/clientutils/GlassFishClient.java","glassfish-remote-3.1/src/main/java/org/jboss/arquillian/container/glassfish/remote_3_1/clientutils/GlassFishClientException.java","glassfish-remote-3.1/src/main/java/org/jboss/arquillian/container/glassfish/remote_3_1/clientutils/GlassFishClientService.java","glassfish-remote-3.1/src/main/java/org/jboss/arquillian/container/glassfish/remote_3_1/clientutils/GlassFishClientUtil.java","glassfish-remote-3.1/src/main/java/org/jboss/arquillian/container/glassfish/remote_3_1/clientutils/NodeAddress.java","glassfish-remote-3.1/src/test/resources/example_arquillian.xml"],"message":"ARQ-269 ARQ-527 ARQ-449 Implementing the GlassFish compatible way of deployment using the \"target\" & some new features\n\n1. GlassFish has a notion of TARGET, which specifies the target to which\n you are  deploying. We should use this way in relation to ARQ-269\n solution.\n\n Valid values are:\n \tserver\n\t   \tDeploys the component to the default server instance\n\t   \tserver. This is the default value.\n   instance_name\n\t   \tDeploys the component to  a  particular  stand-alone\n\t   \tsever instance.\n   cluster_name\n\t   \tDeploys the component to every  server  instance  in\n\t   \tthe cluster. (Though Arquillion use only one instance\n\t   \tto run the test case.)\n\n The domain name as a target is not a reasonable deployment\n senarion in case of testing.\n\nUsing the target we can navigate through the GlassFish REST objects\nto resolve the host address and port numbers for the testing node.\nAutomatic fetch of this data, provides less also related to ARQ-450.\n\n2. We should introduce new property keys for this new feature.\n\n3. There are some other reasonable set of property keys that\nused by the standard GlassFish utility. Implementing some of them\nprovides much more real life like environment for our test.\n\nThe most important ones are: libraries, properties type, etc. Using the same keys with the same semantic as GlassFish use them simplifies the learning curve.\n\nPull the server instances status from mgm API, filtering on RUNNING status of instances\n\n1. Pull the server instances status from mgm API\n2. In case of cluster, tries to find a RUNNING instance (if any), not just picking the first\n3. Improved validation & error handling, with more meaningful error messages\n4. Simplified GlassFishClient interface","tree":"e570b403e703f22f623b7e7e183ea6200beb9889","modified":[{"filename":"glassfish-remote-3.1/pom.xml","diff":"@@ -78,14 +78,29 @@\n     <build>\n         <plugins>\n             <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-surefire-plugin</artifactId>\n                 <configuration>\n-                    <!-- enable tests when GlassFish is setup on Hudson server -->\n                     <skip>true</skip>\n                 </configuration>\n             </plugin>\n         </plugins>\n     </build>\n-\n-</project>\n+    <profiles>\n+        <profile>\n+            <id>integration</id>\n+            <activation>\n+                <activeByDefault>false</activeByDefault>\n+            </activation>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <artifactId>maven-surefire-plugin</artifactId>\n+                        <configuration>\n+                            <skip>false</skip>\n+                        </configuration>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+    </profiles>\n+</project>\n\\ No newline at end of file"},{"filename":"glassfish-remote-3.1/src/main/java/org/jboss/arquillian/container/glassfish/remote_3_1/GlassFishRestConfiguration.java","diff":"@@ -23,128 +23,257 @@\n import org.jboss.arquillian.container.spi.ConfigurationException;\n import org.jboss.arquillian.container.spi.client.container.ContainerConfiguration;\n import org.jboss.arquillian.container.spi.client.deployment.Validate;\n+import org.jboss.arquillian.container.glassfish.remote_3_1.clientutils.GlassFishClient;\n \n-public class GlassFishRestConfiguration implements ContainerConfiguration {\n-\n-    /**\n-     * Glassfish Admin Console port.\n-     * Used to build the URL for the REST request.\n-     */\n-    private int remoteServerAdminPort = 4848;\n-    \n-    /**\n-     * Glassfish address.\n-     * Used to build the URL for the REST request.\n-     */\n-    private String remoteServerAddress = \"localhost\";\n-    \n-    /**\n-     * Flag indicating the administration url uses a secure connection.\n-     * Used to build the URL for the REST request.\n-     */\n-    private boolean remoteServerAdminHttps = false;\n-    \n-    /**\n-     * Flag indicating application urls use secure connections.\n-     * Used to build the URL for the REST request.\n-     */\n-    private boolean remoteServerHttps = false;\n-    \n-    /**\n-     * Http port for application urls.\n-     * Used to build the URL for the REST request.\n-     */\n-    private int remoteServerHttpPort = 8080;\n-    \n+public class GlassFishRestConfiguration implements ContainerConfiguration\n+{\n+\t/**\n+\t * Glassfish Admin Server (DAS) host address.\n+\t * Used to build the URL for the REST request.\n+\t */\n+\tprivate String adminHost = \"localhost\";\n+\t\n+\t/**\n+\t * Glassfish Admin Console port.\n+\t * Used to build the URL for the REST request.\n+\t */\n+\tprivate int adminPort = 4848;\n+\t\n+\t/**\n+\t * Flag indicating the administration url uses a secure connection.\n+\t * Used to build the URL for the REST request.\n+\t */\n+\tprivate boolean adminHttps = false;\n+\t\n+\t/**\n+\t * Flag indicating application urls use secure connections.\n+\t * Used to build the URL for the REST request.\n+\t */\n+\tprivate boolean serverHttps = false;\n+\t\n+\t/**\n+\t * @deprecated\n+\t * Http port for application urls.\n+\t * Used to build the URL for the REST request.\n+\t */\n+\tprivate int remoteServerHttpPort = 8080;\n+\t\n     /**\n      * Flag indicating the remote server requires an admin user and password. \n      */\n-    private boolean remoteServerAuthorisation = false;\n+    private boolean authorisation = false;\n     \n     /**\n      * Authorised admin user in the remote glassfish admin realm\n      */\n-    private String remoteServerAdminUser;\n-\n+    private String adminUser;\n+\t\n     /**\n      * Authorised admin user password\n      */\n-    private String remoteServerAdminPassword;\n-\n-    public String getRemoteServerAddress() {\n-        return remoteServerAddress;\n-    }\n-\n-    public void setRemoteServerAddress(String remoteServerAddress) {\n-        this.remoteServerAddress = remoteServerAddress;\n-    }\n-\n-    public int getRemoteServerAdminPort() {\n-        return remoteServerAdminPort;\n-    }\n-\n-    public void setRemoteServerAdminPort(int remoteServerAdminPort) {\n-        this.remoteServerAdminPort = remoteServerAdminPort;\n-    }\n-\n-    public boolean isRemoteServerAdminHttps() {\n-        return remoteServerAdminHttps;\n-    }\n-\n-    public void setRemoteServerAdminHttps(boolean remoteServerAdminHttps) {\n-        this.remoteServerAdminHttps = remoteServerAdminHttps;\n-    }\n-\n+    private String adminPassword;\n+\t\n+\t/**\n+\t * Specifies the target to which you are  deploying. \n+\t * \n+\t * Valid values are:\n+\t * \tserver\n+\t *   \tDeploys the component to the default Admin Server instance.\n+\t *   \tThis is the default value.\n+\t *   instance_name\n+\t *   \tDeploys the component to  a  particular  stand-alone\n+\t *   \tsever instance.\n+\t *   cluster_name\n+\t *   \tDeploys the component to every  server  instance  in\n+\t *   \tthe cluster. (Though Arquillion use only one instance\n+\t *   \tto run the test case.)\n+\t * \n+\t * The domain name as a target is not a reasonable deployment \n+\t * senarion in case of testing. \n+\t */\n+\tprivate String target = GlassFishClient.ADMINSERVER;\n+\t\n+\t/**\n+\t * A comma-separated list of library JAR files. Specify the\n+\t * library  JAR  files by their relative or absolute paths.\n+\t * Specify relative paths relative to domain-dir/lib/applibs.\n+\t *  \n+\t * The libraries are made available to the application in \n+\t * the order specified.\n+\t */\n+\tprivate String libraries = null;\n+\t\n+\t/**\n+\t * Optional keyword-value  pairs  that  specify  additional\n+\t * properties  for the deployment. The available properties\n+\t * are determined by the implementation  of  the  component\n+\t * that  is  being deployed or redeployed.\n+\t */\n+\tprivate String properties = null;\n+\t\n+\t/**\n+\t * The packaging archive type of the component that is\n+\t * being deployed. Only possible values is: osgi\n+\t * \n+\t * The component is packaged as an OSGi Alliance bundle.\n+\t * The type option is optional. If the component is packaged\n+\t * as a regular archive, omit this option.\n+\t */\n+\tprivate String type = null;\n+\t\n+\t\n+\tpublic String getAdminHost()\n+\t{\n+\t\treturn adminHost;\n+\t}\n+\t\n+\t/**\n+\t * @deprecated\n+\t */\n+\tpublic void setRemoteServerAddress(String adminHost)\n+\t{\n+\t\tthis.adminHost = adminHost;\n+\t}\n+\t\n+\tpublic void setAdminHost(String adminHost)\n+\t{\n+\t\tthis.adminHost = adminHost;\n+\t}\n+\t\n+\tpublic int getAdminPort()\n+\t{\n+\t\treturn adminPort;\n+\t}\n+\t\n+\t/**\n+\t * @deprecated\n+\t */\n+\tpublic void setRemoteServerAdminPort(int adminPort)\n+\t{\n+\t\tthis.adminPort = adminPort;\n+\t}\n+\t\n+\tpublic void setAdminPort(int adminPort)\n+\t{\n+\t\tthis.adminPort = adminPort;\n+\t}\n+\t\n+\tpublic boolean isAdminHttps()\n+\t{\n+\t\treturn adminHttps;\n+\t}\n+\t\n+\t/**\n+\t * @deprecated\n+\t */\n+\tpublic void setRemoteServerAdminHttps(boolean adminHttps)\n+\t{\n+\t\tthis.adminHttps = adminHttps;\n+\t}\n+\t\n+\tpublic void setAdminHttps(boolean adminHttps)\n+\t{\n+\t\tthis.adminHttps = adminHttps;\n+\t}\n+\t\n+\tpublic boolean isServerHttps()\n+\t{\n+\t\treturn serverHttps;\n+\t}\n+\t\n+\t/**\n+\t * @deprecated\n+\t */\n     public int getRemoteServerHttpPort() {\n-        return remoteServerHttpPort;\n+    \treturn remoteServerHttpPort;\n     }\n-\n+\t\n+\t/**\n+\t * @deprecated\n+\t */\n     public void setRemoteServerHttpPort(int remoteServerHttpPort) {\n-        this.remoteServerHttpPort = remoteServerHttpPort;\n+    \tthis.remoteServerHttpPort = remoteServerHttpPort;\n     }\n-\n-    public boolean isRemoteServerHttps() {\n-        return remoteServerHttps;\n+\t\n+\t/**\n+\t * @deprecated\n+\t */\n+\tpublic void setRemoteServerHttps(Boolean serverHttps)\n+\t{\n+\t\tthis.serverHttps = serverHttps;\n+\t}\n+\t\n+\tpublic void setServerHttps(boolean serverHttps)\n+\t{\n+\t\tthis.serverHttps = serverHttps;\n+\t}\t\n+\t\n+    public boolean isAuthorisation() {\n+        return authorisation;\n     }\n-\n-    public void setRemoteServerHttps(boolean remoteServerHttps) {\n-        this.remoteServerHttps = remoteServerHttps;\n-    }\n-\n-    public boolean isRemoteServerAuthorisation() {\n-        return remoteServerAuthorisation;\n-    }\n-\n-    public void setRemoteServerAuthorisation(boolean remoteServerAuthorisation) {\n-        this.remoteServerAuthorisation = remoteServerAuthorisation;\n+\t\n+    public void setAuthorisation(boolean authorisation) {\n+        this.authorisation = authorisation;\n     }\n-\n-    public String getRemoteServerAdminUser() {\n-        return remoteServerAdminUser;\n+\t\n+    public String getAdminUser() {\n+        return adminUser;\n     }\n-\n-    public void setRemoteServerAdminUser(String remoteServerAdminUser) {\n-        this.setRemoteServerAuthorisation(true);\n-        this.remoteServerAdminUser = remoteServerAdminUser;\n+\t\n+    public void setAdminUser(String adminUser) {\n+        this.setAuthorisation(true);\n+        this.adminUser = adminUser;\n     }\n-\n-    public String getRemoteServerAdminPassword() {\n-        return remoteServerAdminPassword;\n+\t\n+    public String getAdminPassword() {\n+        return adminPassword;\n     }\n-\n-    public void setRemoteServerAdminPassword(String remoteServerAdminPassword) {\n-        this.remoteServerAdminPassword = remoteServerAdminPassword;\n+\t\n+    public void setAdminPassword(String adminPassword) {\n+        this.adminPassword = adminPassword;\n     }\n-\n+\t\n+\tpublic String getTarget() {\n+\t\treturn target; \n+\t}\n+\t\n+\tpublic void setTarget(String target) {\n+\t\tthis.target = target; \n+\t}\n+\t\n+\tpublic String getLibraries() {\n+\t\treturn libraries; \n+\t}\n+\t\n+\tpublic void setLibraries(String library) {\n+\t\tthis.libraries = library; \n+\t}\n+\t\n+\tpublic String getProperties() {\n+\t\treturn properties; \n+\t}\n+\t\n+\tpublic void setProperties(String properties) {\n+\t\tthis.properties = properties; \n+\t}\n+\t\n+\tpublic String getType() {\n+\t\treturn this.type;\n+\t}\n+\t\n+\tpublic void setType(String type) {\n+\t\tthis.type = type; \n+\t}\n+\t\n     /**\n      * Validates if current configuration is valid, that is if all required\n      * properties are set and have correct values\n      */\n     public void validate() throws ConfigurationException {\n-       if(isRemoteServerAuthorisation())\n-       {\n-          Validate.notNull(getRemoteServerAdminUser(), \"remoteServerAdminUser must be specified to use remoteServerAuthorisation\");\n-          Validate.notNull(getRemoteServerAdminPassword(), \"remoteServerAdminPassword must be specified to use remoteServerAuthorisation\");\n-       }\n+\t\tif(isAuthorisation())\n+\t\t{\n+\t\t\tValidate.notNull(getAdminUser(), \"adminUser must be specified to use authorisation\");\n+\t\t\tValidate.notNull(getAdminPassword(), \"adminPassword must be specified to use authorisation\");\n+\t\t}\n     }\n }"},{"filename":"glassfish-remote-3.1/src/main/java/org/jboss/arquillian/container/glassfish/remote_3_1/GlassFishRestDeployableContainer.java","diff":"@@ -21,115 +21,86 @@\n package org.jboss.arquillian.container.glassfish.remote_3_1;\n \n import java.io.File;\n-import java.io.StringReader;\n import java.net.URISyntaxException;\n import java.net.URL;\n \n-import javax.ws.rs.core.MediaType;\n-import javax.xml.xpath.XPath;\n-import javax.xml.xpath.XPathConstants;\n-import javax.xml.xpath.XPathExpressionException;\n-import javax.xml.xpath.XPathFactory;\n-\n import org.jboss.arquillian.container.spi.client.container.DeployableContainer;\n import org.jboss.arquillian.container.spi.client.container.DeploymentException;\n import org.jboss.arquillian.container.spi.client.container.LifecycleException;\n import org.jboss.arquillian.container.spi.client.protocol.ProtocolDescription;\n import org.jboss.arquillian.container.spi.client.protocol.metadata.HTTPContext;\n import org.jboss.arquillian.container.spi.client.protocol.metadata.ProtocolMetaData;\n-import org.jboss.arquillian.container.spi.client.protocol.metadata.Servlet;\n+import org.jboss.arquillian.container.glassfish.remote_3_1.clientutils.GlassFishClient;\n+import org.jboss.arquillian.container.glassfish.remote_3_1.clientutils.GlassFishClientException;\n+import org.jboss.arquillian.container.glassfish.remote_3_1.clientutils.GlassFishClientService;\n+\n import org.jboss.shrinkwrap.api.Archive;\n import org.jboss.shrinkwrap.descriptor.api.Descriptor;\n-import org.w3c.dom.NodeList;\n-import org.xml.sax.InputSource;\n \n-import com.sun.jersey.api.client.Client;\n-import com.sun.jersey.api.client.WebResource;\n-import com.sun.jersey.api.client.filter.HTTPBasicAuthFilter;\n+import javax.ws.rs.core.MediaType;\n import com.sun.jersey.multipart.FormDataMultiPart;\n import com.sun.jersey.multipart.file.FileDataBodyPart;\n \n+import java.util.logging.Logger;\n+\n /**\n  * Glassfish v3.1 remote container using REST deployment.\n  *\n  * @author <a href=\"http://community.jboss.org/people/LightGuard\">Jason Porter</a>\n  */\n-@SuppressWarnings({\"HardcodedFileSeparator\"})\n public class GlassFishRestDeployableContainer implements DeployableContainer<GlassFishRestConfiguration> {\n-\n-    private static final String APPLICATION = \"/applications/application\";\n-    private static final String LIST_SUB_COMPONENTS = \"/applications/application/list-sub-components?id=\";\n-    private static final String SUCCESS = \"SUCCESS\";\n-    private String adminBaseUrl;\n-    private String applicationBaseUrl;\n-    private String deploymentName;\n+\t\n+\tpublic static final String DELETE_OPERATION = \"__deleteoperation\";\n+\t\n+\tprivate String deploymentName;\n+\t\n     private GlassFishRestConfiguration configuration;\n-\n+\t\n+    private GlassFishClient glassFishClient;\n+\t\n+\tprivate static final Logger log = Logger.getLogger(GlassFishRestDeployableContainer.class.getName());\n+\t\n     public Class<GlassFishRestConfiguration> getConfigurationClass() {\n         return GlassFishRestConfiguration.class;\n     }\n-\n+\t\n     public void setup(GlassFishRestConfiguration configuration) {\n         if (configuration == null) {\n             throw new IllegalArgumentException(\"configuration must not be null\");\n         }\n-\n         this.configuration = configuration;\n-\n-        final StringBuilder adminUrlBuilder = new StringBuilder();\n-\n-        if (this.configuration.isRemoteServerAdminHttps()) {\n-            adminUrlBuilder.append(\"https://\");\n-        } else {\n-            adminUrlBuilder.append(\"http://\");\n-        }\n-\n-        adminUrlBuilder.append(this.configuration.getRemoteServerAddress()).append(\":\")\n-                       .append(this.configuration.getRemoteServerAdminPort()).append(\"/management/domain\");\n-\n-        this.adminBaseUrl = adminUrlBuilder.toString();\n-\n-        final StringBuilder applicationUrlBuilder = new StringBuilder();\n-\n-        if (this.configuration.isRemoteServerHttps()) {\n-            applicationUrlBuilder.append(\"https://\");\n-        } else {\n-            applicationUrlBuilder.append(\"http://\");\n-        }\n-\n-        applicationUrlBuilder.append(this.configuration.getRemoteServerAddress()).append(\":\")\n-                             .append(this.configuration.getRemoteServerHttpPort()).append(\"/\");\n-\n-        this.applicationBaseUrl = applicationUrlBuilder.toString();\n+        \n+        // Start up the GlassFishClient service layer\n+        this.glassFishClient = new GlassFishClientService(configuration);        \n     }\n-\n-    public void start() throws LifecycleException {\n-        final String xmlResponse = prepareClient().get(String.class);\n-\n-        try {\n-            if (!isCallSuccessful(xmlResponse)) {\n-                throw new LifecycleException(\"Server is not running\");\n-            }\n-        } catch (XPathExpressionException e) {\n-            throw new LifecycleException(\"Error verifying the sever is running\", e);\n+\t\n+    public void start() throws LifecycleException {   \t\n+\t\t\n+    \ttry {\t\t\t\n+\n+    \t\tglassFishClient.startUp();\n+\t\t\t\n+    \t} catch (GlassFishClientException e) {\n+    \t\tlog.severe( e.getMessage() );\n+    \t\tthrow new LifecycleException( e.getMessage() );\n         }\n     }\n-\n+\t\n     public void stop() throws LifecycleException {\n-       // NO-OP\n+        //To change body of implemented methods use File | Settings | File Templates.\n     }\n-\n+\t\n     public ProtocolDescription getDefaultProtocol() {\n         return new ProtocolDescription(\"Servlet 3.0\");\n     }\n-\n+\t\n     public ProtocolMetaData deploy(Archive<?> archive) throws DeploymentException {\n         if (archive == null) {\n             throw new IllegalArgumentException(\"archive must not be null\");\n         }\n-\n-        final String archiveName = archive.getName();\n-\n+\t\t\n+        final ProtocolMetaData protocolMetaData = new ProtocolMetaData();\n+\t\t\n         try {\n             // Export to a file so we can send it over the wire\n             URL archiveFile = ShrinkWrapUtil.toURL(archive);\n@@ -138,123 +109,90 @@ public ProtocolMetaData deploy(Archive<?> archive) throws DeploymentException {\n             final FormDataMultiPart form = new FormDataMultiPart();\n             try\n             {\n-               form.getBodyParts().add(new FileDataBodyPart(\"id\", new File(archiveFile.toURI())));\n+\t\t\t\tform.getBodyParts().add(new FileDataBodyPart(\"id\", new File(archiveFile.toURI())));\n             }\n             catch (URISyntaxException e1)\n             {\n-               throw new DeploymentException(\"Could not convert exported deployment URL to URI?\", e1);\n-            }\n-            form.field(\"contextroot\", archiveName.substring(0, archiveName.lastIndexOf(\".\")), MediaType.TEXT_PLAIN_TYPE);\n-            deploymentName = archiveName.substring(0, archiveName.lastIndexOf(\".\"));\n-            form.field(\"name\", deploymentName, MediaType.TEXT_PLAIN_TYPE);\n-            final String xmlResponse = prepareClient(APPLICATION).type(MediaType.MULTIPART_FORM_DATA_TYPE).post(String.class, form);\n-\n-            try {\n-                if (!isCallSuccessful(xmlResponse)) {\n-                    throw new DeploymentException(getMessage(xmlResponse));\n-                }\n-            } catch (XPathExpressionException e) {\n-                throw new DeploymentException(\"Error finding exit code or message\", e);\n+\t\t\t\tthrow new DeploymentException(\"Could not convert exported deployment URL to URI?\", e1);\n             }\n-\n-            // Call has been successful, now we need another call to get the list of servlets\n-            final String subComponentsResponse = prepareClient(LIST_SUB_COMPONENTS + this.deploymentName).get(String.class);\n-\n-            return this.parseForProtocolMetaData(subComponentsResponse);\n-        } catch (XPathExpressionException e) {\n-            throw new DeploymentException(\"Error in creating / deploying archive\", e);\n+            \n+            deploymentName = createDeploymentName(archive.getName());\n+            addDeployFormFields(deploymentName, form);\n+            \n+            // Do Deploy the application on the remote GlassFish\n+            HTTPContext httpContext = glassFishClient.doDeploy(deploymentName, form);\t\t\t\n+            protocolMetaData.addContext(httpContext);\n+            \n+        } catch (GlassFishClientException e) {\n+            throw new DeploymentException(\"Could not deploy \" + archive.getName(), e);\n         }\n+        return protocolMetaData;\n     }\n-\n+\t\n     public void undeploy(Archive<?> archive) throws DeploymentException {\n-        final String xmlResponse = prepareClient(APPLICATION + \"/\" + this.deploymentName).delete(String.class);\n-\n-        try {\n-            if (!isCallSuccessful(xmlResponse)) {\n-                throw new DeploymentException(getMessage(xmlResponse));\n-            }\n-        } catch (XPathExpressionException e) {\n-            throw new DeploymentException(\"Error finding exit code or message\", e);\n+\t\t\n+    \tif (archive == null) {\n+            throw new IllegalArgumentException(\"archive must not be null\");\n+        } else {\n+\t\t\t\n+        \tdeploymentName = createDeploymentName(archive.getName());\n+        \ttry {\n+\t            // Build up the POST form to send to Glassfish\n+\t            final FormDataMultiPart form = new FormDataMultiPart();\n+\t            form.field(\"target\", this.configuration.getTarget(), MediaType.TEXT_PLAIN_TYPE);        \t        \t\n+\t            form.field(\"operation\", DELETE_OPERATION, MediaType.TEXT_PLAIN_TYPE);\n+\t        \tglassFishClient.doUndeploy(this.deploymentName, form);\n+\t        } catch (GlassFishClientException e) {\n+\t            throw new DeploymentException(\"Could not undeploy \" + archive.getName(), e);\n+\t        }\n         }\n+\t\t\n     }\n-\n+\t\n     public void deploy(Descriptor descriptor) throws DeploymentException {\n-        throw new UnsupportedOperationException(\"Not implemented\");\n+\t\tthrow new UnsupportedOperationException(\"Not implemented\");\n     }\n-\n+\t\n     public void undeploy(Descriptor descriptor) throws DeploymentException {\n-        throw new UnsupportedOperationException(\"Not implemented\");\n+\t\tthrow new UnsupportedOperationException(\"Not implemented\");\n     }\n-\n-    /**\n-     * Basic REST call preparation\n-     *\n-     * @return the resource builder to execute\n-     */\n-    private WebResource.Builder prepareClient() {\n-        return prepareClient(\"\");\n+\t\n+    private String createDeploymentName(String archiveName)\n+    {\n+\t\tString correctedName = archiveName;\n+\t\tif(correctedName.startsWith(\"/\"))\n+\t\t{\n+\t\t\tcorrectedName = correctedName.substring(1);\n+\t\t}\n+\t\tif(correctedName.indexOf(\".\") != -1)\n+\t\t{\n+\t\t\tcorrectedName = correctedName.substring(0, correctedName.lastIndexOf(\".\"));\n+\t\t}\n+\t\treturn correctedName;\n     }\n-\n-    /**\n-     * Basic REST call preparation, with the additional resource url appended\n-     *\n-     * @param additionalResourceUrl url portion past the base to use\n-     * @return the resource builder to execute\n-     */\n-    private WebResource.Builder prepareClient(String additionalResourceUrl) {\n-        final Client client = Client.create();\n-        if (configuration.isRemoteServerAuthorisation()) {\n-            client.addFilter(new HTTPBasicAuthFilter(\n-                    configuration.getRemoteServerAdminUser(),\n-                    configuration.getRemoteServerAdminPassword()));\n+\t\n+    private void addDeployFormFields(String name, FormDataMultiPart deployform) {\n+\t\t\n+        // add the name field, the name is the archive filename without extension \n+        deployform.field(\"name\", name, MediaType.TEXT_PLAIN_TYPE);\n+\t\t\n+        // add the target field (the default is \"server\" - Admin Server)\n+        deployform.field(\"target\", this.configuration.getTarget(), MediaType.TEXT_PLAIN_TYPE);        \n+\t\t\n+        // add the libraries field (optional)\n+        if ( this.configuration.getLibraries() != null )  {\n+        \tdeployform.field(\"libraries\", this.configuration.getLibraries(), MediaType.TEXT_PLAIN_TYPE);\n         }\n-        return client.resource(this.adminBaseUrl + additionalResourceUrl).accept(MediaType.APPLICATION_XML_TYPE);\n-    }\n-\n-    /**\n-     * Looks for a successful exit code given the response of the call\n-     *\n-     * @param xmlResponse XML response from the REST call\n-     * @return true if call was successful, false otherwise\n-     * @throws XPathExpressionException if the xpath query could not be executed\n-     */\n-    private boolean isCallSuccessful(String xmlResponse) throws XPathExpressionException {\n-        final XPath xpath = XPathFactory.newInstance().newXPath();\n-\n-        final String exitCode = xpath.evaluate(\"/map/entry[@key = 'exit_code']/@value\",\n-                new InputSource(new StringReader(xmlResponse)));\n-\n-        return !(exitCode == null || !SUCCESS.equals(exitCode));\n-\n-    }\n-\n-    /**\n-     * Finds the message from the response.\n-     *\n-     * @param xmlResponse XML response from the REST call\n-     * @return true if call was successful, false otherwise\n-     * @throws XPathExpressionException if the xpath query could not be executed\n-     */\n-    private String getMessage(String xmlResponse) throws XPathExpressionException {\n-        final XPath xpath = XPathFactory.newInstance().newXPath();\n-        return xpath.evaluate(\"/map/entry[@key = 'message']/@value\", new InputSource(new StringReader(xmlResponse)));\n-    }\n-\n-    private ProtocolMetaData parseForProtocolMetaData(String xmlResponse) throws XPathExpressionException {\n-        final ProtocolMetaData protocolMetaData = new ProtocolMetaData();\n-        final HTTPContext httpContext = new HTTPContext(this.configuration.getRemoteServerAddress(),\n-                this.configuration.getRemoteServerHttpPort());\n-\n-        final XPath xpath = XPathFactory.newInstance().newXPath();\n-\n-        NodeList servlets = (NodeList) xpath.evaluate(\"/map/entry[@key = 'properties']/map/entry[@value = 'Servlet']\",\n-                new InputSource(new StringReader(xmlResponse)), XPathConstants.NODESET);\n-\n-        for (int i = 0; i < servlets.getLength(); i++) {\n-            httpContext.add(new Servlet(servlets.item(i).getAttributes().getNamedItem(\"key\").getNodeValue(), this.deploymentName));\n+\t\t\n+        // add the properties field (optional)\n+        if ( this.configuration.getProperties() != null )  {\n+        \tdeployform.field(\"properties\", this.configuration.getProperties(), MediaType.TEXT_PLAIN_TYPE);\n+        }\n+\t\t\n+        // add the type field (optional, the only valid value is \"osgi\", other values are ommited)\n+        if ( this.configuration.getType() != null && \"osgi\".equals(this.configuration.getType()) )  {\n+        \tdeployform.field(\"type\", this.configuration.getType(), MediaType.TEXT_PLAIN_TYPE);\n         }\n-\n-        protocolMetaData.addContext(httpContext);\n-        return protocolMetaData;\n     }\n-}\n\\ No newline at end of file\n+\t\n+}"}],"committer":{"email":"aslak@redhat.com","login":"aslakknutsen","name":"Aslak Knutsen"},"authored_date":"2011-07-09T07:38:11-07:00","url":"/arquillian/arquillian-container-glassfish/commit/3d3d19aeceebd1c6ba5b8f89821c8bf15c787c3d","committed_date":"2011-07-29T04:45:44-07:00","id":"3d3d19aeceebd1c6ba5b8f89821c8bf15c787c3d","author":{"email":"zpaulovics@gmail.com","login":"zpaulovics","name":"zpaulovics"}}}