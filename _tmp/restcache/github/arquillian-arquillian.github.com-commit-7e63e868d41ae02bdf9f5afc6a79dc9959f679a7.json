{"commit":{"committer":{"email":"aslak@redhat.com","login":"aslakknutsen","name":"Aslak Knutsen"},"authored_date":"2012-08-20T03:25:49-07:00","id":"7e63e868d41ae02bdf9f5afc6a79dc9959f679a7","message":"Update guides/testing_java_persistence_fr.textile","committed_date":"2012-08-30T10:45:35-07:00","url":"/arquillian/arquillian.github.com/commit/7e63e868d41ae02bdf9f5afc6a79dc9959f679a7","parents":[{"id":"28b0ff7c4b291a57f641c2c3292feb06fcd48a14"}],"tree":"b7b0ce9207bb76934c94e5fdc05ddb9819175842","modified":[{"diff":"@@ -72,7 +72,7 @@ Afin que vous puissiez prendre vos repères, voici la structure de répertoire d\n \n @Game@ est l'entité JPA et test-persistence.xml est une version modifiée de persistence.xml, qui fournit la définition de notre Persistence Unit pour l'environnement de test. Notez que deux répertoires contiennent un fichier test-persistence.xml, un pour chaque conteneur que nous utiliserons. Nous verrons cela plus tard. \n \n-Nous recommandons d'utiliser un descripteur JPA dédié aux tests, avec une DataSource de test et une configuration spécifique de votre fournisseur de persistance. Par exemple, en environnement de test, vous pourrez vouloir adopter une stratégie \"drop-and-create-tables\" pour gérer le schéma de la base de données. Vous pouvez aussi vouloir voir les requêtes à la base de données dans la sortie de traces. Ce paramètrage peut être réalisé dans test-persistence.xml sans affecter l'application principale, comme nous le verrons plus loin. Nous laisserons donc de côté le fichier persistence.xml car c'est la configuration pour l'environnement de production.\n+Nous recommandons d’utiliser un descripteur JPA dédié aux tests, avec une DataSource de test et une configuration spécifique de votre fournisseur de persistance. Par exemple, en environnement de test, vous pourrez vouloir adopter une stratégie “drop-and-create-tables” pour gérer le schéma de la base de données. Vous pouvez aussi vouloir voir les requêtes à la base de données dans la sortie des traces. Ce paramètrage peut être réalisé dans test-persistence.xml sans affecter l’application principale, comme nous le verrons plus loin. Nous laisserons donc de côté le fichier persistence.xml car c’est la configuration pour l’environnement de production.\n \n Voici le code source de l'entité @Game@, annotée en @@Entity@ :\n \n@@ -178,7 +178,7 @@ p. Etudions ce code depuis le début pour comprendre ce qu'il se passe avant de\n - @RunWith(Arquillian.class) := Indique à JUnit de déléguer l'exécution du test au runner Arquillian. Cela permet à Arquillian d'enrichir votre test avec un modèle de composant, une gestion de cycle de vie par un conteneur et l'injection de dépendance, entre autres. Notez que vous n'avez pas à étendre une classe de base, ce qui vous laisse libre pour d'autres besoins.\n - Méthode @Deployment := Produit une archive de \"micro-déploiement\" avec l'API \"ShrinkWrap\":http://jboss.org/shrinkwrap. Arquillian déploie cette archive dans le conteneur, incluant la classe de test et quelques classes d'infrastructure. Le test est alors exécuté comme un composant au sein de cette mini-application. Le périmètre de cette archive isole le test du reste du monde.\n - Constante GAME_TITLES := Données de test\n-- @PersistenceContext EntityManager := Injecte le contexte de persistance (i.e. @EntityManager@) directement dans le test, comme si le test était un \"managed bean\":http://download.oracle.com/javaee/6/api/javax/annotation/ManagedBean.html.\n+- @PersistenceContext EntityManager := Injecte le contexte de persistance (c-à-d. @EntityManager@) directement dans le test, comme si le test était un \"managed bean\":http://download.oracle.com/javaee/6/api/javax/annotation/ManagedBean.html.\n - @Inject UserTransaction := Injecte une transaction JTA directement dans le test, un service fourni au managed bean par CDI (JSR-299).\n \n Pour ne pas encombrer notre logique de test avec l'initialisation de la persistance, nous allons ajouter des méthodes qui seront exécutées avant et après chaque exécution de test. Jetons un coup d'oeil à ce code.\n@@ -245,7 +245,7 @@ Notez que nous devons explicitement joindre l' @EntityManager@ à la transaction\n \n h4. Requête JPQL\n \n-Vous trouverez ici un test qui vérifie qu'on puisse accéder aux enregistrements en JPQL. Nous avons laissé quelques traces pour mieux suivre se passe.\n+Vous trouverez ici un test qui vérifie qu'on puisse accéder aux enregistrements en JPQL. Nous avons laissé quelques traces pour mieux suivre ce qui se passe.\n \n bc(prettify).. <!-- clip -->\n import java.util.List;\n@@ -353,7 +353,7 @@ p. Puis faites un clic droit sur le projet et sélectionnez Properties. Dépliez\n \n Vous devriez voir le fichier @Game_.java@ dans le répertoire target/generated-sources/annotations , qui devrait être dans le build path.\n \n-p(info). %Oui, vous devez bidouiller un peu, tout comme vous devez mettre un coup de latte au distributeur automatique de friandises pour qu'il laisse tomber votre friandise ~:) Si ça vous ennuie, vous pouvez passer l'étape de génération du méta-modèle et référencer simplement les colonnes avec des chaines de caractères.%\n+p(info). %Oui, vous devez bidouiller un peu, tout comme vous devez mettre un coup de latte au distributeur automatique de friandises pour qu'il laisse tomber votre friandise ~:) Si ça vous ennuie, vous pouvez passer l'étape de génération du méta-modèle et référencer simplement les colonnes avec des chaînes de caractères.%\n \n Finalement, vous voilà prêt à écrire la requête Criteria.\n \n@@ -389,9 +389,9 @@ public void shouldFindAllGamesUsingCriteriaApi() throws Exception {\n     assertContainsAllGames(games);\n }\n \n-p. Pour que JPA fonctionne, il a besoin d'un Persistence Unit.\n+p. Pour que JPA fonctionne, il a besoin d'une Persistence Unit.\n \n-Nous définissons le Persistence Unit dans un fichier test-persistence.xml correspondant au conteneur cible. Shrinkwrap récupère ce fichier depuis le classpath et le copie à la position standard dans l'archive. \n+Nous définissons la Persistence Unit dans un fichier test-persistence.xml correspondant au conteneur cible. Shrinkwrap récupère ce fichier depuis le classpath et le copie à la position standard dans l’archive.\n \n bc(prettify). .addAsResource(\"test-persistence.xml\", \"META-INF/persistence.xml\")\n \n@@ -473,7 +473,7 @@ bc(prettify). <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n     </jdbc-connection-pool>\n </resources>\n \n-Nous avons ainsi isolé la définition de la DataSource du reste du test de la même façon dont avons procédé pour l'application principale. L'intérêt supplémentaire est que nous pouvons définir n'importe quelle ressource dont nous aurions besoin pour notre test. Je vous laisse imaginer les possibilités.\n+Nous avons ainsi isolé la définition de la DataSource du reste du test de la même façon dont nous avons procédé pour l'application principale. L'intérêt supplémentaire est que nous pouvons définir n'importe quelle ressource dont nous aurions besoin pour notre test. Je vous laisse imaginer les possibilités.\n \n A présent, nous devons dire à Arquillian d'utiliser ce fichier. Nous ouvrons la configuration Arquillian et configurons l'adaptateur du conteneur Glassfish embarqué pour qu'il prenne ce fichier, avec lequel il alimentera la commande @add-resources@ de l'API d'administration de Glassfish.\n \n@@ -673,7 +673,7 @@ Nous pouvons exécuter exactement le même test dans JBoss AS 7 en faisant quelq\n \n Nous aurons besoin d'un Persistence Unit différent, qui utilise une DataSource disponible dans JBoss AS et qui positionne quelques paramètres Hibernate.\n \n-Si nous étions dans JBoss AS 7.0, nous aurions besoin d'\"ajouter manuellement une DataSource dans la configuration de JBoss AS\":https://docs.jboss.org/author/display/AS7/Admin+Guide#AdminGuide-Datasources ou d'utiliser la DataSource intégrée, java:jboss/datasources/ExampleDS. Voici le descripteur du Persistence Unit pour JBoss AS 7.0 qui utilise la DataSource intégrée.\n+Si nous étions dans JBoss AS 7.0, nous aurions besoin de pouvoir \"ajouter manuellement une DataSource dans la configuration de JBoss AS\":https://docs.jboss.org/author/display/AS7/Admin+Guide#AdminGuide-Datasources ou d'utiliser la DataSource intégrée, java:jboss/datasources/ExampleDS. Voici le descripteur de la Persistence Unit pour JBoss AS 7.0 qui utilise la DataSource intégrée.\n \n div(filename). src/test/resources-jbossas-managed/test-persistence.xml\n \n@@ -739,7 +739,7 @@ Nous devons aussi ajouter le descripteur au répertoire WEB-INF de l'archive de\n \n bc(prettify). .addAsWebInfResource(\"jbossas-ds.xml\")\n \n-Inclure ce fichier dans l'archive n'a pas d'impact sur la capacité à exécuter le test dans Glassfish embarqué. La DataSource et le Persistence Unit sont prêts à l'emploi.\n+Inclure ce fichier dans l'archive n'a pas d'impact sur la capacité à exécuter le test dans Glassfish embarqué. La DataSource et la Persistence Unit sont prêtes à l'emploi.\n \n Maintenant nous avons besoin d'un profil Maven qui ajoute le conteneur JBoss AS, ainsi que les ressources JBoss AS dans le classpath :\n \n@@ -792,4 +792,4 @@ Vous pouvez exécuter ce test depuis votre IDE ! Importez juste votre projet, ac\n \n *Appréciez la recette idéale pour tester JPA !*\n \n-p(info). %Même si la préparation peut sembler longue, reconnaissez que nous avons fait le tour de la question. Pour vous en remémorer les avantages, regardez juste la simplicité du cas de test, et rappelez vous qu'il n'est lié à aucun conteneur Java EE 6 ou implémentation JPA 2 spécifiques.%\n+p(info). %Même si la préparation peut sembler longue, reconnaissez que nous avons fait le tour de la question. Pour vous en remémorer les avantages, regardez juste la simplicité du cas de test, et rappelez-vous qu'il n'est lié à aucun conteneur Java EE 6 ou implémentation JPA 2 spécifiques.%","filename":"guides/testing_java_persistence_fr.textile"}],"author":{"email":"ph.charriere@gmail.com","login":"k33g","name":"Philippe CHARRIERE"}}}