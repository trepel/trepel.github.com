{"commit":{"id":"28b0ff7c4b291a57f641c2c3292feb06fcd48a14","message":"Update guides/testing_java_persistence_fr.textile\n\nQuelques améliorations quitte à s'éloigner un peu de l'original","committer":{"name":"Aslak Knutsen","email":"aslak@redhat.com","login":"aslakknutsen"},"committed_date":"2012-08-30T10:41:19-07:00","url":"/arquillian/arquillian.github.com/commit/28b0ff7c4b291a57f641c2c3292feb06fcd48a14","authored_date":"2012-08-20T02:11:44-07:00","parents":[{"id":"e6c623e524a5d9e2cd6fd8e5086d18067c8e8484"}],"author":{"name":"Emmanuel Hugonnet","email":"emmanuel.hugonnet@gmail.com","login":"ehsavoie"},"modified":[{"filename":"guides/testing_java_persistence_fr.textile","diff":"@@ -13,13 +13,13 @@ Ce guide vous explique comment utiliser Arquillian pour tester la persistance Ja\n * enregistrer des entités puis les interroger via JPQL et l'API Criteria de JPA 2,\n * exécuter les tests en utilisant différents fournisseurs JPA.\n \n-Vous allez découvrir qu'Arquillian propose la recette idéale pour tester JPA ou simplement expérimenter comment ça fonctionne. Nous avons conçu ce guide de façon à ce qu'il soit facile à suivre pour que vous puissiez y revenir à chaque fois que vous aurez besoin de revenir sur JPA.\n+Vous allez découvrir qu'Arquillian propose la recette idéale pour tester JPA ou simplement expérimenter comment ça fonctionne. Nous avons conçu ce guide de façon à ce qu'il soit facile à suivre pour que vous puissiez vous y référer à chaque fois que vous aurez besoin de revenir sur JPA.\n \n h3. Hypothèses\n \n-Nous considérerons que vous avez déjà lu soit le guide \"Démarrage Rapide\":/guides/getting_started_fr, soit le guide \"Get Started Faster with Forge\":/guides/get_started_faster_with_forge et que vous avez mis en place une suite de tests Arquillian dans un projet Maven. Nous allons ajouter une entité JPA au projet afin de créer un test de persistance Java élémentaire (JPA). Vous pouvez aussi appliquer ces instructions à n'importe quelle autre entité que vous avez besoin de tester.\n+Nous considérerons que vous avez déjà lu soit le guide \"Démarrage Rapide\":/guides/getting_started_fr, soit le guide \"Get Started Faster with Forge\":/guides/get_started_faster_with_forge et que vous avez mis en place une suite de tests Arquillian dans un projet Maven. Nous allons ajouter une entité JPA au projet afin de créer un test élémentaire de persistance Java (JPA). Vous pouvez aussi appliquer ces instructions pour tester vos propres entités.\n \n-Les instructions dans ce guide sont spécifiques à un projet Maven, mais rappelez-vous qu'Arquillian n'est en aucune façon lié à Maven. Nous allons exécuter les tests dans un GlassFish embarqué et dans une instance JBoss AS 7 locale, mais vous pouvez utiliser n'importe quel conteneur supporté par Arquillian et qui supporte JPA.\n+Les instructions dans ce guide sont spécifiques à un projet Maven, mais rappelez-vous qu'Arquillian n'est en aucune façon lié à Maven. Nous allons exécuter les tests dans un serveur GlassFish embarqué et dans une instance locale de JBoss AS 7, mais vous pouvez utiliser n'importe quel conteneur supportant JPA supporté par Arquillian.\n \n p(warning). %Vous ne pouvez pas utiliser le conteneur arquillian-weld-ee-embedded dans ce tutoriel car Weld ne fournit pas de service JPA (Weld ne fournit que CDI).%\n \n@@ -72,7 +72,7 @@ Afin que vous puissiez prendre vos repères, voici la structure de répertoire d\n \n @Game@ est l'entité JPA et test-persistence.xml est une version modifiée de persistence.xml, qui fournit la définition de notre Persistence Unit pour l'environnement de test. Notez que deux répertoires contiennent un fichier test-persistence.xml, un pour chaque conteneur que nous utiliserons. Nous verrons cela plus tard. \n \n-Nous recommandons d'utiliser un descripteur JPA dédié aux tests, avec une DataSource de test et une configuration spécifique de votre fournisseur de persistance. Par exemple, en environnement de test, vous pourrez vouloir adopter une stratégie \"drop-and-create-tables\" pour gérer le schéma de la base de données. Vous pouvez aussi vouloir voir les requêtes à la base de données dans la sortie de traces. Ce paramètrage peut être réalisé dans test-persistence.xml sans affecter l'application principale, comme nous le verrons plus loin. Nous laisserons le fichier persistence.xml car c'est la définition pour l'environnement de production.\n+Nous recommandons d'utiliser un descripteur JPA dédié aux tests, avec une DataSource de test et une configuration spécifique de votre fournisseur de persistance. Par exemple, en environnement de test, vous pourrez vouloir adopter une stratégie \"drop-and-create-tables\" pour gérer le schéma de la base de données. Vous pouvez aussi vouloir voir les requêtes à la base de données dans la sortie de traces. Ce paramètrage peut être réalisé dans test-persistence.xml sans affecter l'application principale, comme nous le verrons plus loin. Nous laisserons donc de côté le fichier persistence.xml car c'est la configuration pour l'environnement de production.\n \n Voici le code source de l'entité @Game@, annotée en @@Entity@ :\n \n@@ -173,9 +173,9 @@ public class GamePersistenceTest {\n     // tests go here\n }\n \n-p. Etudions ceci depuis le début pour comprendre ce qu'il se passe avant de voir les tests.\n+p. Etudions ce code depuis le début pour comprendre ce qu'il se passe avant de voir les tests.\n \n-- @RunWith(Arquillian.class) := Dit à JUnit de déléguer l'exécution du test au runner Arquillian. Cela permet à Arquillian d'enrichir votre test avec un modèle de composant, avec une gestion de cycle de vie par un conteneur et l'injection de dépendance, entre autres. Notez que vous n'avez pas à étendre une classe de base, ce qui vous laisse libre pour d'autres besoins.\n+- @RunWith(Arquillian.class) := Indique à JUnit de déléguer l'exécution du test au runner Arquillian. Cela permet à Arquillian d'enrichir votre test avec un modèle de composant, une gestion de cycle de vie par un conteneur et l'injection de dépendance, entre autres. Notez que vous n'avez pas à étendre une classe de base, ce qui vous laisse libre pour d'autres besoins.\n - Méthode @Deployment := Produit une archive de \"micro-déploiement\" avec l'API \"ShrinkWrap\":http://jboss.org/shrinkwrap. Arquillian déploie cette archive dans le conteneur, incluant la classe de test et quelques classes d'infrastructure. Le test est alors exécuté comme un composant au sein de cette mini-application. Le périmètre de cette archive isole le test du reste du monde.\n - Constante GAME_TITLES := Données de test\n - @PersistenceContext EntityManager := Injecte le contexte de persistance (i.e. @EntityManager@) directement dans le test, comme si le test était un \"managed bean\":http://download.oracle.com/javaee/6/api/javax/annotation/ManagedBean.html.\n@@ -228,7 +228,7 @@ private void startTransaction() throws Exception {\n     em.joinTransaction();\n }\n \n-p. Nous aurons aussi besoin d'une méthode qui valide (commit) la transaction après chaque test, qui requiert un autre import :\n+p. Nous aurons aussi besoin d'une méthode qui valide (commit) la transaction après chaque test, ce qui requiert un autre import :\n \n bc(prettify).. <!-- clip -->\n import org.junit.After;\n@@ -239,7 +239,7 @@ public void commitTransaction() throws Exception {\n     utx.commit();\n }\n \n-p. Arquillian exécute les méthodes @@Before@ and @@After@ dans le conteneur, respectivement avant et après chaque méthode de test. La méthode @@Before@  est exécutée après que les injections aient été faites.\n+p. Arquillian exécute les méthodes @@Before@ and @@After@ dans le conteneur, respectivement avant et après chaque méthode de test. La méthode @@Before@ est exécutée après que les injections aient été faites.\n \n Notez que nous devons explicitement joindre l' @EntityManager@ à la transaction JTA. Cette étape est nécessaire car nous utilisons ces deux ressources indépendamment. Cela peut sembler étrange si vous avez l'habitude d'utiliser JPA depuis un EJB, où l'association est faite automatiquement.\n \n@@ -391,7 +391,7 @@ public void shouldFindAllGamesUsingCriteriaApi() throws Exception {\n \n p. Pour que JPA fonctionne, il a besoin d'un Persistence Unit.\n \n-Nous définissons le Persistence Unit dans un fichier test-persistence.xml correspondant au conteneur cible. Shrinkwrap prend ce fichier dans le classpath et le place à l'endroit standard dans l'archive. \n+Nous définissons le Persistence Unit dans un fichier test-persistence.xml correspondant au conteneur cible. Shrinkwrap récupère ce fichier depuis le classpath et le copie à la position standard dans l'archive. \n \n bc(prettify). .addAsResource(\"test-persistence.xml\", \"META-INF/persistence.xml\")\n \n@@ -435,12 +435,12 @@ bc(prettify). <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n     </persistence-unit>\n </persistence>\n \n-Nous renseignons deux propriétés spécifiques pour activer des fonctionnalités spécifiques à EclipseLink, le fournisseur intégré.\n+Nous renseignons deux propriétés spécifiques pour activer des fonctionnalités propre sexà EclipseLink, le fournisseur intégré.\n \n - eclipselink.ddl-generation := Configure la commande de génération du schéma de la base ; la valeur drop-and-create-tables indique à EclipseLink de générer la base de données conformément aux entités JPA, à chaque exécution.\n - eclipselink.logging.level.sql := Configure la journalisation des requêtes ; la valeur FINE active les traces des requêtes SQL, nous permettant de suivre l'activité sur la base de données.\n \n-Le logging d'EclipseLink devra aussi être configuré dans le fichier de configuration des logs standards de Java, en y activant le niveau FINE.\n+Les traces d'EclipseLink devront aussi être configurées dans le fichier de configuration des logs standards de Java, en y activant le niveau FINE.\n \n div(filename). src/test/resources-glassfish-embedded/logging.properties\n \n@@ -494,7 +494,7 @@ bc(prettify).. <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n     </container>\n </arquillian>\n \n-p. A la place de cela, nous pourrions sauter la configuration de la DataSource et simplement inclure les informations de connexion à la base de données directement dans test-persistence.xml, en utilisant les propriétés standard de connexion à la base :\n+p. A la place de cela, nous pourrions sauter l'étape de la configuration de la DataSource et simplement inclure les informations de connexion à la base de données directement dans test-persistence.xml, en utilisant les propriétés standard de connexion à la base :\n \n bc(prettify). <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <persistence version=\"2.0\" xmlns=\"http://java.sun.com/xml/ns/persistence\"\n@@ -515,9 +515,9 @@ bc(prettify). <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n     </persistence-unit>\n </persistence>\n \n-N'oubliez pas toutefois que le basculement d'une DataSource JNDI vers une connexion explicite change l'architecture entre l'environnement de production et celui de test, et ainsi réduit la confiance à accorder au test pour identifier toutes les défaillances potentielles.\n+N'oubliez pas toutefois que le basculement d'une DataSource JNDI vers une connexion explicite modifie l'architecture entre l'environnement de production et celui de test, et ainsi réduit la confiance à accorder aux tests pour identifier toute défaillance potentielle.\n \n-p. Tout ce qu'il reste à faire, c'est de configurer l'adaptateur de conteneur et d'exécuter le test.\n+p. Tout ce qu'il nous reste à faire, c'est de configurer l'adaptateur de conteneur et d'exécuter le test.\n \n h3. Préparer le Test pour GlassFish\n \n@@ -551,7 +551,7 @@ bc(prettify).. <!-- clip -->\n </dependencies>\n <!-- clip -->\n \n-p(warning). %Si vous prévoyez d'utiliser une base de données qui n'est pas incluse dans le serveur d'applications, comme MySQL, vous devrez inclure ses librairies client dans le classpath. Vous pouvez consulter le \"tutoriel\":http://github.com/arquillian/arquillian-examples/tree/master/arquillian-persistence-tutorial pour avoir un exemple d'utilisation de H2 à la place de Derby.%\n+p(warning). %Si vous prévoyez d'utiliser une base de données qui n'est pas incluse dans le serveur d'applications, comme MySQL, vous devrez inclure ses librairies clientes dans le classpath. Vous pouvez consulter le \"tutoriel\":http://github.com/arquillian/arquillian-examples/tree/master/arquillian-persistence-tutorial pour avoir un exemple d'utilisation de H2 à la place de Derby.%\n \n p. A présent, ajoutons (ou modifions) le profil pour Glassfish embarqué.\n \n@@ -605,7 +605,7 @@ bc(prettify). <!-- clip -->\n </profile>\n <!-- clip -->\n \n-Nous ajoutons explicitement le répertoire src/test/resources-glassfish-embedded comme une ressource de test afin que le fichier test-persistence.xml soit placé dans le classpath. Nous avons aussi configuré le plugin surefire pour qu'il passe le fichier de configuration du logging Java au processus en fork afin que le logging SQL fonctionne. Enfin, nous envoyons le fichier le log de Derby dans le répertoire cible du build afin qu'il soit évincé lorsqu'on nettoie le projet.\n+Nous ajoutons explicitement le répertoire src/test/resources-glassfish-embedded comme une ressource de test afin que le fichier test-persistence.xml soit placé dans le classpath. Nous avons aussi configuré le plugin surefire pour qu'il passe le fichier de configuration des traces Java au processus en fork afin que le logging SQL fonctionne. Enfin, nous envoyons le fichier le log de Derby dans le répertoire cible du build afin qu'il soit supprimé lorsqu'on nettoie le projet.\n \n p(info). %Si vous n'avez pas prévu de tester dans différents conteneurs, vous n'avez pas besoin de mettre la configuration ci-dessus dans un profil.%\n "}],"tree":"d6e894fbe79eef61ad47e0ee59491cfb1743367c"}}