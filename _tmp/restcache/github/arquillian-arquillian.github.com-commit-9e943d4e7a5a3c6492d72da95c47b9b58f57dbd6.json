{"commit":{"committer":{"email":"aslak@redhat.com","login":"aslakknutsen","name":"Aslak Knutsen"},"authored_date":"2012-09-09T15:59:23-07:00","id":"9e943d4e7a5a3c6492d72da95c47b9b58f57dbd6","message":"Update getting_started_ja","committed_date":"2012-09-11T03:50:53-07:00","url":"/arquillian/arquillian.github.com/commit/9e943d4e7a5a3c6492d72da95c47b9b58f57dbd6","parents":[{"id":"3181d0edd31dc15cc723954d7f669b1f29269406"}],"tree":"213e6405b45a535cd73e6cbc00766a654b947ea5","modified":[{"diff":"@@ -32,7 +32,7 @@ Arquillianを始める最もシンプルな方法は、依存性の管理をし\n \n p(info). %ArquillianはMavenには、もっと言えばどんな特定のビルドツールにも依存しません。それはAntやGradleでビルドするプロジェクトで使っても--より優れているとは言わないまでも--同じように機能します。理想的には、ビルドツールは、 \"Maven Central repository\":maven_search で配布されているArquillianライブラリをプロジェクトに追加するタスクを単純化できる、依存性管理を提供している物がいいでしょう。%\n \n-このガイドは、読者がコマンドシェルとIDE(Integrated Development Environment:統合開発環境)からMavenを利用できると仮定しています。もしそうでなければ、 \"Mavenをダウンロードしてインストールしてください\":maven_download 。 また、 \"JDK(Java Development Kit) 1.5\":jdk_download 以降のインストールが必要です。\n+このガイドは、読者がコマンドシェルとIDE(Integrated Development Environment:統合開発環境)からMavenを利用できると仮定しています。もしそうでなければ、 \"Mavenをダウンロードしてインストールしてください\":maven_download 。 また、 \"JDK(Java Development Kit) 1.5\":jdk_download 以降のインストールが必要で、JDK 1.6を推奨します。\n \n h3. 新しいプロジェクトを作成する\n \n@@ -76,15 +76,15 @@ p. このコマンドは、カレントディレクトリに @arquillian-tutoria\n *** resources/ - すべてのテスト用の設定ファイルをここに置きます。（例：arquillian.xml）\n * pom.xml - Mavenのビルドファイルです。Mavenでどのようにプロジェクトをビルドするか定義します。\n \n-p(info). %このプロジェクトは、Arquillianがそれぞれ最低限要求するバージョンであるJava 1.6とJUnit 4.8を使用するようにあらかじめ設定されています。%\n-\n プロジェクトジェネレータはまた、2つの @java@ フォルダの下に、 @org.arquillian.example@ というJavaパッケージを作成しています。 @java@ フォルダ直下ではなく、このパッケージの下にJavaソースファイルを置いてください。\n \n-p(warning). %Arquillianはまた、TestNG 5をサポートしています。しかしこのガイドでは、JUnitを使用します。%\n+さて、エディタで @pom.xml@ を開いてください。XMLファイルには、基本的なプロジェクト情報、ビルドセクション、依存セクションが含まれているのが分かります。\n \n-さて、エディタで @pom.xml@ を開いてください。XMLファイルには、基本的なプロジェクト情報、ビルドセクション、依存セクションが含まれているのが分かります。 *JUnitより下の @<dependency>@ 要素は不要なので削除してください。*\n+p(info). %このプロジェクトは、Arquillianがそれぞれ最低限要求するバージョンであるJava 1.6とJUnit 4.8を使用するようにあらかじめ設定されていることに気づくでしょう。%\n \n-編集が終わったら、以下のようになっているはずです（表示上、簡潔にしてあります）：\n+p(warning). %Arquillianはまた、TestNG 5をサポートしています。しかしこのガイドでは、JUnitを使用します。%\n+\n+*JUnitのdependencyより下の @<dependency>@ 要素は、不要なので削除してもかまいません。* 編集が終わったら、以下のようになっているはずです（少し整形しています）：\n \n div(filename). pom.xml\n \n@@ -155,7 +155,7 @@ bc(prettify).. <!-- clip -->\n </dependencies>\n <!-- clip -->\n \n-p(important). % @org.jboss.spec:jboss-javaee-6.0@ アーティファクトは、Java EE 6 APIだけで構成されています。Java EE APIアーティファクトを、 @javax:javaee-api@ と組み合わせて *使わない* ことを強くおすすめします。後者のアーティファクトには、メソッドの実装を省いたクラスが含まれているので、実行時に（テストの実行時でも）これがクラスパスに残っていた場合、アプリケーションは奇妙なAbsent Codeエラーを投げます。もっと背景を知りたい場合は、 \"このFAQを読んでください\":http://community.jboss.org/wiki/WhatsTheCauseOfThisExceptionJavalangClassFormatErrorAbsentCode 。%\n+p(important). %@org.jboss.spec:jboss-javaee-6.0@ アーティファクトは、Java EE 6 APIだけで構成されています。Java EE APIアーティファクトを、 @javax:javaee-api@ と組み合わせて *使わないことを強く* おすすめします。後者のアーティファクトには、メソッドの実装を省いたクラスが含まれているので、実行時に（テストの実行時でも）これがクラスパスに残っていた場合、アプリケーションは奇妙なAbsent Codeエラーを投げます。もっと背景を知りたい場合は、 \"このFAQを読んでください\":http://community.jboss.org/wiki/WhatsTheCauseOfThisExceptionJavalangClassFormatErrorAbsentCode 。%\n \n p. プロジェクトの基本は準備できました！ \"プロジェクトをEclipseで開く\":#open_the_project_in_eclipse に進んでください。コードを書きはじめます！\n \n@@ -163,9 +163,10 @@ h4(#create_project_using_forge). Forgeでプロジェクトを生成する\n \n \"JBoss Forge\":forge_home は、標準ベースの環境で高速アプリケーション開発をするためのコマンドシェルです。別の見方をすれば、ドーピングしたMaven Archetypeのようなものです。\n \n-Forgeのインストールは、比較的短い手順であり、このガイドでは、基礎を体験します。以下の、簡単なステップに従ってインストールしてください：\n+Forgeのインストールは、比較的短い手順であり、このガイドでは、基礎を体験します。以下の簡単なステップに従ってインストールしてください：\n \n-# \"Forgeをダウンロード\":forge_download し、ディスクに展開します。展開したフォルダを @$FORGE_HOME@ と呼びます。\n+# \"Forgeをダウンロード\":forge_download\n+# ダウンロードしたディストリビューションをディスクの任意の場所に展開します。展開されたフォルダを @$FORGE_HOME@ と呼びます。\n   ホームディレクトリの @forge@ というフォルダに配布物を展開したと仮定します。\n # @$FORGE_HOME/bin@ を（WindowsやLinux、Mac OSXの）パスに追加します。\n \n@@ -217,12 +218,16 @@ bc(command). [arquillian-tutorial] arquillian-tutorial $\n \n 次に追加する必要があるのは、Java EE APIです。以下の @project add-dependency@ コマンドでできます：\n \n-bc(command). $ project add-dependency org.jboss.spec:jboss-javaee-6.0:1.0.0.Final:pom:provided\n+bc(command). $ project add-dependency org.jboss.spec:jboss-javaee-6.0:1.0.0.Final:provided:pom\n \n また、Arquillianが最低限要求するバージョンである、JUnit 4.8をテストスコープの依存性として追加する必要があります：\n \n bc(command). $ project add-dependency junit:junit:4.8.1:test\n \n+Forgeは、JBoss Communityリポジトリをpom.xmlファイルに追加します。このリポジトリはArquillianに関しては不要です。（しかし、JBoss Commuityリポジトリにしかない他のライブラリを利用しているならば、残しておくこともできます。）リポジトリを削除すると決めれば、以下のForgeのコマンドで簡単に実行できます：\n+\n+bc(command). $ project remove-repository http://repository.jboss.org/nexus/content/groups/public \n+\n Forgeが生成したpom.xmlを以下に示します：\n \n div(filename). pom.xml\n@@ -242,8 +247,8 @@ bc(prettify).. <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n             <groupId>org.jboss.spec</groupId>\n             <artifactId>jboss-javaee-6.0</artifactId>\n             <version>1.0.0.Final</version>\n-            <type>provided</type>\n-            <scope>pom</scope>\n+            <type>pom</type>\n+            <scope>provided</scope>\n         </dependency>\n         <dependency>\n             <groupId>junit</groupId>\n@@ -252,12 +257,6 @@ bc(prettify).. <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n             <scope>test</scope>\n         </dependency>\n     </dependencies>\n-    <repositories>\n-      <repository>\n-          <id>JBOSS_NEXUS</id>\n-          <url>http://repository.jboss.org/nexus/content/groups/public</url>\n-      </repository>\n-    </repositories>\n     <build>\n         <finalName>arquillian-tutorial</finalName>\n         <plugins>\n@@ -273,10 +272,6 @@ bc(prettify).. <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n     </build>\n </project>\n \n-p(info). %Arquillianは、Mavenセントラルリポジトリで配布されていて、そのためpom.xmlのJBossパブリックリポジトリの記述は不要で、削除できます。しかしMavenセントラルでは入手できない他のJBossソフトウェアを取得するために必要になるかもしれないことは、覚えておいてください。%\n-\n-p(warning). %もし、プロジェクトのpom.xmlにリポジトリを明記するのはアンチパターンだと考えるなら、settings.xmlでリポジトリをユーザーグローバルに友好にするために \"この説明\":http://community.jboss.org/wiki/MavenGettingStarted-Users を読んでください。%\n-\n p. プロジェクトの基本は準備できました！Eclipseでプロジェクトを開きましょう。コードを書きはじめます！\n \n h3(#open_the_project_in_eclipse). プロジェクトをEclipseで開く\n@@ -386,17 +381,29 @@ p. Arquillian-JUnitインテグレーションアーティファクトは、Arqu\n \n p(info). %JUnitの代わりにTestNGを使うためには、Arquillian JUnitインテグレーションをArquillian TestNGインテグレーションで置き換えてください。%\n \n-p. ここまでで、pom.xmlになにか問題があれば、 \"このgist\":https://gist.github.com/1263892 からダウンロードできます。\n+（オプション） \"このFAQ\":https://community.jboss.org/wiki/WhatVersionOfSurefireShouldIUseToRunMyArquillianTestsInAMavenBuild で説明しているように、MavenのSurefireプラグインをデフォルトのバージョンからアップグレードすることをお勧めします。Surefire Pluginのバージョンは、 @<plugins>@ 要素内の、Maven Compiler Pluginの下に、以下の @<plugin>@ 要素を加えると設定できます：\n+\n+div(filename). pom.xml\n+\n+bc(prettify).. <!-- clip -->\n+<plugin>\n+    <groupId>org.apache.maven.plugins</groupId>\n+    <artifactId>maven-surefire-plugin</artifactId>\n+    <version>2.12</version>\n+</plugin>\n+<!-- clip -->\n+\n+p. ここまでで、pom.xmlになにか問題があれば、 \"pom-no-container-profiles.xml\":https://raw.github.com/arquillian/arquillian-examples/master/arquillian-tutorial/pom-no-container-profiles.xml ファイルを \"サンプルプロジェクト\":https://github.com/arquillian/arquillian-examples/tree/master/arquillian-tutorial からダウンロードできるので、pom.xmlにリネームしてください。\n \n *最初のArquillianテストを書く準備ができました！*\n \n h3. Arquillianテストを書く\n \n-Arquillianテストは、すこし余分なフレアのある、単なるユニットテストのように見えます。IDEに戻りましょう。\n+Arquillianテストは、すこし余分なフレアのある、単なるユニットテストのように見えます。IDEに戻って一つ作成しましょう。\n \n p(warning). %もし\"Project configuration is out of date with pom.xml\"というメッセージが表示されたら、プロジェクトを再同期するために右クリックしてProject > Maven > Update Project Configurationを選択してください.%\n \n-src/test/javaにて、 @org.arquillian.example@ パッケージ以下に @GreeterTest@ という新しいJUnitテストケースを作成することから始めます。力仕事はほとんどArquillianがやるので、よくあるsetupとteardownメソッドは不要です。今のところ、次のようになります：\n+src/test/javaにて、@GreeterTest@ という新しいJUnitテストケースを作成し、パッケージ名を @org.arquillian.example@ として始めます。力仕事はほとんどArquillianがやるので、よくあるsetupとtearDownメソッドは不要です。今のところ、次のようになります：\n \n div(filename). src/test/java/org/arquillian/example/GreeterTest.java\n \n@@ -415,14 +422,16 @@ public class GreeterTest {\n p. では、フレアについてです。Arquillianテストケースは、以下の3点が必要です：\n \n # クラスへの @@RunWith(Arquillian.class)@ アノテーションの付加\n-# @@Deployment@ でアノテートされ、ShrinkWrapアーカイブを返すスタティックメソッド\n+# @@Deployment@ でアノテートされ、ShrinkWrapアーカイブを返すパブリックなスタティックメソッド\n # @@Test@ でアノテートされた、少なくとも一つのメソッド\n \n-@@RunWith@ アノテーションは、JUnitに、Arquillianをテストコントローラとして使用することを伝えます。Arquillianはテストアーカイブ（つまり、マイクロデプロイメント）を受け取るために @@Deployment@ アノテーションのついたメソッドを探します。そしてマジックが起きて、それぞれの @@Test@ メソッドはコンテナ環境内で実行されます。\n+@@RunWith@ アノテーションは、JUnitに、Arquillianをテストコントローラとして使用することを伝えます。Arquillianはテストアーカイブ（つまり、マイクロデプロイメント）を受け取るために @@Deployment@ アノテーションのついたパブリックなスタティックメソッドを探します。そしてマジックが起きて、それぞれの @@Test@ メソッドはコンテナ環境内で実行されます。\n \n h4. テストアーカイブとは？\n \n-テストアーカイブの目的は、テストに必要なクラスとリソースを、クラスパスにあるそれ以外から隔離することです。通常のユニットテストとは異なり、Arquillianは単純にクラスパス上のすべてに手をつけることはしません。その代わり、テストに必要なもの（もしクラスパス上のすべてと決めれば、それかもしれません）だけを含めます。このアーカイブは、 \"ShrinkWrap\":shrinkwrap_home を使って定義されます。これはアーカイブ（つまり、jar、war、ear）作成用のJava APIです。マイクロデプロイメントストラテジーにより、明確にテストしたいクラスにフォーカスできます。その結果として、テストは無駄のない状態のまま保たれます。\n+テストアーカイブの目的は、テストに必要なクラスとリソースを、クラスパスにあるそれ以外から隔離することです。通常のユニットテストとは異なり、Arquillianは単純にクラスパス上のすべてをタップしたりしません。その代わり、テストに必要なもの（もしクラスパス上のすべてと決めれば、それかもしれません）だけを含めます。このアーカイブは、 \"ShrinkWrap\":shrinkwrap_home を使って定義されます。これはアーカイブ（つまり、jar、war、ear）作成用のJava APIです。マイクロデプロイメントストラテジーにより、明確にテストしたいクラスにフォーカスできます。その結果として、テストは無駄のない状態のまま保たれます。\n+\n+一度ShrinkWrapアーカイブがサーバーにデプロイされると、それは現実のアーカイブになります。そのコンテナのデプロイヤーはそのアーカイブがShrinkWrapによってアーカイブされたことについてはまったく知りません。ShrinkWrapについては、一つだけ例外的な部分のあるJavaベースのビルドツールと考えることもできます。最適なケースでは、ディスクにアーカイブを書き込むことなくサーバーに送ります。それでもそれが作るのは、本物のアーカイブです。\n \n p(info). %また、ShrinkWrapはアーティファクト（ライブラリ）の解決をサポートします。プログラム的に設定ファイルを作成し、テストアーカイブに追加します。ShrinkWrapのより詳細な説明は、 \"ShrinkWrap introduction\":/guides/shrinkwrap_introduction を参照してください。%\n \n@@ -459,6 +468,29 @@ public class GreeterTest {\n \n p. ShrinkWrapを使って、Javaアーカイブ（jar）をデプロイメントとして定義しました。このアーカイブは、テスト対象の @Greeter@ クラスと、META-INFディレクトリ内にこのアーカイブでCDIを有効にするための空のbeans.xmlファイルを含みます。\n \n+もしテスト実行時にShrinkWrapが作成したアーカイブの内容を見たければ、アーカイブを返す前に内容を標準出力（つまり、コンソール）に出力することができます。\n+\n+bc(prettify).. @Deployment\n+public static JavaArchive createDeployment() {\n+    JavaArchive jar = ShrinkWrap.create(JavaArchive.class)\n+        .addClass(Greeter.class)\n+        .addAsManifestResource(EmptyAsset.INSTANCE, \"beans.xml\");\n+    System.out.println(jar.toString(true));\n+    return jar;\n+}\n+\n+p. このコードは、テスト実行時に以下のように出力します：\n+\n+bc(output). 2ac9cd28-a71a-479a-a785-750b40221766.jar:\n+/META-INF/\n+/META-INF/beans.xml\n+/org/\n+/org/arquillian/\n+/org/arquillian/example/\n+/org/arquillian/example/Greeter.class\n+\n+明示的に指定しなかったので、ShrinkWrapは、このアーカイブにランダムな名前を割り当てています。別の \"Getting Started: Rinse and Repeat\":/guides/getting_started_rinse_and_repeat/#export_the_deployment ガイドで、アーカイブを特定する他の方法を説明します。\n+\n ここでやるべきことは、テストメソッドの上で @Greeter@ インスタンスを直接フィールドに注入し、未実装のテストメソッドをそのbeanの振る舞いを検証するものに置き換えることです。読者に和んでもらえるように、コンソールにも挨拶を出力します。テストメソッドを以下のように置き換えて @javax.inject.Inject@ のインポート文を追加してください。\n \n div(filename). src/test/java/org/arquillian/example/GreeterTest.java\n@@ -522,7 +554,7 @@ h3. コンテナアダプタを追加する\n \n これまで、コンテナでテストすることについて数多く語ってきましたが、今のところどれを使うかは検討しませんでした。それは、実行時に決定することだからです。\n \n-Arquillianは、テストクラスパスで利用可能なコンテナの中からターゲットコンテナを選択します。だから、プロジェクトにもっとライブラリを追加します。\n+Arquillianは、テストクラスパスで利用可能なコンテナの中からターゲットコンテナを選択します。 _コンテナアダプタ_ は、コンテナをコントロールし、通信するものです（コンテナそのものではありません）。だから、プロジェクトにもっとライブラリを追加します。\n \n Arquillianのテストは、テストで使用するプログラミングモデルと互換性があるならば（つまり、コンテナ用のArquillianアダプタがあるならば）どんなコンテナでも実行できます。私達のテストは、CDIプログラミングモデルを使用しているので、CDIをサポートするコンテナを使う必要があります。開発中は高速にターンアラウンドしたいので、Weld EEエンベデッドコンテナから始めましょう。\n \n@@ -826,19 +858,26 @@ bc(prettify).. <!-- clip -->\n             <version>7.1.1.Final</version>\n             <scope>test</scope>\n         </dependency>\n+        <dependency>\n+            <groupId>org.jboss.arquillian.protocol</groupId>\n+            <artifactId>arquillian-protocol-servlet</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n     </dependencies>\n </profile>\n <!-- clip -->\n \n+p(info). %デフォルトでは、JBoss AS 7はテストアーカイブをJMXプロトコルを使ってデプロイします。すでに、今後必要になったときのために、このサーブレットプロトコルの依存性を @arquillian-jbossas-managed@ プロファイルに追加しています。こちらに変更する方法は、\"このFAQ\":https://community.jboss.org/wiki/WhyDoIGetNoActiveContextsForScopeTypeWhenTestingOnJBossAS7 を参照してください。%\n+\n p. これで、このテストは3つのコンテナの中から一つを選んで実行できるようになりました。\n \n-p. ここまでで、pom.xmlになにか問題があれば、 \"このgist\":https://gist.github.com/1263934 からダウンロードできます。\n+p. ここまでで、pom.xmlになにか問題があれば、 \"pom.xml\":https://raw.github.com/arquillian/arquillian-examples/master/arquillian-tutorial/pom.xml ファイルを \"サンプルプロジェクト\":https://github.com/arquillian/arquillian-examples/tree/master/arquillian-tutorial からダウンロードできます。\n \n h3. コンテナを越えてテストする\n \n Eclipseでプロジェクトをリフレッシュしたら、ビルドされないことに気づくでしょう。これは、コンテナプロファイルのどれかを有効にする必要があるからです。前の状態を復元するためにWeld EEエンベデッドプロファイルを有効にしましょう。\n \n-EclipseでMavenプロファイルを有効にするには、2つのやり方があります：\n+EclipseでMavenプロファイルを有効にするには、2つのやり方があります（ \"Maven Integration for Eclipse\":http://www.eclipse.org/m2e を前提としています）：\n \n # 手動で設定（標準的なやり方）\n # Maven profile selector (JBoss Tools)\n@@ -871,9 +910,31 @@ JBoss Toolsがインストール済みなら、有効なプロファイルの選\n \n 一度プロファイルを有効化したら、コンパイラのエラーは消え、テストはまた成功するはずです。\n \n+プロファイルを有功にする別の方法としては、どれかのプロファイルをデフォルトで有効になるように設定します。 プロファイル定義に @<activation>@ エレメントを追加して、Weld EE Embeddedプロファイルをデフォルトにしてみましょう：\n+\n+div(filename). pom.xml\n+\n+bc(prettify).. <!-- clip -->\n+<profile>\n+    <id>arquillian-weld-ee-embedded</id>\n+    <activation>\n+        <activeByDefault>true</activeByDefault>\n+    </activation>\n+    <dependencies>\n+        <!-- hidden -->\n+    </dependencies>\n+</profile>\n+<!-- clip -->\n+\n+p. 自動的にプロファイルが選択されるようになったので、もうIDEでプロファイルを選択する必要はなくなりました。しかし、他のプロファイル（だけ）を使う場合、まずこのプロファイルをデフォルトからの解除が必要です。\n+\n h4. コンテナを切り替える\n \n-すでにこのテストがWeld EEエンベデッドで成功することはわかっています。上のステップを繰り返してGlassFishエンベデッドに切り替え、今回は @arquillian-glassfish-embedded@ だけを有効にします。テストをまた実行。GlassFishがコンソールで起動するのが見えて…今度も *(greenbar)グリーンバー* です！\n+すでにこのテストがWeld EEエンベデッドで成功することはおわかりですね。上のステップを繰り返してGlassFishエンベデッドに切り替え、今回は @arquillian-glassfish-embedded@ だけを有効にします。\n+\n+p(info). %Weld EEエンベデッドをデフォルトにする場合、他のプロファイルを確実に無効にしてください。Mave Profle selectorで、エントリを右クリックして、コンテキストメニューからDeactiveを選択すると、プロファイルを無効にできます。これで、プロファイル名の前にエクスクラメーションマークが表示されます（例えば、 @!arquillian-weld-ee-embedded@ ）。複数のファイルが選択されている（または無効化されている）のは、コンマで分けられています。%\n+\n+テストをまた実行。GlassFishがコンソールで起動するのが見えて…今度も *(greenbar)グリーンバー* です！\n \n これで、同じテストを異なる二つのエンベデッドコンテナで実行しました。CDIコンテナ（Weld）とJava EEコンテナ（GlassFish）です。どちらも実行はプロセス内です。純粋な環境でコンポーネントが正常に動作するか本当に確認するには、スタンドアロンのコンテナが必要です。JBoss ASを使うよう切り替えましょう。\n \n@@ -893,7 +954,7 @@ h4. コンテナを切り替える\n \n p(info). %標準出力に出力されるメッセージは、コンソールではなくサーバーログに出力されるので、そちらで見てください。%\n \n-Mavenでこのタスクを実行したい場合（オプション）、 @arq-jbossas-managed@ の @id@ の後に、以下のXMLフラグメントを追加してください：\n+Mavenでこのタスクを実行したい場合（オプション）、 @arquillian-jbossas-managed@ プロファイルの @<id>@ 要素の後に、以下のXMLフラグメントを追加してください：\n \n div(filename). pom.xml\n \n@@ -928,7 +989,7 @@ bc(prettify).. <!-- clip -->\n </build> \n <!-- clip -->\n \n-p. MavenでダウンロードしたJBoss AS 7マネージドインスタンスをターゲットにするには、もう少しArquillianに設定が必要です。以下の設定ファイルを作成し、 @jbossHome@ プロパティの値を、JBoss AS 7がインストールされた場所にします。Maven依存プラグインを使っている場合は、場所は、 @target/jboss-as-7.0.2.Final@ です。\n+p. MavenでダウンロードしたJBoss AS 7マネージドインスタンスをターゲットにするには、もう少しArquillianに設定が必要です。以下の設定ファイルを作成し、 @jbossHome@ プロパティの値を、JBoss AS 7がインストールされた場所にします。Maven依存プラグインを使っている場合は、場所は、 @target/jboss-as-7.1.1.Final@ です。\n \n div(filename). src/test/resources/arquillian.xml\n ","filename":"guides/getting_started_ja.textile"}],"author":{"email":"tkonishi@redhat.com","login":"","name":"Takayuki Konishi"}}}