{"commit":{"tree":"01f573f0c4d0845c092e4e2b7e52794609431e2c","parents":[{"id":"2c4d506316631ebb54c588622dfd89905c42463c"}],"authored_date":"2012-02-14T14:56:14-08:00","id":"c02851bdd6f06c244b35f3c31762fde251b64ceb","added":["ejb3/src/main/java/org/jboss/as/ejb3/remote/EJBRemoteTransactionPropagatingInterceptor.java","ejb3/src/main/java/org/jboss/as/ejb3/remote/EJBRemoteTransactionPropagatingInterceptorFactory.java","remoting/src/main/java/org/jboss/as/remoting/RemoteOutboundConnectionResourceDefinition.java"],"url":"/jbossas/jboss-as/commit/c02851bdd6f06c244b35f3c31762fde251b64ceb","committer":{"email":"maasvdberg@gmail.com","name":"Maas van den Berg","login":"maasvdberg"},"committed_date":"2012-02-17T13:00:49-08:00","removed":["ejb3/src/main/java/org/jboss/as/ejb3/remote/EJBRemoteTransactionPropogatingInterceptor.java","ejb3/src/main/java/org/jboss/as/ejb3/remote/EJBRemoteTransactionPropogatingInterceptorFactory.java","remoting/src/main/java/org/jboss/as/remoting/RemoteOutboundConnnectionResourceDefinition.java"],"message":"spelling and typos\n\nspelling and typos","author":{"email":"maasvdberg@gmail.com","name":"Maas van den Berg","login":"maasvdberg"},"modified":[{"filename":"appclient/src/main/java/org/jboss/as/appclient/component/ApplicationClientComponentDescription.java","diff":"@@ -53,8 +53,8 @@ public boolean isIntercepted() {\n     }\n \n     @Override\n-    public ComponentConfiguration createConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoder, final ModuleLoader moduleLoader) {\n-        final ComponentConfiguration configuration =  super.createConfiguration(classIndex, moduleClassLoder, moduleLoader);\n+    public ComponentConfiguration createConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoader, final ModuleLoader moduleLoader) {\n+        final ComponentConfiguration configuration =  super.createConfiguration(classIndex, moduleClassLoader, moduleLoader);\n         configuration.setInstanceFactory(new ManagedReferenceFactory() {\n             @Override\n             public ManagedReference getReference() {"},{"filename":"appclient/src/main/java/org/jboss/as/appclient/deployment/ActiveApplicationClientProcessor.java","diff":"@@ -34,7 +34,7 @@\n import static org.jboss.as.appclient.logging.AppClientMessages.MESSAGES;\n \n /**\n- * Processor that determines which application client should be started. This may be specifed on the command line,\n+ * Processor that determines which application client should be started. This may be specified on the command line,\n  * or alternatively if there is only one app client in the deployment it will be used.\n  *\n  * @author Stuart Douglas"},{"filename":"appclient/src/main/java/org/jboss/as/appclient/deployment/ApplicationClientDependencyProcessor.java","diff":"@@ -41,7 +41,7 @@\n  * DUP that handles app client dependencies.\n  *\n  * This DUP is quite unusual, as it will also remove dependencies if they refer to\n- * dependencies that are not accisible to the application client. This allows a server\n+ * dependencies that are not accessible to the application client. This allows a server\n  * side deployment to reference another module, while still allowing the app client to\n  * function when that additional deployment is not present.\n  *"},{"filename":"appclient/src/main/java/org/jboss/as/appclient/deployment/ApplicationClientDescriptorMethodProcessor.java","diff":"@@ -42,7 +42,7 @@\n import static org.jboss.as.appclient.logging.AppClientMessages.MESSAGES;\n \n /**\n- * Deployment descriptor that resolves interceptor methods definined in ejb-jar.xml that could not be resolved at\n+ * Deployment descriptor that resolves interceptor methods defined in ejb-jar.xml that could not be resolved at\n  * DD parse time.\n  *\n  * @author Stuart Douglas"},{"filename":"appclient/src/main/java/org/jboss/as/appclient/subsystem/ApplicationClientConfigurationPersister.java","diff":"@@ -65,8 +65,8 @@\n      */\n     private final String hostUrl;\n \n-    public ApplicationClientConfigurationPersister(final String filePath, final String deploymentName, final String hostUrl, final List<String> parameters, final File configFile, final QName element, final XMLElementReader<List<ModelNode>> xmlparser) {\n-        super(configFile, element, xmlparser, null);\n+    public ApplicationClientConfigurationPersister(final String filePath, final String deploymentName, final String hostUrl, final List<String> parameters, final File configFile, final QName element, final XMLElementReader<List<ModelNode>> xmlParser) {\n+        super(configFile, element, xmlParser, null);\n         this.filePath = filePath;\n         this.deploymentName = deploymentName;\n         this.hostUrl = hostUrl;"},{"filename":"arquillian/protocol-jmx/src/main/java/org/jboss/as/arquillian/protocol/jmx/JMXProtocolPackager.java","diff":"@@ -106,11 +106,11 @@ private JavaArchive generateArquillianServiceArchive(Collection<Archive<?>> auxA\n         archive.addPackage(ArquillianService.class.getPackage());\n         archive.addPackage(AbstractJMXProtocol.class.getPackage());\n \n-        // Merge the auxilliary archives and collect the loadable extensions\n+        // Merge the auxiliary archives and collect the loadable extensions\n         final Set<String> loadableExtensions = new HashSet<String>();\n-        final String loadableExtentionsPath = \"META-INF/services/\" + RemoteLoadableExtension.class.getName();\n+        final String loadableExtensionsPath = \"META-INF/services/\" + RemoteLoadableExtension.class.getName();\n         for (Archive<?> aux : auxArchives) {\n-            Node node = aux.get(loadableExtentionsPath);\n+            Node node = aux.get(loadableExtensionsPath);\n             if (node != null) {\n                 BufferedReader br = new BufferedReader(new InputStreamReader(node.getAsset().openStream()));\n                 try {\n@@ -156,7 +156,7 @@ public InputStream openStream() {\n         archive.addAsResource(new UrlAsset(serviceActivatorURL), serviceActivatorPath);\n \n         // Replace the loadable extensions with the collected set\n-        archive.delete(ArchivePaths.create(loadableExtentionsPath));\n+        archive.delete(ArchivePaths.create(loadableExtensionsPath));\n         archive.addAsResource(new Asset() {\n             @Override\n             public InputStream openStream() {\n@@ -168,7 +168,7 @@ public InputStream openStream() {\n                 pw.close();\n                 return new ByteArrayInputStream(baos.toByteArray());\n             }\n-        }, loadableExtentionsPath);\n+        }, loadableExtensionsPath);\n \n         log.debugf(\"Loadable extensions: %s\", loadableExtensions);\n         log.tracef(\"Archive content: %s\\n%s\", archive, archive.toString(true));"},{"filename":"arquillian/protocol-jmx/src/main/java/org/jboss/as/arquillian/service/ArquillianConfig.java","diff":"@@ -115,22 +115,22 @@ BundleContext getBundleContext() {\n             throw new ClassNotFoundException(\"Class '\" + className + \"' not found in: \" + testClasses);\n \n         Module module = depUnit.getAttachment(Attachments.MODULE);\n-        Deployment osgidep = OSGiDeploymentAttachment.getDeployment(depUnit);\n-        if (module == null && osgidep == null)\n+        Deployment osgiDep = OSGiDeploymentAttachment.getDeployment(depUnit);\n+        if (module == null && osgiDep == null)\n             throw new IllegalStateException(\"Cannot determine deployment type: \" + depUnit);\n-        if (module != null && osgidep != null)\n+        if (module != null && osgiDep != null)\n             throw new IllegalStateException(\"Found MODULE attachment for Bundle deployment: \" + depUnit);\n \n         Class<?> testClass;\n-        if (osgidep != null) {\n-            Bundle bundle = osgidep.getAttachment(Bundle.class);\n+        if (osgiDep != null) {\n+            Bundle bundle = osgiDep.getAttachment(Bundle.class);\n             testClass = bundle.loadClass(className);\n             BundleAssociation.setBundle(bundle);\n         } else {\n             testClass = module.getClassLoader().loadClass(className);\n         }\n \n-        // Always make the MSC artefacts available\n+        // Always make the MSC artifacts available\n         ServiceTargetAssociation.setServiceTarget(serviceTarget);\n         ServiceContainerAssociation.setServiceContainer(serviceContainer);\n "},{"filename":"arquillian/protocol-jmx/src/main/java/org/jboss/as/arquillian/service/ContextManager.java","diff":"@@ -54,17 +54,17 @@ public int compare(final SetupAction arg0, final SetupAction arg1) {\n      * wrapped and thrown\n      */\n     public void setup(final Map<String, Object> properties) {\n-        final List<SetupAction> sucessfulActions = new ArrayList<SetupAction>();\n+        final List<SetupAction> successfulActions = new ArrayList<SetupAction>();\n         for (final SetupAction action : setupActions) {\n             try {\n                 action.setup(properties);\n-                sucessfulActions.add(action);\n+                successfulActions.add(action);\n             } catch (final Throwable e) {\n-                for (SetupAction s : sucessfulActions) {\n+                for (SetupAction s : successfulActions) {\n                     try {\n                         s.teardown(properties);\n                     } catch (final Throwable t) {\n-                        // we ignore these, and just propegate the exception that caused the setup to fail\n+                        // we ignore these, and just propagate the exception that caused the setup to fail\n                     }\n                 }\n                 throw new RuntimeException(e);\n@@ -76,10 +76,10 @@ public void setup(final Map<String, Object> properties) {\n      * Tears down the contexts. If an exception is thrown by a {@link SetupAction} it is wrapped and re-thrown after all\n      * {@link SetupAction#teardown(java.util.Map)} methods have been called.\n      * <p>\n-     * Contexts are torn down in the oposite order to which they are set up (i.e. the first context set up is the last to be\n+     * Contexts are torn down in the opposite order to which they are set up (i.e. the first context set up is the last to be\n      * torn down).\n      * <p>\n-     * If more than one teardown() method thrown an exception then only the first is propegated.\n+     * If more than one teardown() method thrown an exception then only the first is propagated.\n      */\n     public void teardown(final Map<String, Object> properties) {\n         Throwable exceptionToThrow = null;"},{"filename":"build/src/main/resources/domain/configuration/mgmt-users.properties","diff":"@@ -20,6 +20,6 @@\n # for local tools running against this AS installation.\n #\n # The following illustrates how an admin user could be defined, this\n-# is for illustration only an does not correspond to a useable password.\n+# is for illustration only an does not correspond to a usable password.\n #\n #admin=2a0923285184943425d1f53ddd58ec7a"},{"filename":"build/src/main/resources/standalone/deployments/README.txt","diff":"@@ -1,6 +1,6 @@\n The standalone/deployments directory in the JBoss Application Server\n distribution is the location end users can place their deployment content\n-(e.g. war, ear, jar, sar files) to have it automically deployed into the server\n+(e.g. war, ear, jar, sar files) to have it automatically deployed into the server\n runtime.\n \n Users, particularly those running production systems, are encouraged to use the"},{"filename":"cli/src/main/java/org/jboss/as/cli/gui/ManagementModelNode.java","diff":"@@ -158,7 +158,7 @@ public static String escapeAddressElement(String element) {\n         private String value;\n         private boolean isLeaf;\n         private boolean isGeneric = false;\n-        private String seperator;\n+        private String separator;\n \n         /**\n          * Constructor for generic folder where resource=*.\n@@ -170,7 +170,7 @@ public UserObject(String name) {\n             this.value = \"*\";\n             this.isLeaf = false;\n             this.isGeneric = true;\n-            this.seperator = \"=\";\n+            this.separator = \"=\";\n         }\n \n         public UserObject(String name, String value, boolean isLeaf) {\n@@ -178,9 +178,9 @@ public UserObject(String name, String value, boolean isLeaf) {\n             this.value = value;\n             this.isLeaf = isLeaf;\n             if (isLeaf) {\n-                this.seperator = \" => \";\n+                this.separator = \" => \";\n             } else {\n-                this.seperator = \"=\";\n+                this.separator = \"=\";\n             }\n         }\n \n@@ -206,7 +206,7 @@ public boolean isGeneric() {\n \n         @Override\n         public String toString() {\n-            return this.name + this.seperator + this.value;\n+            return this.name + this.separator + this.value;\n         }\n     }\n "},{"filename":"cli/src/main/java/org/jboss/as/cli/handlers/CommandCommandHandler.java","diff":"@@ -318,7 +318,7 @@ protected boolean validateInput(CommandContext ctx, String typePath, String prop\n             }\n         }\n         if(!pathValid) {\n-            ctx.error(\"Type '\" + typeName + \"' not found amoung child types of '\" + ctx.getPrefixFormatter().format(typeAddress) + \"'\");\n+            ctx.error(\"Type '\" + typeName + \"' not found among child types of '\" + ctx.getPrefixFormatter().format(typeAddress) + \"'\");\n             return false;\n         }\n "},{"filename":"cli/src/main/java/org/jboss/as/cli/handlers/DeployHandler.java","diff":"@@ -250,7 +250,7 @@ protected void doHandle(CommandContext ctx) throws CommandFormatException {\n         String name = this.name.getValue(args);\n         if(name == null) {\n             if(f == null) {\n-                ctx.error(\"Either path or --name is requied.\");\n+                ctx.error(\"Either path or --name is required.\");\n                 return;\n             }\n             name = f.getName();\n@@ -423,7 +423,7 @@ public ModelNode buildRequest(CommandContext ctx) throws CommandFormatException\n         String name = this.name.getValue(args);\n         if(name == null) {\n             if(f == null) {\n-                throw new OperationFormatException(\"Either path or --name is requied.\");\n+                throw new OperationFormatException(\"Either path or --name is required.\");\n             }\n             name = f.getName();\n         }"},{"filename":"cli/src/main/java/org/jboss/as/cli/handlers/GenericTypeOperationHandler.java","diff":"@@ -744,21 +744,21 @@ protected void printNodeDescription(CommandContext ctx) {\n         if(idProperty == null) {\n             buf.append(\"is the name of the resource that completes the path \").append(nodeType).append(\" and \\n\");\n         } else {\n-            buf.append(\"corresponds to a property of the resourse which \\n\");\n+            buf.append(\"corresponds to a property of the resource which \\n\");\n         }\n         for(int i = 0; i < name.getFullName().length() + 5; ++i) {\n             buf.append(' ');\n         }\n-        buf.append(\"is used to identify the resourse against which the command should be executed.\");\n+        buf.append(\"is used to identify the resource against which the command should be executed.\");\n \n-        buf.append(\"\\n\\n<property>   - property name of the resourse whose value should be updated.\");\n+        buf.append(\"\\n\\n<property>   - property name of the resource whose value should be updated.\");\n         buf.append(\"\\n               For a complete list of available property names, their types and descriptions,\");\n         buf.append(\"\\n               execute \").append(commandName).append(\" --help --properties.\");\n \n-        buf.append(\"\\n\\n<command>    - command name provided by the resourse. For a complete list of available commands,\");\n+        buf.append(\"\\n\\n<command>    - command name provided by the resource. For a complete list of available commands,\");\n         buf.append(\"\\n               execute \").append(commandName).append(\" --help --commands.\");\n \n-        buf.append(\"\\n\\n<parameter>  - parameter name of the <command> provided by the resourse.\");\n+        buf.append(\"\\n\\n<parameter>  - parameter name of the <command> provided by the resource.\");\n         buf.append(\"\\n               For a complete list of available parameter names of a specific <command>,\");\n         buf.append(\"\\n               their types and descriptions, execute \").append(commandName).append(\" <command> --help.\");\n "},{"filename":"cli/src/main/java/org/jboss/as/cli/handlers/LsHandler.java","diff":"@@ -268,7 +268,7 @@ protected void doHandle(CommandContext ctx) throws CommandFormatException {\n                                                     buf.append(prop.getName());\n                                                     buf.append('=');\n                                                     buf.append(prop.getValue().asString());\n-// TODO the value should be formatted nicer but the current fomatter uses new lines for complex value which doesn't work here\n+// TODO the value should be formatted nicer but the current formatter uses new lines for complex value which doesn't work here\n //                                                    final ModelNode value = prop.getValue();\n //                                                    ModelNodeFormatter.Factory.forType(value.getType()).format(buf, 0, value);\n                                                     typeNames.add(buf.toString());"},{"filename":"cli/src/main/java/org/jboss/as/cli/impl/CommandContextImpl.java","diff":"@@ -726,11 +726,11 @@ private boolean handleSSLFailure() throws IOException {\n         }\n     }\n \n-    private static final String[] FINGERPRINT_ALOGRITHMS = new String[] { \"MD5\", \"SHA1\" };\n+    private static final String[] FINGERPRINT_ALGORITHMS = new String[] { \"MD5\", \"SHA1\" };\n \n     private Map<String, String> generateFingerprints(final X509Certificate cert) throws IOException  {\n-        Map<String, String> fingerprints = new HashMap<String, String>(FINGERPRINT_ALOGRITHMS.length);\n-        for (String current : FINGERPRINT_ALOGRITHMS) {\n+        Map<String, String> fingerprints = new HashMap<String, String>(FINGERPRINT_ALGORITHMS.length);\n+        for (String current : FINGERPRINT_ALGORITHMS) {\n             try {\n                 fingerprints.put(current, generateFingerPrint(current, cert.getEncoded()));\n             } catch (GeneralSecurityException e) {"},{"filename":"cli/src/main/java/org/jboss/as/cli/parsing/GlobalCharacterHandlers.java","diff":"@@ -99,7 +99,7 @@ private static void addHandler(char start, ParsingState state) {\n \n     //private static void addHandler(char start, )\n     static {\n-        addHandler(\"STRING_IN_PARANTHESIS\", '(', ')');\n+        addHandler(\"STRING_IN_PARENTHESIS\", '(', ')');\n         addHandler(\"STRING_IN_BRACKETS\", '[', ']');\n         addHandler(\"STRING_IN_BRACES\", '{', '}');\n         //addHandler(\"STRING_IN_CHEVRONS\", '<', '>', \"The closing '>' is missing.\");"},{"filename":"clustering/api/src/main/java/org/jboss/as/clustering/lock/AbstractClusterLockSupport.java","diff":"@@ -136,7 +136,7 @@ public boolean lock(Serializable lockId, long timeout) {\n         long start = System.currentTimeMillis();\n         while (left > 0) {\n             // Another node we lost to who should take precedence\n-            // over ourself in competition for the lock\n+            // over ourselves in competition for the lock\n             ClusterNode superiorCompetitor = null;\n \n             // Only continue if category is unlocked"},{"filename":"clustering/api/src/main/java/org/jboss/as/clustering/lock/LocalAndClusterLockManager.java","diff":"@@ -204,7 +204,7 @@ public void start() throws Exception {\n     }\n \n     /**\n-     * Removes this object from a state where it is ready for normal oepration and performs cleanup work.\n+     * Removes this object from a state where it is ready for normal operation and performs cleanup work.\n      *\n      * @throws Exception\n      */"},{"filename":"clustering/impl/src/main/java/org/jboss/as/clustering/impl/CoreGroupCommunicationService.java","diff":"@@ -1597,7 +1597,7 @@ public void processEvent(Object event) {\n             }\n \n             @Override\n-            protected int tryAcquireShared(int ingored) {\n+            protected int tryAcquireShared(int ignored) {\n                 return this.getState();\n             }\n "},{"filename":"clustering/infinispan/src/main/java/org/jboss/as/clustering/infinispan/subsystem/CacheContainerAdd.java","diff":"@@ -78,7 +78,7 @@ static ModelNode createOperation(ModelNode address, ModelNode existing) {\n     }\n \n     private static void populate(ModelNode source, ModelNode target) {\n-        // AS7-3488 make default-cache non required attrinbute\n+        // AS7-3488 make default-cache non required attribute\n         // target.get(ModelKeys.DEFAULT_CACHE).set(source.get(ModelKeys.DEFAULT_CACHE));\n         if (source.hasDefined(ModelKeys.DEFAULT_CACHE)) {\n             target.get(ModelKeys.DEFAULT_CACHE).set(source.get(ModelKeys.DEFAULT_CACHE));"},{"filename":"clustering/infinispan/src/main/java/org/jboss/as/clustering/infinispan/subsystem/InfinispanDescriptions.java","diff":"@@ -376,7 +376,7 @@ static ModelNode getEvictionRemoveDescription(Locale locale) {\n         return op;\n     }\n \n-    // cache expiration elemet\n+    // cache expiration element\n     static ModelNode getExpirationDescription(Locale locale) {\n         ResourceBundle resources = getResources(locale);\n         final ModelNode expiration = createDescription(resources, \"infinispan.cache.expiration\");"},{"filename":"clustering/infinispan/src/main/java/org/jboss/as/clustering/infinispan/subsystem/InfinispanSubsystemXMLReader_1_1.java","diff":"@@ -132,7 +132,7 @@ private void parseContainer(XMLExtendedStreamReader reader, ModelNode subsystemA\n         }\n \n         /*\n-          AS7-3488 make default-cache a non-required attribiute\n+          AS7-3488 make default-cache a non-required attribute\n         if ((name == null) || !container.hasDefined(ModelKeys.DEFAULT_CACHE)) {\n             throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.NAME, Attribute.DEFAULT_CACHE));\n         }"},{"filename":"clustering/infinispan/src/main/resources/org/jboss/as/clustering/infinispan/subsystem/LocalDescriptions.properties","diff":"@@ -63,7 +63,7 @@ infinispan.cache.transaction.stop-timeout=If there are any ongoing transactions\n infinispan.cache.transaction.eager-locking=Only has effect for DIST mode and when useEagerLocking is set to true. When this is enabled, then only one node is locked in the cluster, disregarding numOwners config.\n infinispan.cache.transaction.locking=The locking mode for this cache, one of OPTIMISTIC or PESSIMISTIC.\n infinispan.cache.transaction.add=Adds a transaction configuration element to the cache.\n-infinispan.cache.transaction.remove=Removes a transcation configuration element from the cache.\n+infinispan.cache.transaction.remove=Removes a transaction configuration element from the cache.\n #\n infinispan.cache.eviction=The cache eviction configuration.\n infinispan.cache.eviction.strategy=Sets the cache eviction strategy. Available options are 'UNORDERED', 'FIFO', 'LRU', 'LIRS' and 'NONE' (to disable eviction).\n@@ -102,7 +102,7 @@ infinispan.cache.file-store.path=Description\n \n infinispan.cache.jdbc-store=The cache JDBC store configuration.\n infinispan.cache.jdbc-store.add=Adds a JDBC cache store configuration element to the cache.\n-infinispan.cache.jdbc-store.datasource=A datasource referenmce for this datastore.\n+infinispan.cache.jdbc-store.datasource=A datasource reference for this datastore.\n infinispan.cache.jdbc-store.entry-table=FIX ME.\n infinispan.cache.jdbc-store.bucket-table=FIX ME.\n infinispan.cache.jdbc-store.table.prefix=FIX ME."},{"filename":"cmp/src/main/java/org/jboss/as/cmp/bridge/EntityBridge.java","diff":"@@ -27,8 +27,8 @@\n  * EntityBridge follows the Bridge pattern [Gamma et. al, 1995].\n  * In this implementation of the pattern the Abstract is the entity bean class,\n  * and the RefinedAbstraction is the entity bean dynamic proxy. This interface\n- * can be considered the implementor. Each imlementation of the CMPStoreManager\n- * should create a store specifiec implementaion of the bridge.\n+ * can be considered the implementor. Each implementation of the CMPStoreManager\n+ * should create a store specific implementation of the bridge.\n  * <p/>\n  * Life-cycle:\n  * Undefined. Should be tied to CMPStoreManager."},{"filename":"cmp/src/main/java/org/jboss/as/cmp/bridge/EntityBridgeInvocationHandler.java","diff":"@@ -29,9 +29,9 @@\n import org.jboss.as.cmp.context.CmpEntityBeanContext;\n \n /**\n- * EntityBridgeInvocationHandler is the invocation hander used by the CMP 2.x\n+ * EntityBridgeInvocationHandler is the invocation handler used by the CMP 2.x\n  * dynamic proxy. This class only interacts with the EntityBridge. The main\n- * job of this class is to deligate invocation of abstract methods to the\n+ * job of this class is to delegate invocation of abstract methods to the\n  * appropriate EntityBridge method.\n  * <p/>\n  * Life-cycle:"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/component/CmpEntityBeanComponentDescription.java","diff":"@@ -68,8 +68,8 @@ public void configureDependency(final ServiceBuilder<?> serviceBuilder, final Co\n     }\n \n     @Override\n-    public ComponentConfiguration createEntityBeanConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoder, final ModuleLoader moduleLoader) {\n-        final ComponentConfiguration configuration = new ComponentConfiguration(this, classIndex, moduleClassLoder, moduleLoader);\n+    public ComponentConfiguration createEntityBeanConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoader, final ModuleLoader moduleLoader) {\n+        final ComponentConfiguration configuration = new ComponentConfiguration(this, classIndex, moduleClassLoader, moduleLoader);\n         configuration.setComponentCreateServiceFactory(CmpEntityBeanComponentCreateService.FACTORY);\n         return configuration;\n     }"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/ejbql/ASTLike.java","diff":"@@ -24,7 +24,7 @@\n import org.jboss.as.cmp.jdbc.SQLUtil;\n \n /**\n- * This abstract syntax node represents a like opperator.\n+ * This abstract syntax node represents a like operator.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n  * @version $Revision: 81030 $"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/ejbql/ASTMultDiv.java","diff":"@@ -26,7 +26,7 @@\n \n /**\n  * This abstract syntax node represents a series of multiplication and\n- * divide opperators.\n+ * divide operators.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n  * @version $Revision: 81030 $"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/ejbql/ASTNegation.java","diff":"@@ -22,7 +22,7 @@\n package org.jboss.as.cmp.ejbql;\n \n /**\n- * This abstract syntax node represents a negation opperator.\n+ * This abstract syntax node represents a negation operator.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n  * @version $Revision: 81030 $"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/ejbql/ASTNot.java","diff":"@@ -22,7 +22,7 @@\n package org.jboss.as.cmp.ejbql;\n \n /**\n- * This abstract syntax node represents a logical not opperation.\n+ * This abstract syntax node represents a logical not operation.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n  * @version $Revision: 81030 $"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/ejbql/ASTOr.java","diff":"@@ -22,7 +22,7 @@\n package org.jboss.as.cmp.ejbql;\n \n /**\n- * This abstract syntax node represents a logical or opperation.\n+ * This abstract syntax node represents a logical or operation.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n  * @version $Revision: 81030 $"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/ejbql/ASTPlusMinus.java","diff":"@@ -26,7 +26,7 @@\n \n /**\n  * This abstract syntax node represents a series of addition and subtraction\n- * opperations.\n+ * operations.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n  * @version $Revision: 81030 $"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/ejbql/BlockStringBuffer.java","diff":"@@ -24,10 +24,10 @@\n import java.util.LinkedList;\n \n /**\n- * A buffer simmilar to StringBuffer that works on string blocks instead\n+ * A buffer similar to StringBuffer that works on string blocks instead\n  * of individual characters.  This eliminates excessive array allocation\n- * and copying at the expense of removal and substring opperations. This\n- * is a greate compromise as usually the only functions called on a\n+ * and copying at the expense of removal and substring operations. This\n+ * is a great compromise as usually the only functions called on a\n  * StringBuffer are append, length, and toString.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/ByteArrayBlob.java","diff":"@@ -35,7 +35,7 @@\n  * getting the length of an SQL <code>BLOB</code> (Binary Large Object) value,\n  * for materializing a <code>BLOB</code> value on the client, and for\n  * determining the position of a pattern of bytes within a <code>BLOB</code>\n- * value. The ByteArrayBlob has static factory methods for construting an\n+ * value. The ByteArrayBlob has static factory methods for constructing an\n  * <code>BLOB</code> using either an existing serializable object, or an array\n  * of bytes. This is a nice way to store serialized objects in a relational\n  * field of type SQL <code>BLOB</code>."},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCAbstractCreateCommand.java","diff":"@@ -232,7 +232,7 @@ protected void performInsert(CmpEntityBeanContext ctx) throws CreateException {\n         PreparedStatement ps = null;\n         boolean throwRuntimeExceptions = entity.getMetaData().getThrowRuntimeExceptions();\n \n-        // if metadata is true, the getconnection is done inside\n+        // if metadata is true, the getConnection is done inside\n         // its own try catch block to throw a runtime exception (EJBException)\n         if (throwRuntimeExceptions) {\n             try {\n@@ -250,7 +250,7 @@ protected void performInsert(CmpEntityBeanContext ctx) throws CreateException {\n             }\n \n \n-            // if metadata is false, the getconnection is done inside this try catch block\n+            // if metadata is false, the getConnection is done inside this try catch block\n             if (!throwRuntimeExceptions) {\n                 c = entity.getDataSource().getConnection();\n             }"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCAbstractQueryCommand.java","diff":"@@ -170,7 +170,7 @@ protected Collection execute(String sql,\n         final JDBCEntityBridge entityBridge = (JDBCEntityBridge) selectManager.getEntityBridge();\n         boolean throwRuntimeExceptions = entityBridge.getMetaData().getThrowRuntimeExceptions();\n \n-        // if metadata is true, the getconnection is done inside\n+        // if metadata is true, the getConnection is done inside\n         // its own try catch block to throw a runtime exception (EJBException)\n         if (throwRuntimeExceptions) {\n             try {\n@@ -192,7 +192,7 @@ protected Collection execute(String sql,\n                 }\n             }\n \n-            // if metadata is false, the getconnection is done inside this try catch block\n+            // if metadata is false, the getConnection is done inside this try catch block\n             if (!throwRuntimeExceptions) {\n                 con = entityBridge.getDataSource().getConnection();\n             }\n@@ -320,7 +320,7 @@ protected String getEagerLoadGroup() {\n     }\n \n     /**\n-     * Replaces the parameters in the specifiec sql with question marks, and\n+     * Replaces the parameters in the specific sql with question marks, and\n      * initializes the parameter setting code. Parameters are encoded in curly\n      * brackets use a zero based index.\n      *"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCCustomFinderQuery.java","diff":"@@ -134,7 +134,7 @@ public Collection execute(Method unused, Object[] args, CmpEntityBeanContext ctx\n             if (ex instanceof FinderException) {\n                 throw (FinderException) ex;\n             } else {\n-                throw new FinderException(\"Errror invoking cutom finder \" +\n+                throw new FinderException(\"Error invoking custom finder \" +\n                         finderMethod.getName() + \": \" + ex);\n             }\n         }"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCDeclaredSQLQuery.java","diff":"@@ -30,7 +30,7 @@\n import org.jboss.as.cmp.jdbc.metadata.JDBCReadAheadMetaData;\n \n /**\n- * This class generates a query based on the delcared-sql xml specification.\n+ * This class generates a query based on the declared-sql xml specification.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n  * @author <a href=\"mailto:rickard.oberg@telkel.com\">Rickard Oberg</a>\n@@ -46,7 +46,7 @@\n     private final JDBCDeclaredQueryMetaData metadata;\n \n     /**\n-     * Creted a defined finder command based on the information\n+     * Create a defined finder command based on the information\n      * in a declared-sql declaration.\n      */\n     public JDBCDeclaredSQLQuery(JDBCStoreManager manager,\n@@ -101,7 +101,7 @@ private void initSelectObject(JDBCStoreManager manager) {\n     }\n \n     /**\n-     * Builds the sql statement based on the delcared-sql metadata specification.\n+     * Builds the sql statement based on the declared-sql metadata specification.\n      *\n      * @return the sql statement for this query\n      */"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCEJBQLCompiler.java","diff":"@@ -147,7 +147,7 @@ public void compileEJBQL(String ejbql,\n         // reset all state variables\n         reset();\n \n-        // set input arguemts\n+        // set input arguments\n         this.returnType = returnType;\n         this.parameterTypes = parameterTypes;\n         this.readAhead = metadata.getReadAhead();\n@@ -157,7 +157,7 @@ public void compileEJBQL(String ejbql,\n         EJBQLParser parser = new EJBQLParser(new StringReader(SQLUtil.EMPTY_STRING));\n \n         try {\n-            // parse the ejbql into an abstract sytax tree\n+            // parse the ejbql into an abstract syntax tree\n             ASTEJBQL ejbqlNode;\n             ejbqlNode = parser.parse(catalog, parameterTypes, ejbql);\n \n@@ -182,7 +182,7 @@ public void compileJBossQL(String ejbql,\n         // reset all state variables\n         reset();\n \n-        // set input arguemts\n+        // set input arguments\n         this.returnType = returnType;\n         this.parameterTypes = parameterTypes;\n         this.readAhead = metadata.getReadAhead();\n@@ -192,7 +192,7 @@ public void compileJBossQL(String ejbql,\n         JBossQLParser parser = new JBossQLParser(new StringReader(SQLUtil.EMPTY_STRING));\n \n         try {\n-            // parse the ejbql into an abstract sytax tree\n+            // parse the ejbql into an abstract syntax tree\n             ASTEJBQL ejbqlNode;\n             ejbqlNode = parser.parse(catalog, parameterTypes, ejbql);\n \n@@ -744,10 +744,10 @@ private void createThetaJoin(StringBuffer buf) {\n                 String childAlias = (String) entry.getKey();\n                 ASTPath path = (ASTPath) entry.getValue();\n \n-                // join the memeber path\n+                // join the member path\n                 createThetaJoin(path, path.size() - 1, joinedAliases, childAlias, buf);\n \n-                // join the memeber path parents\n+                // join the member path parents\n                 for (int i = 0; i < path.size() - 1; i++) {\n                     createThetaJoin(path, i, joinedAliases, buf);\n                 }\n@@ -906,7 +906,7 @@ public Object visit(ASTSelect node, Object data) {\n                 selectEntity(path, node.distinct, buf);\n             }\n         } else {\n-            // the function should take a path expresion as a parameter\n+            // the function should take a path expression as a parameter\n             path = getPathFromChildren(child0);\n \n             if (path == null) {\n@@ -1016,7 +1016,7 @@ public Object visit(ASTIsEmpty node, Object data) {\n     public Object visit(ASTMemberOf node, Object data) {\n         StringBuffer buf = (StringBuffer) data;\n \n-        // setup compare to vars first, so we can compre types in from vars\n+        // setup compare to vars first, so we can compare types in from vars\n         ASTPath toPath = (ASTPath) node.jjtGetChild(1);\n \n         JDBCCMRFieldBridge toCMRField = (JDBCCMRFieldBridge) toPath.getCMRField();\n@@ -1108,7 +1108,7 @@ public Object visit(ASTMemberOf node, Object data) {\n \n         // second part makes fromNode equal toChild\n         if (fromAlias != null) {\n-            // compre pk to pk\n+            // compare pk to pk\n             if (relationTableAlias == null) {\n                 SQLUtil.getSelfCompareWhereClause(toChildEntity.getPrimaryKeyFields(),\n                         toChildAlias,\n@@ -1193,7 +1193,7 @@ public Object visit(ASTValueClassComparison node, Object data) {\n     }\n \n     /**\n-     * compreEntity(arg0, arg1)\n+     * compareEntity(arg0, arg1)\n      */\n     public Object visit(ASTEntityComparison node, Object data) {\n         StringBuffer buf = (StringBuffer) data;\n@@ -1548,10 +1548,10 @@ public Object visit(ASTWhereConditionalTerm node, Object data) {\n \n     /**\n      * Wrap a node with a class that when ever toString is called visits the\n-     * node.  This is used by the function implmentations, for parameters.\n+     * node.  This is used by the function implementations, for parameters.\n      * <p/>\n      * Be careful with this class because it visits the node for each call of\n-     * toString, which could have undesireable result if called multiple times.\n+     * toString, which could have undesirable result if called multiple times.\n      */\n     private final class NodeStringWrapper {\n         final Node node;"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCFindEntityCommand.java","diff":"@@ -29,7 +29,7 @@\n \n \n /**\n- * JDBCFindEntityCommand finds a single entity, by deligating to\n+ * JDBCFindEntityCommand finds a single entity, by delegating to\n  * find entities and checking that only entity is returned.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCInitEntityCommand.java","diff":"@@ -39,7 +39,7 @@ public JDBCInitEntityCommand(JDBCStoreManager manager) {\n \n     /**\n      * Called before ejbCreate. In the JDBCStoreManager we need to\n-     * initialize the presistence context. The persistence context is where\n+     * initialize the persistence context. The persistence context is where\n      * where bean data is stored. If CMP 1.x, original values are store\n      * and for CMP 2.x actual values are stored int the context. Then we\n      * initialize the data. In CMP 1.x fields are reset to Java defaults, and"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCInsertPKCreateCommand.java","diff":"@@ -42,7 +42,7 @@\n     public void init(JDBCStoreManager manager) {\n         super.init(manager);\n \n-        // if no exception processor is defined, we will perform a existance\n+        // if no exception processor is defined, we will perform a existence\n         // check before trying the insert to report duplicate key\n         if (exceptionProcessor == null) {\n             initExistsSQL();\n@@ -62,7 +62,7 @@ protected void initExistsSQL() {\n     }\n \n     protected void beforeInsert(CmpEntityBeanContext ctx) throws CreateException {\n-        // are we checking existance by query?\n+        // are we checking existence by query?\n         if (existsSQL != null) {\n             Connection c = null;\n             PreparedStatement ps = null;"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCLoadEntityCommand.java","diff":"@@ -38,7 +38,7 @@\n  * JDBCLoadEntityCommand loads the data for an instance from the table.\n  * This command implements specified eager loading. For CMP 2.x, the\n  * entity can be configured to only load some of the fields, which is\n- * helpful for entitys with lots of data.\n+ * helpful for entities with lots of data.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n  * @author <a href=\"mailto:on@ibis.odessa.ua\">Oleg Nitz</a>\n@@ -192,7 +192,7 @@ private boolean execute(JDBCCMPFieldBridge requiredField,\n                     }\n                     mainEntityLoaded = true;\n                 } else {\n-                    // preload entity; load the values into the read ahead cahce\n+                    // preload entity; load the values into the read ahead cache\n                     loadIter.reset();\n                     while (loadIter.hasNext()) {\n                         JDBCCMPFieldBridge field = loadIter.next();\n@@ -233,7 +233,7 @@ private String getSQL(JDBCEntityBridge.FieldIterator loadIter, int keyCount) {\n         StringBuffer sql = new StringBuffer(250);\n         sql.append(SQLUtil.SELECT);\n \n-        // if we are loading more then one entity we need to add the primry\n+        // if we are loading more then one entity we need to add the primary\n         // key to the load fields to match up the results with the correct entity.\n         JDBCFieldBridge[] primaryKeyFields = entity.getPrimaryKeyFields();\n         if (keyCount > 1) {\n@@ -260,7 +260,7 @@ private String getRawLockingSQL(JDBCEntityBridge.FieldIterator loadIter, int key\n         //\n         // column names clause\n         StringBuffer columnNamesClause = new StringBuffer(250);\n-        // if we are loading more then one entity we need to add the primry\n+        // if we are loading more then one entity we need to add the primary\n         // key to the load fields to match up the results with the correct\n         // entity.\n         if (keyCount > 1) {"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCLoadRelationCommand.java","diff":"@@ -66,7 +66,7 @@ public JDBCLoadRelationCommand(JDBCStoreManager manager) {\n     public Collection execute(JDBCCMRFieldBridge cmrField, Object pk) {\n         JDBCCMRFieldBridge relatedCMRField = (JDBCCMRFieldBridge) cmrField.getRelatedCMRField();\n \n-        // get the read ahead cahces\n+        // get the read ahead caches\n         ReadAheadCache readAheadCache = manager.getReadAheadCache();\n         ReadAheadCache relatedReadAheadCache = cmrField.getRelatedManager().getReadAheadCache();\n \n@@ -190,7 +190,7 @@ public Collection execute(JDBCCMRFieldBridge cmrField, Object pk) {\n                 // store the results list for readahead on-load\n                 relatedReadAheadCache.addFinderResults(results, readAhead);\n \n-                // store the preloaded relationship (unless this is the realts we\n+                // store the preloaded relationship (unless this is the result we\n                 // are actually after)\n                 if (!key.equals(pk)) {\n                     readAheadCache.addPreloadData(key, cmrField, results);"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCPassivateEntityCommand.java","diff":"@@ -26,7 +26,7 @@\n \n /**\n  * JDBCPassivateEntityCommand deletes the entity persistence context,\n- * where data about the instence is keeps.\n+ * where data about the instance is keeps.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n  * @author <a href=\"mailto:rickard.oberg@telkel.com\">Rickard Oberg</a>"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCRemoveEntityCommand.java","diff":"@@ -107,7 +107,7 @@ public void execute(CmpEntityBeanContext ctx) throws RemoveException, RemoteExce\n                     log.trace(\"Instance is scheduled for cascade delete. id=\" + ctx.getPrimaryKey());\n             }\n         }\n-        // cascate-delete to old relations, if relation uses cascade.\n+        // cascade-delete to old relations, if relation uses cascade.\n         if (oldRelationsRef[0] != null) {\n             Map oldRelations = (Map) oldRelationsRef[0];\n             entity.cascadeDelete(ctx, oldRelations);"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCResultSetReader.java","diff":"@@ -196,9 +196,9 @@ protected Object readResult(ResultSet rs, int index, Class<?> destination) throw\n         }\n \n         protected Object coerceToJavaType(Object value, Class<?> destination) {\n-            // make new copy as sub types have problems in comparions\n+            // make new copy as sub types have problems in comparisons\n             java.util.Date result;\n-            // handle timestamp special becauses it hoses the milisecond values\n+            // handle timestamp special because it hoses the millisecond values\n             if (value instanceof java.sql.Timestamp) {\n                 java.sql.Timestamp ts = (java.sql.Timestamp) value;\n                 // Timestamp returns whole seconds from getTime and partial"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCStartCommand.java","diff":"@@ -383,7 +383,7 @@ private void alterTable(DataSource dataSource, JDBCFunctionMappingMetaData mappi\n                 statement.executeUpdate(sql);\n             } finally {\n                 // make sure to close the connection and statement before\n-                // comitting the transaction or XA will break\n+                // committing the transaction or XA will break\n                 JDBCUtil.safeClose(statement);\n                 JDBCUtil.safeClose(con);\n             }\n@@ -438,7 +438,7 @@ private void createTable(DataSource dataSource, String tableName, String sql) {\n                 statement.executeUpdate(sql);\n             } finally {\n                 // make sure to close the connection and statement before\n-                // comitting the transaction or XA will break\n+                // committing the transaction or XA will break\n                 JDBCUtil.safeClose(statement);\n                 JDBCUtil.safeClose(con);\n             }\n@@ -494,7 +494,7 @@ private void createIndex(DataSource dataSource, String tableName, String indexNa\n                 statement.executeUpdate(sql);\n             } finally {\n                 // make sure to close the connection and statement before\n-                // comitting the transaction or XA will break\n+                // committing the transaction or XA will break\n                 JDBCUtil.safeClose(statement);\n                 JDBCUtil.safeClose(con);\n             }\n@@ -560,7 +560,7 @@ private void issuePostCreateSQL(DataSource dataSource, List sql, String table) {\n                 }\n             } finally {\n                 // make sure to close the connection and statement before\n-                // comitting the transaction or XA will break\n+                // committing the transaction or XA will break\n                 JDBCUtil.safeClose(statement);\n                 JDBCUtil.safeClose(con);\n             }\n@@ -658,7 +658,7 @@ private void createCMPIndices(DataSource dataSource, ArrayList indexNames) {\n     }\n \n     /**\n-     * Create indix for one specific field\n+     * Create index for one specific field\n      *\n      * @param dataSource\n      * @param field      to create index for\n@@ -857,7 +857,7 @@ private void addForeignKeyConstraint(DataSource dataSource,\n                 statement.executeUpdate(sql);\n             } finally {\n                 // make sure to close the connection and statement before\n-                // comitting the transaction or XA will break\n+                // committing the transaction or XA will break\n                 JDBCUtil.safeClose(statement);\n                 JDBCUtil.safeClose(con);\n             }"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCStoreManager.java","diff":"@@ -74,8 +74,8 @@\n  * Tied to the life-cycle of the entity container.\n  * <p/>\n  * Multiplicity:\n- * One per cmp entity bean. This could be less if another implementaion of\n- * EntityPersistenceStore is created and thoes beans use the implementation\n+ * One per cmp entity bean. This could be less if another implementation of\n+ * EntityPersistenceStore is created and those beans use the implementation\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n  * @author <a href=\"mailto:alex@jboss.org\">Alex Loubyansky</a>\n@@ -195,7 +195,7 @@ public Transaction getTransaction() {\n                 try {\n                     return transactionManager.getTransaction();\n                 } catch (SystemException e) {\n-                    throw new IllegalStateException(\"An error occured while getting the \" +\n+                    throw new IllegalStateException(\"An error occurred while getting the \" +\n                             \"transaction associated with the current thread: \" + e);\n                 }\n             }\n@@ -233,9 +233,9 @@ public Transaction getTransaction() {\n         startCommand.execute();\n \n         // Start the query manager. At this point is creates all of the\n-        // query commands. The must occure in the start phase, as\n-        // queries can opperate on other entities in the application, and\n-        // all entities are gaurenteed to be createed until the start phase.\n+        // query commands. The must occur in the start phase, as\n+        // queries can operate on other entities in the application, and\n+        // all entities are guaranteed to be created until the start phase.\n         queryManager.start();\n \n         readAheadCache.start();\n@@ -400,7 +400,7 @@ public CmpEntityBeanComponent getComponent() {\n     //\n \n     /**\n-     * Returns a new instance of a class which implemnts the bean class.\n+     * Returns a new instance of a class which implements the bean class.\n      *\n      * @return the new instance\n      */"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCTypeComplex.java","diff":"@@ -74,7 +74,7 @@ public JDBCTypeComplex(\n             jdbcTypes[i] = property.getJDBCType();\n             sqlTypes[i] = property.getSQLType();\n             notNull[i] = property.isNotNull();\n-            resultSetReaders[i] = property.getResulSetReader();\n+            resultSetReaders[i] = property.getResultSetReader();\n             paramSetters[i] = property.getParameterSetter();\n             propertiesByName.put(property.getPropertyName(), property);\n         }"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCTypeComplexProperty.java","diff":"@@ -24,7 +24,7 @@\n import java.lang.reflect.Method;\n \n /**\n- * Immutable class which contins the mapping between a single Java Bean\n+ * Immutable class which contains the mapping between a single Java Bean\n  * (not an EJB) property and a column. This class has a flattened view of\n  * the Java Bean property, which may be several properties deep in the\n  * base Java Bean. The details of how a property is mapped to a column\n@@ -44,7 +44,7 @@\n     private final int jdbcType;\n     private final String sqlType;\n     private final boolean notNull;\n-    private final JDBCResultSetReader resulSetReader;\n+    private final JDBCResultSetReader resultSetReader;\n     private final JDBCParameterSetter paramSetter;\n \n     private final Method[] getters;\n@@ -68,7 +68,7 @@ public JDBCTypeComplexProperty(\n         this.notNull = notNull;\n         this.getters = getters;\n         this.setters = setters;\n-        this.resulSetReader = JDBCUtil.getResultSetReader(jdbcType, javaType);\n+        this.resultSetReader = JDBCUtil.getResultSetReader(jdbcType, javaType);\n         this.paramSetter = JDBCUtil.getParameterSetter(jdbcType, javaType);\n     }\n \n@@ -87,7 +87,7 @@ public JDBCTypeComplexProperty(\n         this.notNull = notNull;\n         this.getters = defaultProperty.getters;\n         this.setters = defaultProperty.setters;\n-        this.resulSetReader = JDBCUtil.getResultSetReader(jdbcType, javaType);\n+        this.resultSetReader = JDBCUtil.getResultSetReader(jdbcType, javaType);\n         this.paramSetter = JDBCUtil.getParameterSetter(jdbcType, javaType);\n     }\n \n@@ -115,8 +115,8 @@ public boolean isNotNull() {\n         return notNull;\n     }\n \n-    public JDBCResultSetReader getResulSetReader() {\n-        return resulSetReader;\n+    public JDBCResultSetReader getResultSetReader() {\n+        return resultSetReader;\n     }\n \n     public JDBCParameterSetter getParameterSetter() {\n@@ -151,7 +151,7 @@ public Object setColumnValue(\n             // get the next object in chain\n             Object next = getters[i].invoke(value, noArgs);\n \n-            // the next object is null creat it\n+            // the next object is null create it\n             if (next == null) {\n                 // new type based on getter\n                 next = getters[i].getReturnType().newInstance();"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCTypeFactory.java","diff":"@@ -43,7 +43,7 @@\n //import org.jboss.logging.Logger;\n \n /**\n- * JDBCTypeFactory mapps Java Classes to JDBCType objects.  The main job of\n+ * JDBCTypeFactory maps Java Classes to JDBCType objects.  The main job of\n  * this class is to flatten the JDBCValueClassMetaData into columns.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n@@ -525,7 +525,7 @@ private JDBCTypeComplex createTypeComplex(JDBCCMPFieldMetaData cmpField) {\n             overrides.put(p.getPropertyName(), p);\n         }\n \n-        // array that will hold the final properites after overrides\n+        // array that will hold the final properties after overrides\n         JDBCTypeComplexProperty[] finalProperties = new JDBCTypeComplexProperty[defaultProperties.length];\n \n         // override property default values\n@@ -573,7 +573,7 @@ private JDBCTypeComplex createTypeComplex(JDBCCMPFieldMetaData cmpField) {\n             }\n         }\n \n-        // did we find all overriden properties\n+        // did we find all overridden properties\n         if (overrides.size() > 0) {\n             String propertyName = (String) overrides.keySet().iterator().next();\n             throw new EJBException(\"Property \" + propertyName + \" in field \" +\n@@ -686,7 +686,7 @@ public void pushPropertyMetaData(\n             setters.add(propertyMetaData.getSetter());\n \n             if (properties.contains(propertyMetaData)) {\n-                throw new EJBException(\"Circular reference discoverd at \" +\n+                throw new EJBException(\"Circular reference discovered at \" +\n                         \"property: \" + getPropertyName());\n             }\n             properties.add(propertyMetaData);"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/JDBCUtil.java","diff":"@@ -48,8 +48,8 @@\n import org.jboss.logging.Logger;\n \n /**\n- * JDBCUtil takes care of some of the more anoying JDBC tasks.\n- * It hanles safe closing of jdbc resources, setting statement\n+ * JDBCUtil takes care of some of the more annoying JDBC tasks.\n+ * It handles safe closing of jdbc resources, setting statement\n  * parameters and loading query results.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n@@ -148,7 +148,7 @@ public static Object coerceToSQLType(int jdbcType, Object value) {\n      *\n      * @param value the value to convert into a byte array\n      * @return the byte representation of the value\n-     * @throws SQLException if a problem occures in the conversion\n+     * @throws SQLException if a problem occurs in the conversion\n      */\n     public static byte[] convertObjectToByteArray(Object value)\n             throws SQLException {\n@@ -187,8 +187,8 @@ public static Object coerceToSQLType(int jdbcType, Object value) {\n      * Coverts the input into an object.\n      *\n      * @param input the bytes to convert\n-     * @return the object repsentation of the input stream\n-     * @throws SQLException if a problem occures in the conversion\n+     * @return the object representation of the input stream\n+     * @throws SQLException if a problem occurs in the conversion\n      */\n     public static Object convertToObject(byte[] input)\n             throws SQLException {\n@@ -205,8 +205,8 @@ public static Object convertToObject(byte[] input)\n      * Coverts the input into an object.\n      *\n      * @param input the bytes to convert\n-     * @return the object repsentation of the input stream\n-     * @throws SQLException if a problem occures in the conversion\n+     * @return the object representation of the input stream\n+     * @throws SQLException if a problem occurs in the conversion\n      */\n     public static Object convertToObject(InputStream input)\n             throws SQLException {\n@@ -703,9 +703,9 @@ private static Object coerceToJavaType(\n             //\n             // java.util.Date\n             //\n-            // make new copy as sub types have problems in comparions\n+            // make new copy as sub types have problems in comparisons\n             if (destination == java.util.Date.class && value instanceof java.util.Date) {\n-                // handle timestamp special becauses it hoses the milisecond values\n+                // handle timestamp special because it hoses the millisecond values\n                 if (value instanceof java.sql.Timestamp) {\n                     java.sql.Timestamp ts = (java.sql.Timestamp) value;\n \n@@ -744,9 +744,9 @@ private static Object coerceToJavaType(\n             if (destination == java.sql.Timestamp.class && value instanceof java.sql.Timestamp) {\n                 // make a new Timestamp object; you never know\n                 // what a driver will return\n-                java.sql.Timestamp orignal = (java.sql.Timestamp) value;\n-                java.sql.Timestamp copy = new java.sql.Timestamp(orignal.getTime());\n-                copy.setNanos(orignal.getNanos());\n+                java.sql.Timestamp original = (java.sql.Timestamp) value;\n+                java.sql.Timestamp copy = new java.sql.Timestamp(original.getTime());\n+                copy.setNanos(original.getNanos());\n                 return copy;\n             }\n "},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/QueryParameter.java","diff":"@@ -182,7 +182,7 @@ public QueryParameter(JDBCEntityPersistenceStore manager,\n             // get the field from the entity\n             field = getCMPField(manager, argType, fieldName);\n             if (!field.isPrimaryKeyMember()) {\n-                throw new IllegalArgumentException(\"The specified field must be a primay key field\");\n+                throw new IllegalArgumentException(\"The specified field must be a primary key field\");\n             }\n \n             // get the jdbc type object\n@@ -201,7 +201,7 @@ public QueryParameter(JDBCEntityPersistenceStore manager,\n             this.type = type;\n         } else {\n             if (!tok.hasMoreTokens()) {\n-                throw new IllegalArgumentException(\"Parmeter is a known \" +\n+                throw new IllegalArgumentException(\"Parameter is a known \" +\n                         \"dependent value class, so a property must be supplied\");\n             }\n \n@@ -263,7 +263,7 @@ public void set(Logger log, PreparedStatement ps, int index, Object[] args)\n                 } else if (arg instanceof EJBLocalObject) {\n                     arg = ((EJBLocalObject) arg).getPrimaryKey();\n                 } else {\n-                    throw new IllegalArgumentException(\"Expected an instanc of \" +\n+                    throw new IllegalArgumentException(\"Expected an instance of \" +\n                             \"EJBObject or EJBLocalObject, but got an instance of \" +\n                             arg.getClass().getName());\n                 }"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/ReadAheadCache.java","diff":"@@ -91,7 +91,7 @@ public Transaction getTransaction() {\n                 try {\n                     return transactionManager.getTransaction();\n                 } catch (SystemException e) {\n-                    throw new IllegalStateException(\"An error occured while getting the \" +\n+                    throw new IllegalStateException(\"An error occurred while getting the \" +\n                             \"transaction associated with the current thread: \" + e);\n                 }\n             }\n@@ -431,11 +431,11 @@ public void addPreloadData(Object pk,\n \n         // store the preloaded data\n         Map preloadDataMap = getPreloadDataMap(pk, true);\n-        Object overriden = preloadDataMap.put(field, fieldValue);\n+        Object overridden = preloadDataMap.put(field, fieldValue);\n \n-        if (log.isTraceEnabled() && overriden != null) {\n+        if (log.isTraceEnabled() && overridden != null) {\n             log.trace(\n-                    \"Overriding cached value \" + overriden +\n+                    \"Overriding cached value \" + overridden +\n                             \" with \" + (fieldValue == NULL_VALUE ? null : fieldValue) +\n                             \". pk=\" + pk +\n                             \", field=\" + field.getFieldName()\n@@ -626,7 +626,7 @@ public Transaction getTransaction() {\n                     try {\n                         return transactionManager.getTransaction();\n                     } catch (SystemException e) {\n-                        throw new IllegalStateException(\"An error occured while getting the \" +\n+                        throw new IllegalStateException(\"An error occurred while getting the \" +\n                                 \"transaction associated with the current thread: \" + e);\n                     }\n                 }"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/bridge/CMPMessage.java","diff":"@@ -26,7 +26,7 @@\n \n /**\n  * Type safe enumeration of message objects.\n- * Used by optmistic lock to lock fields and its values dependeding\n+ * Used by optimistic lock to lock fields and its values depending\n  * on the strategy used.\n  *\n  * @author <a href=\"mailto:aloubyansky@hotmail.com\">Alex Loubyansky</a>"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/bridge/JDBCAbstractCMPFieldBridge.java","diff":"@@ -213,7 +213,7 @@ public void setValue(CmpEntityBeanContext ctx, Object value) {\n \n         if (ctx.isValid()) {\n             if (!isLoaded(ctx)) {\n-                // the field must be loaded for dirty cheking to work properly\n+                // the field must be loaded for dirty checking to work properly\n                 manager.loadField(this, ctx);\n             }\n             lockingStrategy.changed(this, ctx);\n@@ -246,7 +246,7 @@ public Object setPrimaryKeyValue(Object primaryKey, Object value)\n             throws IllegalArgumentException {\n         try {\n             if (primaryKeyField != null) {\n-                // if we are tring to set a null value\n+                // if we are trying to set a null value\n                 // into a null pk, we are already done.\n                 if (value == null && primaryKey == null) {\n                     return null;\n@@ -360,7 +360,7 @@ public int loadPrimaryKeyResults(ResultSet rs, int parameterIndex, Object[] pkRe\n         // set the value of this field into the pk\n         pkRef[0] = argumentRef[0] == null ? null : setPrimaryKeyValue(pkRef[0], argumentRef[0]);\n \n-        // retrun the updated parameterIndex\n+        // return the updated parameterIndex\n         return parameterIndex;\n     }\n \n@@ -416,7 +416,7 @@ private int loadArgumentResults(ResultSet rs, int parameterIndex, Object[] argum\n                 argumentRef[0] = jdbcType.setColumnValue(i, argumentRef[0], columnValue);\n             }\n \n-            // retrun the updated parameterIndex\n+            // return the updated parameterIndex\n             return parameterIndex;\n         } catch (SQLException e) {\n             // Non recoverable internal exception"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/bridge/JDBCCMP2xFieldBridge.java","diff":"@@ -475,7 +475,7 @@ public CMRChainLink(JDBCCMRFieldBridge cmrField) {\n         /**\n          * Going down the chain current related id is calculated and stored in oldRelatedId.\n          * When the next link is originator, the flow is going backward:\n-         * - field state is updated with new vaue;\n+         * - field state is updated with new value;\n          * - new related id is calculated;\n          * - old relationship is destroyed (if there is one);\n          * - new relationship is established (if it is valid)."},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/bridge/JDBCCMRFieldBridge.java","diff":"@@ -100,11 +100,11 @@\n      */\n     private final JDBCRelationshipRoleMetaData metadata;\n     /**\n-     * The data source used to acess the relation table if relevant.\n+     * The data source used to access the relation table if relevant.\n      */\n     private DataSource dataSource;\n     /**\n-     * The relation table name if relevent.\n+     * The relation table name if relevant.\n      */\n     private String qualifiedTableName;\n     private String tableName;\n@@ -198,7 +198,7 @@ public JDBCCMRFieldBridge(JDBCEntityBridge entity,\n         this.metadata = metadata;\n         this.jdbcContextIndex = ((JDBCEntityBridge) manager.getEntityBridge()).getNextJDBCContextIndex();\n \n-        //  Creat the log\n+        //  Create the log\n         String categoryName = this.getClass().getName() +\n                 \".\" + manager.getMetaData().getName() + \".\";\n         if (metadata.getCMRFieldName() != null) {\n@@ -352,7 +352,7 @@ public Transaction getTransaction() {\n                 try {\n                     return transactionManager.getTransaction();\n                 } catch (SystemException e) {\n-                    throw new IllegalStateException(\"An error occured while getting the \" +\n+                    throw new IllegalStateException(\"An error occurred while getting the \" +\n                             \"transaction associated with the current thread: \" + e);\n                 }\n             }\n@@ -424,7 +424,7 @@ public String getFieldName() {\n     }\n \n     /**\n-     * Gets the name of the relation table if relevent.\n+     * Gets the name of the relation table if relevant.\n      */\n     public String getQualifiedTableName() {\n         return qualifiedTableName;\n@@ -435,7 +435,7 @@ public String getTableName() {\n     }\n \n     /**\n-     * Gets the datasource of the relation table if relevent.\n+     * Gets the datasource of the relation table if relevant.\n      */\n     public DataSource getDataSource() {\n         return dataSource;\n@@ -1087,7 +1087,7 @@ private void load(CmpEntityBeanContext myCtx) {\n \n         // check the preload cache\n         if (log.isTraceEnabled()) {\n-            log.trace(\"Read ahead cahce load: cmrField=\" + getFieldName() + \" pk=\" + myCtx.getPrimaryKey());\n+            log.trace(\"Read ahead cache load: cmrField=\" + getFieldName() + \" pk=\" + myCtx.getPrimaryKey());\n         }\n \n         manager.getReadAheadCache().load(myCtx);\n@@ -1602,7 +1602,7 @@ public void removeRelation(Object fk) {\n          * loads the collection of related ids\n          */\n         public void loadRelations(Collection values) {\n-            // check if we are aleready loaded\n+            // check if we are already loaded\n             if (isLoaded) {\n                 throw new EJBException(\"CMR field value is already loaded\");\n             }\n@@ -1647,14 +1647,14 @@ public Set getRelationSet() {\n                         true);\n             }\n \n-            // if we already have a relationset use it\n+            // if we already have a relationSet use it\n             if (relationSet != null) {\n                 return relationSet;\n             }\n \n-            // construct a new relationshet\n+            // construct a new relationSet\n             try {\n-                // get the curent transaction\n+                // get the current transaction\n                 CmpEntityBeanComponent component = getJDBCStoreManager().getComponent();\n                 TransactionManager tm = component.getTransactionManager();\n                 Transaction tx = tm.getTransaction();\n@@ -1866,7 +1866,7 @@ public Transaction getTransaction() {\n                     try {\n                         return transactionManager.getTransaction();\n                     } catch (SystemException e) {\n-                        throw new IllegalStateException(\"An error occured while getting the \" +\n+                        throw new IllegalStateException(\"An error occurred while getting the \" +\n                                 \"transaction associated with the current thread: \" + e);\n                     }\n                 }"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/bridge/JDBCEntityBridge.java","diff":"@@ -659,7 +659,7 @@ public Object extractPrimaryKeyFromInstance(CmpEntityBeanContext ctx) {\n                 Object fieldValue = pkField.getInstanceValue(ctx);\n \n                 // updated pk object with return form set primary key value to\n-                // handle single valued non-composit pks and more complicated behivors.\n+                // handle single valued non-composite pks and more complicated behivors.\n                 pk = pkField.setPrimaryKeyValue(pk, fieldValue);\n             }\n             return pk;\n@@ -933,7 +933,7 @@ private JDBCCMPFieldBridge createCMPField(JDBCEntityMetaData metadata,\n \n     private void loadSelectors(JDBCEntityMetaData metadata) {\n         // Don't know if this is the best way to do this.  Another way would be\n-        // to deligate seletors to the JDBCFindEntitiesCommand, but this is\n+        // to delegate selectors to the JDBCFindEntitiesCommand, but this is\n         // easier now.\n         selectorsByMethod = new HashMap(metadata.getQueries().size());\n         Iterator definedFinders = manager.getMetaData().getQueries().iterator();"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/bridge/JDBCFieldBridge.java","diff":"@@ -101,7 +101,7 @@\n     int loadInstanceResults(ResultSet rs, int parameterIndex, CmpEntityBeanContext ctx);\n \n     /**\n-     * Loads the value of this cmp field from result set into argument referance.\n+     * Loads the value of this cmp field from result set into argument reference.\n      */\n     int loadArgumentResults(ResultSet rs, int parameterIndex, Object[] argumentRef);\n "},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/keygen/GetTCLAction.java","diff":"@@ -26,7 +26,7 @@\n \n /**\n  * @author Scott.Stark@jboss.org\n- * @version $Revison:$\n+ * @version $Revision:$\n  */\n public class GetTCLAction implements PrivilegedAction {\n     static PrivilegedAction ACTION = new GetTCLAction();"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/keygen/JDBCOracleCreateCommand.java","diff":"@@ -33,7 +33,7 @@\n import org.jboss.as.cmp.jdbc.metadata.JDBCEntityCommandMetaData;\n \n /**\n- * Create command for use with Oracle that uses a sequence in conjuction with\n+ * Create command for use with Oracle that uses a sequence in conjunction with\n  * a RETURNING clause to generate keys in a single statement\n  *\n  * @author <a href=\"mailto:jeremy@boynes.com\">Jeremy Boynes</a>"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/keygen/JDBCOracleSequenceCreateCommand.java","diff":"@@ -33,7 +33,7 @@\n import org.jboss.as.cmp.jdbc.metadata.JDBCEntityCommandMetaData;\n \n /**\n- * Create command for use with Oracle that uses a sequence in conjuction with\n+ * Create command for use with Oracle that uses a sequence in conjunction with\n  * a RETURNING clause to generate keys in a single statement\n  * <p/>\n  * The sequence is called by the parameter attribute \"sequence_name\"."},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/GetTCLAction.java","diff":"@@ -26,7 +26,7 @@\n \n /**\n  * @author Scott.Stark@jboss.org\n- * @version $Revison:$\n+ * @version $Revision:$\n  */\n public class GetTCLAction implements PrivilegedAction {\n     static PrivilegedAction ACTION = new GetTCLAction();"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCApplicationMetaData.java","diff":"@@ -342,7 +342,7 @@ public JDBCTypeMappingMetaData getTypeMappingByName(String name) {\n     /**\n      * Gets the relationship roles for the entity with the specified name.\n      *\n-     * @param entityName the name of the entity whos roles are returned\n+     * @param entityName the name of the entity whose roles are returned\n      * @return an unmodifiable collection of JDBCRelationshipRoles\n      *         of the specified entity\n      */"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCAutomaticQueryMetaData.java","diff":"@@ -25,9 +25,9 @@\n \n /**\n  * This immutable class contains information about an automatically generated\n- * query. This class is a place holder used to make an automaticlly generated\n+ * query. This class is a place holder used to make an automatically generated\n  * query look more like a user specified query.  This class only contains a\n- * referance to the method used to invoke this query.\n+ * reference to the method used to invoke this query.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n  * @author <a href=\"sebastien.alborini@m4x.org\">Sebastien Alborini</a>\n@@ -35,7 +35,7 @@\n  */\n public final class JDBCAutomaticQueryMetaData implements JDBCQueryMetaData {\n     /**\n-     * A referance to the method which invokes this query.\n+     * A reference to the method which invokes this query.\n      */\n     private final Method method;\n "},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCCMPFieldMetaData.java","diff":"@@ -31,7 +31,7 @@\n import org.jboss.logging.Logger;\n \n /**\n- * Imutable class which holds all the information jbosscmp-jdbc needs to know\n+ * Immutable class which holds all the information jbosscmp-jdbc needs to know\n  * about a CMP field It loads its data from standardjbosscmp-jdbc.xml and\n  * jbosscmp-jdbc.xml\n  *\n@@ -90,7 +90,7 @@\n     private final int readTimeOut;\n \n     /**\n-     * Is this field a memeber of the primary keys or the sole prim-key-field.\n+     * Is this field a member of the primary keys or the sole prim-key-field.\n      */\n     private final boolean primaryKeyMember;\n \n@@ -450,7 +450,7 @@ public JDBCCMPFieldMetaData(JDBCEntityMetaData entity, ParsedCmpField parsedFiel\n         }\n \n         // Field type\n-        // must be set for unknow-pk\n+        // must be set for unknown-pk\n \n         if (parsedField.getUnknownPk() == null) {\n             fieldType = defaultValues.getFieldType();\n@@ -562,10 +562,10 @@ public String getFieldName() {\n \n     /**\n      * Gets the column name the property should use or null if the\n-     * column name is not overriden.\n+     * column name is not overridden.\n      *\n      * @return the name to which this field is persisted or null if the\n-     *         column name is not overriden\n+     *         column name is not overridden\n      */\n     public String getColumnName() {\n         return columnName;\n@@ -573,7 +573,7 @@ public String getColumnName() {\n \n     /**\n      * Gets the JDBC type the property should use or Integer.MIN_VALUE\n-     * if not overriden.\n+     * if not overridden.\n      *\n      * @return the jdbc type of this field\n      */\n@@ -583,7 +583,7 @@ public int getJDBCType() {\n \n     /**\n      * Gets the SQL type the property should use or null\n-     * if not overriden.\n+     * if not overridden.\n      *\n      * @return the sql data type string used in create table statements\n      */"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCCMPFieldPropertyMetaData.java","diff":"@@ -22,7 +22,7 @@\n package org.jboss.as.cmp.jdbc.metadata;\n \n /**\n- * This immutable class contains information about the an overriden field property.\n+ * This immutable class contains information about the an overridden field property.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n  * @version $Revision: 81030 $\n@@ -59,7 +59,7 @@\n     private boolean notNull;\n \n     /**\n-     * Gets the name of the property to be overriden.\n+     * Gets the name of the property to be overridden.\n      */\n     public String getPropertyName() {\n         return propertyName;\n@@ -67,7 +67,7 @@ public String getPropertyName() {\n \n     /**\n      * Gets the column name the property should use or null if the\n-     * column name is not overriden.\n+     * column name is not overridden.\n      */\n     public String getColumnName() {\n         return columnName;\n@@ -75,7 +75,7 @@ public String getColumnName() {\n \n     /**\n      * Gets the JDBC type the property should use or Integer.MIN_VALUE\n-     * if not overriden.\n+     * if not overridden.\n      */\n     public int getJDBCType() {\n         return jdbcType;\n@@ -83,7 +83,7 @@ public int getJDBCType() {\n \n     /**\n      * Gets the SQL type the property should use or null\n-     * if not overriden.\n+     * if not overridden.\n      */\n     public String getSQLType() {\n         return sqlType;"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCDeclaredQueryMetaData.java","diff":"@@ -26,7 +26,7 @@\n \n \n /**\n- * Imutable class contains information about a declated query.\n+ * Immutable class contains information about a declared query.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n  * @version $Revision: 81030 $\n@@ -79,7 +79,7 @@\n     private final String fieldName;\n \n     /**\n-     * The aliase that is used for the main select table.\n+     * The alias that is used for the main select table.\n      */\n     private final String alias;\n     /**\n@@ -241,7 +241,7 @@ public String getOrder() {\n \n     /**\n      * Gets other sql code which is appended to the end of the query.\n-     * This is userful for supplying hints to the query engine.\n+     * This is useful for supplying hints to the query engine.\n      *\n      * @return a String which contains additional sql code which is\n      *         appended to the end of the query"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCDynamicQLQueryMetaData.java","diff":"@@ -49,7 +49,7 @@\n \n     /**\n      * Constructs a JDBCDynamicQLQueryMetaData with DynamicQL declared in the\n-     * jboss-ql elemnt and is invoked by the specified method.\n+     * jboss-ql element and is invoked by the specified method.\n      *\n      * @param defaults the metadata about this query\n      */\n@@ -67,7 +67,7 @@ public JDBCDynamicQLQueryMetaData(JDBCDynamicQLQueryMetaData defaults,\n \n     /**\n      * Constructs a JDBCDynamicQLQueryMetaData with DynamicQL declared in the\n-     * jboss-ql elemnt and is invoked by the specified method.\n+     * jboss-ql element and is invoked by the specified method.\n      */\n     public JDBCDynamicQLQueryMetaData(boolean resultTypeMappingLocal,\n                                       Method method,"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCEntityMetaData.java","diff":"@@ -449,7 +449,7 @@ public JDBCEntityMetaData(JDBCApplicationMetaData jdbcApplication, JDBCEntityMet\n \n     public JDBCEntityMetaData(JDBCApplicationMetaData jdbcApplication, ParsedEntity parsed, JDBCEntityMetaData defaultValues) {\n         // store passed in application... application in defaultValues may\n-        // be different because jdbcApplication is imutable\n+        // be different because jdbcApplication is immutable\n         this.jdbcApplication = jdbcApplication;\n \n         // set default values\n@@ -724,7 +724,7 @@ public JDBCEntityMetaData(JDBCApplicationMetaData jdbcApplication, ParsedEntity\n     /**\n      * Gets the meta data for the application of which this entity is a member.\n      *\n-     * @return the meta data for the application that this entity is a memeber\n+     * @return the meta data for the application that this entity is a member\n      */\n     public JDBCApplicationMetaData getJDBCApplication() {\n         return jdbcApplication;\n@@ -767,7 +767,7 @@ public String getName() {\n     }\n \n     /**\n-     * Gets the abstract shcema name of this entity. The name come from\n+     * Gets the abstract schema name of this entity. The name come from\n      * the ejb-jar.xml file.\n      *\n      * @return the abstract schema name of this entity\n@@ -859,7 +859,7 @@ public String getEagerLoadGroup() {\n     }\n \n     /**\n-     * Gets the map from load grou name to a List of field names, which\n+     * Gets the map from load group name to a List of field names, which\n      * forms a logical load group.\n      *\n      * @return an unmodifiable map of load groups (Lists) by group name.\n@@ -943,7 +943,7 @@ public boolean getAlterTable() {\n     }\n \n     /**\n-     * Get the (user-defined) SQL commands that sould be issued after table\n+     * Get the (user-defined) SQL commands that should be issued after table\n      * creation\n      *\n      * @return the SQL command to issue to the DB-server\n@@ -954,7 +954,7 @@ public boolean getAlterTable() {\n \n     /**\n      * Gets the flag used to determine if the store manager should add a\n-     * priary key constraint when creating the table\n+     * primary key constraint when creating the table\n      *\n      * @return true if the store manager should add a primary key constraint to\n      *         the create table sql statement\n@@ -975,7 +975,7 @@ public boolean hasRowLocking() {\n     }\n \n     /**\n-     * The maximum number of qurey result lists that will be tracked.\n+     * The maximum number of query result lists that will be tracked.\n      */\n     public int getListCacheMax() {\n         return listCacheMax;\n@@ -1007,7 +1007,7 @@ public JDBCQueryMetaData getQueryMetaDataForMethod(Method method) {\n     }\n \n     /**\n-     * Get the relationsip roles of this entity.\n+     * Get the relationship roles of this entity.\n      * Items are instance of JDBCRelationshipRoleMetaData.\n      *\n      * @return an unmodifiable collection of the relationship roles defined"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCFunctionMappingMetaData.java","diff":"@@ -120,7 +120,7 @@ public StringBuffer getFunctionSql(Object[] args, StringBuffer buf) {\n         for (int i = 0; i < sqlChunks.length; i++) {\n             if (i < parameters.length) {\n                 // the logic is that if there is a parameter\n-                // than append its chunck unless the parameter is null\n+                // than append its chunk unless the parameter is null\n                 // FIXME: I am not sure it's ok for any kind of template.\n                 Object arg = args[parameters[i]];\n                 if (arg != null) {"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCJBossQLQueryMetaData.java","diff":"@@ -56,7 +56,7 @@\n \n     /**\n      * Constructs a JDBCJBossQLQueryMetaData with JBossQL declared in the\n-     * jboss-ql elemnt and is invoked by the specified method.\n+     * jboss-ql element and is invoked by the specified method.\n      */\n     public JDBCJBossQLQueryMetaData(JDBCJBossQLQueryMetaData defaults,\n                                     JDBCReadAheadMetaData readAhead,"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCMappingMetaData.java","diff":"@@ -24,7 +24,7 @@\n import org.jboss.logging.Logger;\n \n /**\n- * Imutable class which holds a mapping between a Java Class and a JDBC type\n+ * Immutable class which holds a mapping between a Java Class and a JDBC type\n  * and a SQL type.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCOptimisticLockingMetaData.java","diff":"@@ -49,7 +49,7 @@\n     private final String groupName;\n \n     /**\n-     * locking field for verion- or timestamp-column strategy\n+     * locking field for version- or timestamp-column strategy\n      */\n     private final JDBCCMPFieldMetaData lockingField;\n \n@@ -107,7 +107,7 @@ public JDBCOptimisticLockingMetaData(JDBCEntityMetaData entity, ParsedOptimistic\n                 break;\n             }\n             default: {\n-                throw new RuntimeException(\"Unexpected error: entity \" + entity.getName() + \" has unkown/incorrect optimistic locking configuration. -- \" + lockingStrategy);\n+                throw new RuntimeException(\"Unexpected error: entity \" + entity.getName() + \" has unknown/incorrect optimistic locking configuration. -- \" + lockingStrategy);\n             }\n         }\n     }"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCQueryMetaData.java","diff":"@@ -25,7 +25,7 @@\n \n /**\n  * This interface is used to identify a query that will be invoked in\n- * responce to the invocation of a finder method in a home interface or\n+ * response to the invocation of a finder method in a home interface or\n  * an ejbSelect method in a bean implementation class.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCQueryMetaDataFactory.java","diff":"@@ -33,7 +33,7 @@\n \n /**\n  * JDBCQueryMetaDataFactory constructs a JDBCQueryMetaData object based\n- * on the query specifiection type.\n+ * on the query specification type.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n  * @version $Revision: 81030 $"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCRawSqlQueryMetaData.java","diff":"@@ -24,7 +24,7 @@\n import java.lang.reflect.Method;\n \n /**\n- * Imutable class which holds information about a raw sql query.\n+ * Immutable class which holds information about a raw sql query.\n  * A raw sql query allows you to do anything sql allows you to do.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCReadAheadMetaData.java","diff":"@@ -117,14 +117,14 @@ public boolean isNone() {\n     }\n \n     /**\n-     * Is the read ahead stratey on-load\n+     * Is the read ahead strategy on-load\n      */\n     public boolean isOnLoad() {\n         return (strategy == ON_LOAD);\n     }\n \n     /**\n-     * Is the read ahead stratey on-find\n+     * Is the read ahead strategy on-find\n      */\n     public boolean isOnFind() {\n         return (strategy == ON_FIND);"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCRelationMetaData.java","diff":"@@ -224,8 +224,8 @@ public JDBCRelationMetaData(JDBCApplicationMetaData jdbcApplication, JDBCRelatio\n     }\n \n     public JDBCRelationMetaData(JDBCApplicationMetaData jdbcApplication, ParsedEntity defaultEntity, JDBCRelationMetaData defaultValues) {\n-        String perferredRelationMapping = defaultEntity.getPreferredMappingStyle();\n-        if (\"relation-table\".equals(perferredRelationMapping) || defaultValues.isManyToMany()) {\n+        String preferredRelationMapping = defaultEntity.getPreferredMappingStyle();\n+        if (\"relation-table\".equals(preferredRelationMapping) || defaultValues.isManyToMany()) {\n             mappingStyle = MappingStyle.TABLE;\n         } else {\n             mappingStyle = MappingStyle.FOREIGN_KEY;\n@@ -579,8 +579,8 @@ public String getDefaultTableName() {\n \n     /**\n      * Does the table exist yet? This does not mean that table has been created\n-     * by the appilcation, or the the database metadata has been checked for the\n-     * existance of the table, but that at this point the table is assumed to\n+     * by the application, or the the database metadata has been checked for the\n+     * existence of the table, but that at this point the table is assumed to\n      * exist.\n      *\n      * @return true if the table exists\n@@ -607,7 +607,7 @@ public boolean isTableDropped() {\n     /**\n      * Should the relation table be created on startup.\n      *\n-     * @return true if the store mananager should attempt to create the relation\n+     * @return true if the store manager should attempt to create the relation\n      *         table\n      */\n     public boolean getCreateTable() {\n@@ -617,7 +617,7 @@ public boolean getCreateTable() {\n     /**\n      * Should the relation table be removed on shutdown.\n      *\n-     * @return true if the store mananager should attempt to remove the relation\n+     * @return true if the store manager should attempt to remove the relation\n      *         table\n      */\n     public boolean getRemoveTable() {\n@@ -635,7 +635,7 @@ public boolean getAlterTable() {\n      * When the relation table is created, should it have a primary key\n      * constraint.\n      *\n-     * @return true if the store mananager should add a primary key constraint\n+     * @return true if the store manager should add a primary key constraint\n      *         to the the create table sql statement\n      */\n     public boolean hasPrimaryKeyConstraint() {"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCRelationshipRoleMetaData.java","diff":"@@ -32,7 +32,7 @@\n import org.jboss.metadata.ejb.spec.RelationRoleMetaData;\n \n /**\n- * Imutable class which represents one ejb-relationship-role element found in\n+ * Immutable class which represents one ejb-relationship-role element found in\n  * the ejb-jar.xml file's ejb-relation elements.\n  *\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n@@ -231,7 +231,7 @@ public String getRelationshipRoleName() {\n     /**\n      * Should this role use a foreign key constraint.\n      *\n-     * @return true if the store mananager will execute an ALTER TABLE ADD\n+     * @return true if the store manager will execute an ALTER TABLE ADD\n      *         CONSTRAINT statement to add a foreign key constraint.\n      */\n     public boolean hasForeignKeyConstraint() {\n@@ -417,10 +417,10 @@ else if (getRelatedRole().isMultiplicityOne() && !getRelatedRole().isNavigable()\n             fields.put(cmpField.getFieldName(), cmpField);\n         }\n \n-        // all fields must be overriden\n+        // all fields must be overridden\n         if (!defaultFields.isEmpty()) {\n             throw new RuntimeException(\"Mappings were not provided for all \" +\n-                    \"fields: unmaped fields=\" + defaultFields.keySet() +\n+                    \"fields: unmapped fields=\" + defaultFields.keySet() +\n                     \" in role=\" + relationshipRoleName);\n         }\n         return Collections.unmodifiableMap(fields);"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCTypeMappingMetaData.java","diff":"@@ -26,7 +26,7 @@\n \n \n /**\n- * Imutable class which holds a map between Java Classes and JDBCMappingMetaData.\n+ * Immutable class which holds a map between Java Classes and JDBCMappingMetaData.\n  *\n  * @author John Bailey\n  * @author <a href=\"mailto:dain@daingroup.com\">Dain Sundstrom</a>\n@@ -115,7 +115,7 @@ public String getName() {\n     /**\n      * Gets the prefix for that is used when generating an alias header.  An\n      * alias header is prepended to a generated table alias to prevent name\n-     * collisions. An alias header is constructed as folows:\n+     * collisions. An alias header is constructed as follows:\n      * aliasHeaderPrefix + int_counter + aliasHeaderSuffix\n      *\n      * @return the prefix for alias headers\n@@ -127,7 +127,7 @@ public String getAliasHeaderPrefix() {\n     /**\n      * Gets the suffix for that is used when generating an alias header.  An\n      * alias header is prepended to a generated table alias to prevent name\n-     * collisions. An alias header is constructed as folows:\n+     * collisions. An alias header is constructed as follows:\n      * aliasHeaderPrefix + int_counter + aliasHeaderSuffix\n      *\n      * @return the suffix for alias headers\n@@ -138,7 +138,7 @@ public String getAliasHeaderSuffix() {\n \n     /**\n      * Gets maximum length of a table alias.\n-     * An alias is constructed as folows: aliasHeader + ejb_ql_identifier_path\n+     * An alias is constructed as follows: aliasHeader + ejb_ql_identifier_path\n      *\n      * @return the maximum length that a table alias can be\n      */\n@@ -259,7 +259,7 @@ public void setName(final String name) {\n         this.name = name;\n     }\n \n-    public void setAddColomnTemplate(final JDBCFunctionMappingMetaData addColumn) {\n+    public void setAddColumnTemplate(final JDBCFunctionMappingMetaData addColumn) {\n         this.addColumn = addColumn;\n     }\n \n@@ -275,7 +275,7 @@ public void setFKConstraintTemplate(final JDBCFunctionMappingMetaData fkConstrai\n         this.fkConstraint = fkConstraint;\n     }\n \n-    public void setAlterColomnTemplate(final JDBCFunctionMappingMetaData alterColumn) {\n+    public void setAlterColumnTemplate(final JDBCFunctionMappingMetaData alterColumn) {\n         this.alterColumn = alterColumn;\n     }\n \n@@ -295,7 +295,7 @@ public void setAutoIncrementTemplate(final JDBCFunctionMappingMetaData autoIncre\n         this.autoIncrement = autoIncrement;\n     }\n \n-    public void setDropColomnTemplate(final JDBCFunctionMappingMetaData dropColumn) {\n+    public void setDropColumnTemplate(final JDBCFunctionMappingMetaData dropColumn) {\n         this.dropColumn = dropColumn;\n     }\n "},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/JDBCUserTypeMappingMetaData.java","diff":"@@ -40,11 +40,11 @@\n      */\n     private String mapper;\n     /**\n-     * Check a field of this type for dirty state after the getter: null, true or false (can be overriden on the field level)\n+     * Check a field of this type for dirty state after the getter: null, true or false (can be overridden on the field level)\n      */\n     private byte checkDirtyAfterGet = JDBCCMPFieldMetaData.CHECK_DIRTY_AFTER_GET_NOT_PRESENT;\n     /**\n-     * CMP field state factory class that should be used for fields of this type unless overriden on the field level\n+     * CMP field state factory class that should be used for fields of this type unless overridden on the field level\n      */\n     private String stateFactory;\n "},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/parser/Element.java","diff":"@@ -116,7 +116,7 @@\n     PK_CONSTRAINT(\"pk-constraint\"),\n     PK_CONSTRAINT_TEMPLATE(\"pk-constraint-template\"),\n     POST_TABLE_CREATE(\"post-table-create\"),\n-    PREFERED_RELATION(\"preferred-relation-mapping\"),\n+    PREFERRED_RELATION(\"preferred-relation-mapping\"),\n     PROPERTY(\"property\"),\n     PROPERTY_NAME(\"property-name\"),\n     QL_COMPILER(\"ql-compiler\"),"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc/metadata/parser/JDBCMetaDataParser.java","diff":"@@ -129,9 +129,9 @@ private static JDBCTypeMappingMetaData parseTypeMapping(final XMLStreamReader re\n                 case ADD_COLUMN_TEMPLATE: {\n                     final String value = getElementText(reader);\n                     if (!isEmpty(value)) {\n-                        metaData.setAddColomnTemplate(new JDBCFunctionMappingMetaData(\"add-column-template\", value));\n+                        metaData.setAddColumnTemplate(new JDBCFunctionMappingMetaData(\"add-column-template\", value));\n                     } else {\n-                        metaData.setAddColomnTemplate(new JDBCFunctionMappingMetaData(\"add-column-template\", \"ALTER TABLE ?1 ADD ?2 ?3\"));\n+                        metaData.setAddColumnTemplate(new JDBCFunctionMappingMetaData(\"add-column-template\", \"ALTER TABLE ?1 ADD ?2 ?3\"));\n                     }\n                     break;\n                 }\n@@ -162,9 +162,9 @@ private static JDBCTypeMappingMetaData parseTypeMapping(final XMLStreamReader re\n                 case ALTER_COLUMN_TEMPLATE: {\n                     final String value = getElementText(reader);\n                     if (!isEmpty(value)) {\n-                        metaData.setAlterColomnTemplate(new JDBCFunctionMappingMetaData(\"add-column-template\", value));\n+                        metaData.setAlterColumnTemplate(new JDBCFunctionMappingMetaData(\"add-column-template\", value));\n                     } else {\n-                        metaData.setAlterColomnTemplate(new JDBCFunctionMappingMetaData(\"add-column-template\", \"ALTER TABLE ?1 ADD ?2 ?3\"));\n+                        metaData.setAlterColumnTemplate(new JDBCFunctionMappingMetaData(\"add-column-template\", \"ALTER TABLE ?1 ADD ?2 ?3\"));\n                     }\n                     break;\n                 }\n@@ -178,9 +178,9 @@ private static JDBCTypeMappingMetaData parseTypeMapping(final XMLStreamReader re\n                 case DROP_COLUMN_TEMPLATE: {\n                     final String value = getElementText(reader);\n                     if (!isEmpty(value)) {\n-                        metaData.setDropColomnTemplate(new JDBCFunctionMappingMetaData(\"drop-column-template\", value));\n+                        metaData.setDropColumnTemplate(new JDBCFunctionMappingMetaData(\"drop-column-template\", value));\n                     } else {\n-                        metaData.setDropColomnTemplate(new JDBCFunctionMappingMetaData(\"drop-column-template\", \"ALTER TABLE ?1 DROP ?2\"));\n+                        metaData.setDropColumnTemplate(new JDBCFunctionMappingMetaData(\"drop-column-template\", \"ALTER TABLE ?1 DROP ?2\"));\n                     }\n                     break;\n                 }\n@@ -199,7 +199,7 @@ private static JDBCTypeMappingMetaData parseTypeMapping(final XMLStreamReader re\n                     break;\n                 }\n                 case FUNCTION_MAPPING: {\n-                    metaData.addFunctionMapping(parseFuctionMapping(reader));\n+                    metaData.addFunctionMapping(parseFunctionMapping(reader));\n                     break;\n                 }\n                 case MAPPING: {\n@@ -250,7 +250,7 @@ private static JDBCTypeMappingMetaData parseTypeMapping(final XMLStreamReader re\n         return metaData;\n     }\n \n-    private static JDBCFunctionMappingMetaData parseFuctionMapping(final XMLStreamReader reader) throws XMLStreamException {\n+    private static JDBCFunctionMappingMetaData parseFunctionMapping(final XMLStreamReader reader) throws XMLStreamException {\n \n         final JDBCFunctionMappingMetaData metaData = new JDBCFunctionMappingMetaData();\n         for (Element element : children(reader)) {\n@@ -825,7 +825,7 @@ private static ParsedEntity parseEntity(final XMLStreamReader reader, final Clas\n                     metaData.audit = parseAudit(reader);\n                     break;\n                 }\n-                case PREFERED_RELATION: {\n+                case PREFERRED_RELATION: {\n                     getElementText(reader); // TODO: jeb How to handle this\n                     break;\n                 }"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc2/AbstractQueryCommand.java","diff":"@@ -173,7 +173,7 @@ static Collection fetchCollection(JDBCEntityBridge2 entity,\n         ResultSet rs = null;\n         boolean throwRuntimeExceptions = entity.getMetaData().getThrowRuntimeExceptions();\n \n-        // if metadata is true, the getconnection is done inside\n+        // if metadata is true, the getConnection is done inside\n         // its own try catch block to throw a runtime exception (EJBException)\n         if (throwRuntimeExceptions) {\n             try {\n@@ -189,7 +189,7 @@ static Collection fetchCollection(JDBCEntityBridge2 entity,\n                 log.debug(\"executing: \" + sql);\n             }\n \n-            // if metadata is false, the getconnection is done inside this try catch block\n+            // if metadata is false, the getConnection is done inside this try catch block\n             if (!throwRuntimeExceptions) {\n                 con = entity.getDataSource().getConnection();\n             }\n@@ -239,7 +239,7 @@ static Object fetchOne(JDBCEntityBridge2 entity,\n         ResultSet rs = null;\n         boolean throwRuntimeExceptions = entity.getMetaData().getThrowRuntimeExceptions();\n \n-        // if metadata is true, the getconnection is done inside\n+        // if metadata is true, the getConnection is done inside\n         // its own try catch block to throw a runtime exception (EJBException)\n         if (throwRuntimeExceptions) {\n             try {\n@@ -255,7 +255,7 @@ static Object fetchOne(JDBCEntityBridge2 entity,\n                 log.debug(\"executing: \" + sql);\n             }\n \n-            // if metadata is false, the getconnection is done inside this try catch block\n+            // if metadata is false, the getConnection is done inside this try catch block\n             if (!throwRuntimeExceptions) {\n                 con = entity.getDataSource().getConnection();\n             }"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc2/bridge/JDBCCMPFieldBridge2.java","diff":"@@ -198,7 +198,7 @@ public Object loadArgumentResults(ResultSet rs, int parameterIndex)\n                 columnValue = jdbcType.setColumnValue(i, null, columnValue);\n             }\n \n-            // retrun the updated parameterIndex\n+            // return the updated parameterIndex\n             return columnValue;\n         } catch (SQLException e) {\n             // Non recoverable internal exception"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc2/bridge/JDBCCMRFieldBridge2.java","diff":"@@ -604,7 +604,7 @@ public void addLoadedPk(Object pk) {\n                         +\n                         getFieldName()\n                         +\n-                        \" single-valued CMR field is already loaded. Check the database for consistancy. \"\n+                        \" single-valued CMR field is already loaded. Check the database for consistency. \"\n                         + \" current value=\" + value + \", loaded value=\" + pk\n                 );\n             }\n@@ -781,7 +781,7 @@ public void addLoadedPk(Object pk) {\n                         +\n                         getFieldName()\n                         +\n-                        \" collection-valued CMR field is already loaded. Check the database for consistancy. \"\n+                        \" collection-valued CMR field is already loaded. Check the database for consistency. \"\n                         + \" current value=\" + value + \", loaded value=\" + pk\n                 );\n             }"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc2/bridge/JDBCEntityBridge2.java","diff":"@@ -161,7 +161,7 @@ public Object extractPrimaryKeyFromInstance(CmpEntityBeanContext ctx) {\n     }\n \n     public static void destroyPersistenceContext(CmpEntityBeanContext ctx) {\n-        // If we have an EJB 2.0 dynaymic proxy,\n+        // If we have an EJB 2.0 dynamic proxy,\n         // notify the handler of the assigned context.\n         // Object instance = ctx.getComponent().getCache().get(ctx.getPrimaryKey());\n         // TODO: jeb - Set context on proxy\n@@ -169,7 +169,7 @@ public static void destroyPersistenceContext(CmpEntityBeanContext ctx) {\n     }\n \n     public void initPersistenceContext(CmpEntityBeanContext ctx) {\n-        // If we have an EJB 2.0 dynaymic proxy,\n+        // If we have an EJB 2.0 dynamic proxy,\n         // notify the handler of the assigned context.\n         //Object instance = ctx.getComponent().getCache().get(ctx.getPrimaryKey());\n         // TODO: jeb - Set context on proxy"},{"filename":"cmp/src/main/java/org/jboss/as/cmp/jdbc2/schema/EntityTable.java","diff":"@@ -868,7 +868,7 @@ public void flushCreated(Schema.Views views) throws SQLException {\n             if (references != null) {\n                 if (inFlush) {\n                     if (log.isTraceEnabled()) {\n-                        log.trace(\"inFlush, ignorning flushCreated\");\n+                        log.trace(\"inFlush, ignoring flushCreated\");\n                     }\n                     return;\n                 } else if (log.isTraceEnabled()) {"},{"filename":"configadmin/src/main/java/org/jboss/as/configadmin/parser/ConfigAdminDescribeHandler.java","diff":"@@ -27,7 +27,7 @@\n import org.jboss.dmr.ModelNode;\n \n /**\n- * Descibe and handle subsystem operations.\n+ * Describe and handle subsystem operations.\n  *\n  * @author Thomas.Diesler@jboss.com\n  */"},{"filename":"configadmin/src/main/java/org/jboss/as/configadmin/parser/ConfigAdminExtension.java","diff":"@@ -56,7 +56,7 @@ public void initialize(ExtensionContext context) {\n         registration.registerOperationHandler(ModelDescriptionConstants.DESCRIBE, ConfigAdminDescribeHandler.INSTANCE, ConfigAdminAdd.DESCRIPTION, false, OperationEntry.EntryType.PRIVATE);\n         registration.registerOperationHandler(ModelDescriptionConstants.REMOVE, ReloadRequiredRemoveStepHandler.INSTANCE, ConfigAdminProviders.SUBSYSTEM_REMOVE, false);\n \n-        // Configuration Admin Setings\n+        // Configuration Admin Settings\n         ManagementResourceRegistration configuration = registration.registerSubModel(PathElement.pathElement(ModelConstants.CONFIGURATION), ConfigAdminProviders.CONFIGURATION_DESCRIPTION);\n         configuration.registerOperationHandler(ModelDescriptionConstants.ADD, ConfigurationAdd.INSTANCE, ConfigurationAdd.DESCRIPTION, false);\n         configuration.registerOperationHandler(ModelDescriptionConstants.REMOVE, ConfigurationRemove.INSTANCE, ConfigurationRemove.DESCRIPTION, false);"},{"filename":"configadmin/src/main/java/org/jboss/as/configadmin/service/ConfigAdminService.java","diff":"@@ -28,7 +28,7 @@\n import org.jboss.msc.service.ServiceName;\n \n /**\n- * Maintains a set of {@link Dictionary}s in the domain model keyd by persistent ID (PID).\n+ * Maintains a set of {@link Dictionary}s in the domain model keyed by persistent ID (PID).\n  *\n  * @author Thomas.Diesler@jboss.com\n  * @since 29-Nov-2010\n@@ -44,7 +44,7 @@\n     Set<String> getConfigurations();\n \n     /**\n-     * True if therer is a configuration for the given PID.\n+     * True if there is a configuration for the given PID.\n      */\n     boolean hasConfiguration(String pid);\n \n@@ -61,7 +61,7 @@\n     Dictionary<String, String> putConfiguration(String pid, Dictionary<String, String> config);\n \n     /**\n-     * REmove the configuration for the given PID.\n+     * Remove the configuration for the given PID.\n      * @return The previously registered configuration or <code>null</code>\n      */\n     Dictionary<String, String> removeConfiguration(String pid);"},{"filename":"configadmin/src/main/java/org/jboss/as/configadmin/service/ConfigAdminServiceImpl.java","diff":"@@ -53,7 +53,7 @@\n import static org.jboss.as.configadmin.ConfigAdminLogger.ROOT_LOGGER;\n \n /**\n- * Maintains a set of {@link Dictionary}s in the domain model keyd be persistent ID (PID).\n+ * Maintains a set of {@link Dictionary}s in the domain model keyed be persistent ID (PID).\n  *\n  * @author Thomas.Diesler@jboss.com\n  * @since 29-Nov-2010\n@@ -94,11 +94,11 @@ public boolean hasConfiguration(String pid) {\n     }\n \n     @Override\n-    public Dictionary<String, String> putConfiguration(String pid, Dictionary<String, String> newconfig) {\n+    public Dictionary<String, String> putConfiguration(String pid, Dictionary<String, String> newConfig) {\n         ModelNode address = getSubsystemAddress();\n         address.add(new ModelNode().set(ModelConstants.CONFIGURATION, pid));\n-        Dictionary<String, String> oldconfig = getConfiguration(pid);\n-        if (oldconfig != null) {\n+        Dictionary<String, String> oldConfig = getConfiguration(pid);\n+        if (oldConfig != null) {\n             ModelNode op = Util.getEmptyOperation(ModelDescriptionConstants.REMOVE, address);\n             try {\n                 controllerClient.execute(op);\n@@ -107,10 +107,10 @@ public boolean hasConfiguration(String pid) {\n             }\n         }\n         ModelNode entries = new ModelNode();\n-        Enumeration<String> keys = newconfig.keys();\n+        Enumeration<String> keys = newConfig.keys();\n         while (keys.hasMoreElements()) {\n             String key = keys.nextElement();\n-            entries.get(key).set(newconfig.get(key));\n+            entries.get(key).set(newConfig.get(key));\n         }\n         ModelNode op = Util.getEmptyOperation(ModelDescriptionConstants.ADD, address);\n         op.get(ModelConstants.ENTRIES).set(entries);\n@@ -118,20 +118,20 @@ public boolean hasConfiguration(String pid) {\n             ModelNode node = controllerClient.execute(op);\n             ModelNode outcome = node.get(ModelDescriptionConstants.OUTCOME);\n             if (ModelDescriptionConstants.SUCCESS.equals(outcome.asString())) {\n-                executor.execute(new ConfigurationModifiedService(pid, newconfig));\n+                executor.execute(new ConfigurationModifiedService(pid, newConfig));\n             } else {\n                 ROOT_LOGGER.cannotAddConfiguration(pid, node);\n             }\n         } catch (IOException ex) {\n             ROOT_LOGGER.cannotAddConfiguration(ex, pid);\n         }\n-        return oldconfig;\n+        return oldConfig;\n     }\n \n     @Override\n     public Dictionary<String, String> removeConfiguration(String pid) {\n-        Dictionary<String, String> oldconfig = getConfiguration(pid);\n-        if (oldconfig != null) {\n+        Dictionary<String, String> oldConfig = getConfiguration(pid);\n+        if (oldConfig != null) {\n             ModelNode address = getSubsystemAddress();\n             address.add(new ModelNode().set(ModelConstants.CONFIGURATION, pid));\n             ModelNode op = Util.getEmptyOperation(ModelDescriptionConstants.REMOVE, address);\n@@ -139,7 +139,7 @@ public boolean hasConfiguration(String pid) {\n                 ModelNode node = controllerClient.execute(op);\n                 ModelNode outcome = node.get(ModelDescriptionConstants.OUTCOME);\n                 if (ModelDescriptionConstants.SUCCESS.equals(outcome.asString())) {\n-                    executor.execute(new ConfigurationModifiedService(pid, oldconfig));\n+                    executor.execute(new ConfigurationModifiedService(pid, oldConfig));\n                 } else {\n                     ROOT_LOGGER.cannotRemoveConfiguration(pid, node);\n                 }\n@@ -147,7 +147,7 @@ public boolean hasConfiguration(String pid) {\n                 ROOT_LOGGER.cannotRemoveConfiguration(ex, pid);\n             }\n         }\n-        return oldconfig;\n+        return oldConfig;\n     }\n \n     @Override\n@@ -174,7 +174,7 @@ public void addListener(ConfigAdminListener listener) {\n         ROOT_LOGGER.debugf(\"Add listener: %s\", listener);\n         listeners.add(listener);\n \n-        // Call the newly registered listener with a potentially null dictionaly for every registered pid\n+        // Call the newly registered listener with a potentially null dictionary for every registered pid\n         Set<String> pids = listener.getPIDs();\n         if (pids != null) {\n             for (String pid : pids) {\n@@ -197,7 +197,7 @@ private ModelNode getSubsystemAddress() {\n     }\n \n     /**\n-     * Asynchronously update the persistet configuration and call the set of registered listeners\n+     * Asynchronously update the persistent configuration and call the set of registered listeners\n      */\n     class ConfigurationModifiedService implements Runnable {\n "},{"filename":"connector/src/main/java/org/jboss/as/connector/ConnectorLogger.java","diff":"@@ -43,7 +43,7 @@\n public interface ConnectorLogger extends BasicLogger {\n \n     /**\n-     * The root logger with a category of the default pacakge.\n+     * The root logger with a category of the default package.\n      */\n     ConnectorLogger ROOT_LOGGER = Logger.getMessageLogger(ConnectorLogger.class, ConnectorLogger.class.getPackage().getName());\n \n@@ -146,7 +146,7 @@\n     /**\n      * Logs an informational message indicating the JNDI connection factory was registered.\n      *\n-     * @param jndiName the JNDI connectory factory.\n+     * @param jndiName the JNDI connection factory.\n      */\n     @LogMessage(level = INFO)\n     @Message(id = 10406, value = \"Registered connection factory %s\")"},{"filename":"connector/src/main/java/org/jboss/as/connector/ConnectorServices.java","diff":"@@ -85,9 +85,9 @@\n      */\n     public static final ServiceName IRONJACAMAR_MDR = ServiceName.JBOSS.append(\"ironjacamar\", \"mdr\");\n \n-    public static final ServiceName RA_REPOSISTORY_SERVICE = ServiceName.JBOSS.append(\"rarepository\");\n+    public static final ServiceName RA_REPOSITORY_SERVICE = ServiceName.JBOSS.append(\"rarepository\");\n \n-    public static final ServiceName MANAGEMENT_REPOSISTORY_SERVICE = ServiceName.JBOSS.append(\"management_repository\");\n+    public static final ServiceName MANAGEMENT_REPOSITORY_SERVICE = ServiceName.JBOSS.append(\"management_repository\");\n \n     public static final ServiceName RESOURCEADAPTERS_SERVICE = ServiceName.JBOSS.append(\"resourceadapters\");\n \n@@ -272,7 +272,7 @@ public static synchronized ServiceName registerResourceAdapter(String raName) {\n         // adapter elements (with different configs) in the resource adapter subsystem, all pointing to the same ra archive.\n         // The ServiceName for the first activation of a RA with raName *will always* be of the form:\n         // RESOURCE_ADAPTER_SERVICE_PREFIX.append(raName).\n-        // Any subsequent activations for the same raname will have a numeric identifier appended to the service name\n+        // Any subsequent activations for the same raName will have a numeric identifier appended to the service name\n         // as follows:\n         // RESOURCE_ADAPTER_SERVICE_PREFIX.append(raName).append(RA_SERVICE_NAME_SEPARATOR).append(<numeric-id>)\n "},{"filename":"connector/src/main/java/org/jboss/as/connector/annotations/repository/jandex/AnnotationImpl.java","diff":"@@ -132,7 +132,7 @@ public final Object getAnnotation() {\n                        clazz = clazz.getSuperclass();\n                     }\n                 }\n-            } else { // onclass\n+            } else { // onClass\n                 Class<?> clazz = cl.loadClass(className);\n                 return clazz.getAnnotation(annotationClass);\n             }"},{"filename":"connector/src/main/java/org/jboss/as/connector/deployers/RaDeploymentActivator.java","diff":"@@ -65,13 +65,13 @@\n             .install());\n \n         RaRepositoryService raRepositoryService = new RaRepositoryService();\n-        controllers.add(serviceTarget.addService(ConnectorServices.RA_REPOSISTORY_SERVICE, raRepositoryService)\n+        controllers.add(serviceTarget.addService(ConnectorServices.RA_REPOSITORY_SERVICE, raRepositoryService)\n             .addDependency(ConnectorServices.IRONJACAMAR_MDR, MetadataRepository.class, raRepositoryService.getMdrInjector())\n             .addListener(listeners)\n             .install());\n \n         ManagementRepositoryService managementRepositoryService = new ManagementRepositoryService();\n-        controllers.add(serviceTarget.addService(ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE, managementRepositoryService)\n+        controllers.add(serviceTarget.addService(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, managementRepositoryService)\n             .addListener(listeners)\n             .install());\n "},{"filename":"connector/src/main/java/org/jboss/as/connector/deployers/processors/DsXmlDeploymentInstallProcessor.java","diff":"@@ -257,8 +257,8 @@ private void startDataSource(final AbstractDataSourceService dataSourceService,\n                 .addService(dataSourceServiceName, dataSourceService)\n                 .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                         dataSourceService.getTransactionIntegrationInjector())\n-                .addDependency(ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE, ManagementRepository.class,\n-                        dataSourceService.getmanagementRepositoryInjector())\n+                .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class,\n+                        dataSourceService.getManagementRepositoryInjector())\n                 .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                         dataSourceService.getSubjectFactoryInjector())\n                 .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class, dataSourceService.getCcmInjector())"},{"filename":"connector/src/main/java/org/jboss/as/connector/deployers/processors/ParsedRaDeploymentProcessor.java","diff":"@@ -137,20 +137,20 @@ public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitPro\n             }\n \n             final ServiceName deployerServiceName = ConnectorServices.RESOURCE_ADAPTER_DEPLOYER_SERVICE_PREFIX.append(connectorXmlDescriptor.getDeploymentName());\n-            final ResourceAdapterDeploymentService raDeployementService = new ResourceAdapterDeploymentService(connectorXmlDescriptor, cmd, ijmd, module, null);\n+            final ResourceAdapterDeploymentService raDeploymentService = new ResourceAdapterDeploymentService(connectorXmlDescriptor, cmd, ijmd, module, null);\n \n             final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n \n             // Create the service\n-            ServiceBuilder builder = serviceTarget.addService(deployerServiceName, raDeployementService)\n-                    .addDependency(ConnectorServices.IRONJACAMAR_MDR, MetadataRepository.class, raDeployementService.getMdrInjector())\n-                    .addDependency(ConnectorServices.RA_REPOSISTORY_SERVICE, ResourceAdapterRepository.class, raDeployementService.getRaRepositoryInjector())\n-                    .addDependency(ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE, ManagementRepository.class, raDeployementService.getManagementRepositoryInjector())\n-                    .addDependency(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE, ResourceAdapterDeploymentRegistry.class, raDeployementService.getRegistryInjector())\n-                    .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class, raDeployementService.getTxIntegrationInjector())\n-                    .addDependency(ConnectorServices.CONNECTOR_CONFIG_SERVICE, JcaSubsystemConfiguration.class, raDeployementService.getConfigInjector())\n-                    .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class, raDeployementService.getSubjectFactoryInjector())\n-                    .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class, raDeployementService.getCcmInjector())\n+            ServiceBuilder builder = serviceTarget.addService(deployerServiceName, raDeploymentService)\n+                    .addDependency(ConnectorServices.IRONJACAMAR_MDR, MetadataRepository.class, raDeploymentService.getMdrInjector())\n+                    .addDependency(ConnectorServices.RA_REPOSITORY_SERVICE, ResourceAdapterRepository.class, raDeploymentService.getRaRepositoryInjector())\n+                    .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class, raDeploymentService.getManagementRepositoryInjector())\n+                    .addDependency(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE, ResourceAdapterDeploymentRegistry.class, raDeploymentService.getRegistryInjector())\n+                    .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class, raDeploymentService.getTxIntegrationInjector())\n+                    .addDependency(ConnectorServices.CONNECTOR_CONFIG_SERVICE, JcaSubsystemConfiguration.class, raDeploymentService.getConfigInjector())\n+                    .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class, raDeploymentService.getSubjectFactoryInjector())\n+                    .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class, raDeploymentService.getCcmInjector())\n                     .addDependency(ConnectorServices.IDLE_REMOVER_SERVICE)\n                     .addDependency(ConnectorServices.CONNECTION_VALIDATOR_SERVICE)\n                     .addDependency(NamingService.SERVICE_NAME);"},{"filename":"connector/src/main/java/org/jboss/as/connector/mdr/MdrService.java","diff":"@@ -55,7 +55,7 @@ public MetadataRepository getValue() throws IllegalStateException {\n \n     @Override\n     public void start(StartContext context) throws StartException {\n-        MDR_LOGGER.debugf(\"Starting sevice MDR\");\n+        MDR_LOGGER.debugf(\"Starting service MDR\");\n     }\n \n     @Override"},{"filename":"connector/src/main/java/org/jboss/as/connector/metadata/deployment/AbstractResourceAdapterDeploymentService.java","diff":"@@ -435,10 +435,10 @@ protected void registerResourceAdapterToMDR(URL url, File file, Connector connec\n \n         @Override\n         protected String registerResourceAdapterToResourceAdapterRepository(ResourceAdapter instance) {\n-            final String raIdentifer = raRepository.getValue().registerResourceAdapter(instance);\n+            final String raIdentifier = raRepository.getValue().registerResourceAdapter(instance);\n             // make a note of this identifier for future use\n-            ConnectorServices.registerResourceAdapterIdentifier(this.deploymentName, raIdentifer);\n-            return raIdentifer;\n+            ConnectorServices.registerResourceAdapterIdentifier(this.deploymentName, raIdentifier);\n+            return raIdentifier;\n \n         }\n "},{"filename":"connector/src/main/java/org/jboss/as/connector/metadata/xmldescriptors/ConnectorXmlDescriptor.java","diff":"@@ -69,7 +69,7 @@ public Connector getConnector() {\n \n     /**\n      * get file root of this deployment\n-     * @return the root direcvtory\n+     * @return the root directory\n      */\n     public File getRoot() {\n         return root;"},{"filename":"connector/src/main/java/org/jboss/as/connector/pool/PoolConfigurationRWHandler.java","diff":"@@ -130,7 +130,7 @@ protected boolean applyUpdateToRuntime(final OperationContext context, final Mod\n             final String jndiName = address.getLastElement().getValue();\n \n             final ServiceController<?> managementRepoService = context.getServiceRegistry(false).getService(\n-                    ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE);\n+                    ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE);\n             List<PoolConfiguration> poolConfigs = null;\n             if (managementRepoService != null) {\n                 try {"},{"filename":"connector/src/main/java/org/jboss/as/connector/pool/PoolMetrics.java","diff":"@@ -52,7 +52,7 @@ public void execute(OperationContext context, ModelNode operation) throws Operat\n                     final String attributeName = operation.require(NAME).asString();\n \n                     final ServiceController<?> managementRepoService = context.getServiceRegistry(false).getService(\n-                            ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE);\n+                            ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE);\n                     if (managementRepoService != null) {\n                         try {\n                             final ManagementRepository repository = (ManagementRepository) managementRepoService.getValue();\n@@ -93,7 +93,7 @@ public void execute(OperationContext context, ModelNode operation) throws Operat\n                         final String attributeName = operation.require(NAME).asString();\n \n                         final ServiceController<?> managementRepoService = context.getServiceRegistry(false).getService(\n-                                ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE);\n+                                ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE);\n                         if (managementRepoService != null) {\n                             try {\n                                 final ModelNode result = context.getResult();"},{"filename":"connector/src/main/java/org/jboss/as/connector/pool/PoolOperations.java","diff":"@@ -44,7 +44,7 @@ public void execute(OperationContext context, ModelNode operation) throws Operat\n             context.addStep(new OperationStepHandler() {\n                 public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                     final ServiceController<?> managementRepoService = context.getServiceRegistry(false).getService(\n-                            ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE);\n+                            ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE);\n                     if (managementRepoService != null) {\n                         ModelNode operationResult = null;\n                         try {"},{"filename":"connector/src/main/java/org/jboss/as/connector/services/ConnectionFactoryReferenceFactoryService.java","diff":"@@ -43,7 +43,7 @@\n  *         Maestri</a>\n  */\n public class ConnectionFactoryReferenceFactoryService implements Service<ManagedReferenceFactory>, ManagedReferenceFactory {\n-    public static final ServiceName SERVICE_NAME_BASE = ServiceName.JBOSS.append(\"conection-factory\").append(\n+    public static final ServiceName SERVICE_NAME_BASE = ServiceName.JBOSS.append(\"connection-factory\").append(\n             \"reference-factory\");\n     private final InjectedValue<Object> connectionFactoryValue = new InjectedValue<Object>();\n "},{"filename":"connector/src/main/java/org/jboss/as/connector/subsystems/datasources/AbstractDataSourceAdd.java","diff":"@@ -83,8 +83,8 @@ protected void performRuntime(final OperationContext context, ModelNode operatio\n                 .addService(dataSourceServiceName, dataSourceService)\n                 .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                         dataSourceService.getTransactionIntegrationInjector())\n-                .addDependency(ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE, ManagementRepository.class,\n-                        dataSourceService.getmanagementRepositoryInjector())\n+                .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class,\n+                        dataSourceService.getManagementRepositoryInjector())\n                 .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                         dataSourceService.getSubjectFactoryInjector())\n                 .addDependency(ConnectorServices.JDBC_DRIVER_REGISTRY_SERVICE, DriverRegistry.class,"},{"filename":"connector/src/main/java/org/jboss/as/connector/subsystems/datasources/AbstractDataSourceService.java","diff":"@@ -156,7 +156,7 @@ public synchronized DataSource getValue() throws IllegalStateException, IllegalA\n         return driverValue;\n     }\n \n-    public Injector<ManagementRepository> getmanagementRepositoryInjector() {\n+    public Injector<ManagementRepository> getManagementRepositoryInjector() {\n         return managementRepositoryValue;\n     }\n "},{"filename":"connector/src/main/java/org/jboss/as/connector/subsystems/datasources/DataSourceDisable.java","diff":"@@ -111,11 +111,11 @@ public void execute(final OperationContext context, ModelNode operation) throws\n \n                         for (ServiceName name : serviceNames) {\n                             if (dataSourceConfigServiceName.append(\"connection-properties\").isParentOf(name)) {\n-                                final ServiceController<?> connProperyController = registry.getService(name);\n+                                final ServiceController<?> connPropertyController = registry.getService(name);\n \n-                                if (connProperyController != null) {\n-                                    if (ServiceController.State.UP.equals(connProperyController.getState())) {\n-                                        connProperyController.setMode(ServiceController.Mode.NEVER);\n+                                if (connPropertyController != null) {\n+                                    if (ServiceController.State.UP.equals(connPropertyController.getState())) {\n+                                        connPropertyController.setMode(ServiceController.Mode.NEVER);\n                                     } else {\n                                         throw new OperationFailedException(new ModelNode().set(MESSAGES.serviceAlreadyStarted(\"Data-source.connectionProperty\", name)));\n                                     }\n@@ -124,11 +124,11 @@ public void execute(final OperationContext context, ModelNode operation) throws\n                                 }\n                             }\n                             if (xaDataSourceConfigServiceName.append(\"xa-datasource-properties\").isParentOf(name)) {\n-                                final ServiceController<?> xaConfigProperyController = registry.getService(name);\n+                                final ServiceController<?> xaConfigPropertyController = registry.getService(name);\n \n-                                if (xaConfigProperyController != null) {\n-                                    if (ServiceController.State.UP.equals(xaConfigProperyController.getState())) {\n-                                        xaConfigProperyController.setMode(ServiceController.Mode.NEVER);\n+                                if (xaConfigPropertyController != null) {\n+                                    if (ServiceController.State.UP.equals(xaConfigPropertyController.getState())) {\n+                                        xaConfigPropertyController.setMode(ServiceController.Mode.NEVER);\n                                     } else {\n                                         throw new OperationFailedException(new ModelNode().set(MESSAGES.serviceAlreadyStarted(\"Data-source.xa-config-property\", name)));\n                                     }"},{"filename":"connector/src/main/java/org/jboss/as/connector/subsystems/datasources/DataSourceEnable.java","diff":"@@ -122,14 +122,14 @@ static void addServices(OperationContext context, ModelNode operation, ServiceVe\n             int propertiesCount = 0;\n             for (ServiceName name : serviceNames) {\n                 if (xaDataSourceConfigServiceName.append(\"xa-datasource-properties\").isParentOf(name)) {\n-                    final ServiceController<?> xaConfigProperyController = registry.getService(name);\n-                    XaDataSourcePropertiesService xaPropService = (XaDataSourcePropertiesService) xaConfigProperyController.getService();\n+                    final ServiceController<?> xaConfigPropertyController = registry.getService(name);\n+                    XaDataSourcePropertiesService xaPropService = (XaDataSourcePropertiesService) xaConfigPropertyController.getService();\n \n-                    if (xaConfigProperyController != null) {\n+                    if (xaConfigPropertyController != null) {\n \n-                        if (!ServiceController.State.UP.equals(xaConfigProperyController.getState())) {\n+                        if (!ServiceController.State.UP.equals(xaConfigPropertyController.getState())) {\n                             propertiesCount++;\n-                            xaConfigProperyController.setMode(ServiceController.Mode.ACTIVE);\n+                            xaConfigPropertyController.setMode(ServiceController.Mode.ACTIVE);\n                             builder.addDependency(name, String.class, xaDataSourceConfigService.getXaDataSourcePropertyInjector(xaPropService.getName()));\n \n                         } else {"},{"filename":"connector/src/main/java/org/jboss/as/connector/subsystems/datasources/DataSourceModelNodeUtil.java","diff":"@@ -165,9 +165,9 @@ static ModifiableDataSource from(final OperationContext operationContext, final\n         final Long queryTimeout = getLongIfSetOrGetDefault(operationContext, dataSourceNode, QUERYTIMEOUT, null);\n         final Integer xaResourceTimeout = getIntIfSetOrGetDefault(operationContext, dataSourceNode, XA_RESOURCE_TIMEOUT, null);\n         final Long useTryLock = getLongIfSetOrGetDefault(operationContext, dataSourceNode, USETRYLOCK, null);\n-        final boolean setTxQuertTimeout = getBooleanIfSetOrGetDefault(operationContext, dataSourceNode, SETTXQUERYTIMEOUT, Defaults.SET_TX_QUERY_TIMEOUT);\n+        final boolean setTxQueryTimeout = getBooleanIfSetOrGetDefault(operationContext, dataSourceNode, SETTXQUERYTIMEOUT, Defaults.SET_TX_QUERY_TIMEOUT);\n         final TimeOut timeOut = new TimeOutImpl(blockingTimeoutMillis, idleTimeoutMinutes, allocationRetry,\n-                allocationRetryWaitMillis, xaResourceTimeout, setTxQuertTimeout, queryTimeout, useTryLock);\n+                allocationRetryWaitMillis, xaResourceTimeout, setTxQueryTimeout, queryTimeout, useTryLock);\n         final TransactionIsolation transactionIsolation = dataSourceNode.hasDefined(TRANSACTION_ISOLATION.getName()) ? TransactionIsolation\n                 .valueOf(dataSourceNode.get(TRANSACTION_ISOLATION.getName()).asString()) : null;\n         final String checkValidConnectionSql = getResolvedStringIfSetOrGetDefault(operationContext, dataSourceNode, CHECKVALIDCONNECTIONSQL, null);\n@@ -244,9 +244,9 @@ static ModifiableXaDataSource xaFrom(final OperationContext operationContext, fi\n         final Long queryTimeout = getLongIfSetOrGetDefault(operationContext, dataSourceNode, QUERYTIMEOUT, null);\n         final Integer xaResourceTimeout = getIntIfSetOrGetDefault(operationContext, dataSourceNode, XA_RESOURCE_TIMEOUT, null);\n         final Long useTryLock = getLongIfSetOrGetDefault(operationContext, dataSourceNode, USETRYLOCK, null);\n-        final Boolean setTxQuertTimeout = getBooleanIfSetOrGetDefault(operationContext, dataSourceNode, SETTXQUERYTIMEOUT, Defaults.SET_TX_QUERY_TIMEOUT);\n+        final Boolean setTxQueryTimeout = getBooleanIfSetOrGetDefault(operationContext, dataSourceNode, SETTXQUERYTIMEOUT, Defaults.SET_TX_QUERY_TIMEOUT);\n         final TimeOut timeOut = new TimeOutImpl(blockingTimeoutMillis, idleTimeoutMinutes, allocationRetry,\n-                allocationRetryWaitMillis, xaResourceTimeout, setTxQuertTimeout, queryTimeout, useTryLock);\n+                allocationRetryWaitMillis, xaResourceTimeout, setTxQueryTimeout, queryTimeout, useTryLock);\n         final TransactionIsolation transactionIsolation = dataSourceNode.hasDefined(TRANSACTION_ISOLATION.getName()) ? TransactionIsolation\n                 .valueOf(dataSourceNode.get(TRANSACTION_ISOLATION.getName()).asString()) : null;\n         final String checkValidConnectionSql = getResolvedStringIfSetOrGetDefault(operationContext, dataSourceNode, CHECKVALIDCONNECTIONSQL, null);"},{"filename":"connector/src/main/java/org/jboss/as/connector/subsystems/datasources/DataSourcesExtension.java","diff":"@@ -832,10 +832,10 @@ public void execute(OperationContext context, ModelNode operation) throws Operat\n \n                     if (dataSource.hasDefined(CONNECTION_PROPERTIES.getName())) {\n                         for (final Property prop : dataSource.get(CONNECTION_PROPERTIES.getName()).asPropertyList()) {\n-                            final ModelNode propAdrress = address.clone();\n+                            final ModelNode propAddress = address.clone();\n \n-                            propAdrress.add(CONNECTION_PROPERTIES.getName(), prop.getName());\n-                            final ModelNode addPropOperation = Util.getEmptyOperation(ADD, propAdrress);\n+                            propAddress.add(CONNECTION_PROPERTIES.getName(), prop.getName());\n+                            final ModelNode addPropOperation = Util.getEmptyOperation(ADD, propAddress);\n                             addPropOperation.get(\"value\").set(prop.getValue().get(VALUE).asString());\n                             result.add(addPropOperation);\n                         }\n@@ -866,10 +866,10 @@ public void execute(OperationContext context, ModelNode operation) throws Operat\n \n                     if (dataSource.hasDefined(XADATASOURCE_PROPERTIES.getName())) {\n                         for (final Property prop : dataSource.get(XADATASOURCE_PROPERTIES.getName()).asPropertyList()) {\n-                            final ModelNode propAdrress = address.clone();\n+                            final ModelNode propAddress = address.clone();\n \n-                            propAdrress.add(XADATASOURCE_PROPERTIES.getName(), prop.getName());\n-                            final ModelNode addPropOperation = Util.getEmptyOperation(ADD, propAdrress);\n+                            propAddress.add(XADATASOURCE_PROPERTIES.getName(), prop.getName());\n+                            final ModelNode addPropOperation = Util.getEmptyOperation(ADD, propAddress);\n                             addPropOperation.get(\"value\").set(prop.getValue().get(VALUE).asString());\n                             result.add(addPropOperation);\n                         }"},{"filename":"connector/src/main/java/org/jboss/as/connector/subsystems/datasources/DisableRequiredWriteAttributeHandler.java","diff":"@@ -55,7 +55,7 @@ protected boolean applyUpdateToRuntime(OperationContext context, ModelNode opera\n                 Constants.JNDINAME.getName().equals(attributeName)) {\n            return true;\n         } else {\n-            //do thejob\n+            //do the job\n             return false;\n         }\n     }"},{"filename":"connector/src/main/java/org/jboss/as/connector/subsystems/jca/JcaExtension.java","diff":"@@ -609,11 +609,11 @@ private ModelNode parseBootstrapContexts(final XMLExtendedStreamReader reader, f\n                             }\n                         }\n \n-                        final ModelNode bootStrapCOntextAddress = parentAddress.clone();\n-                        bootStrapCOntextAddress.add(BOOTSTRAP_CONTEXT, name);\n-                        bootStrapCOntextAddress.protect();\n+                        final ModelNode bootstrapContextAddress = parentAddress.clone();\n+                        bootstrapContextAddress.add(BOOTSTRAP_CONTEXT, name);\n+                        bootstrapContextAddress.protect();\n \n-                        bootstrapContextOperation.get(OP_ADDR).set(bootStrapCOntextAddress);\n+                        bootstrapContextOperation.get(OP_ADDR).set(bootstrapContextAddress);\n \n                         // Handle elements\n                         requireNoContent(reader);\n@@ -629,9 +629,9 @@ private ModelNode parseBootstrapContexts(final XMLExtendedStreamReader reader, f\n         }\n \n         public String rawElementText(XMLStreamReader reader) throws XMLStreamException {\n-            String elementtext = reader.getElementText();\n-            elementtext = elementtext == null || elementtext.trim().length() == 0 ? null : elementtext.trim();\n-            return elementtext;\n+            String elementText = reader.getElementText();\n+            elementText = elementText == null || elementText.trim().length() == 0 ? null : elementText.trim();\n+            return elementText;\n         }\n \n         public String rawAttributeText(XMLStreamReader reader, String attributeName) {"},{"filename":"connector/src/main/java/org/jboss/as/connector/subsystems/resourceadapters/RaOperationUtil.java","diff":"@@ -107,8 +107,8 @@ public static ModifiableResourceAdapter buildResourceAdaptersObject(final Operat\n         List<String> beanValidationGroups = null;\n         if (operation.hasDefined(BEANVALIDATIONGROUPS.getName())) {\n             beanValidationGroups = new ArrayList<String>(operation.get(BEANVALIDATIONGROUPS.getName()).asList().size());\n-            for (ModelNode beanValidtion : operation.get(BEANVALIDATIONGROUPS.getName()).asList()) {\n-                beanValidationGroups.add(beanValidtion.asString());\n+            for (ModelNode beanValidation : operation.get(BEANVALIDATIONGROUPS.getName()).asList()) {\n+                beanValidationGroups.add(beanValidation.asString());\n             }\n \n         }\n@@ -202,10 +202,10 @@ public static ModifiableAdminObject buildAdminObjects(final OperationContext ope\n                 boolean enabled = getBooleanIfSetOrGetDefault(operationContext, operation, ENABLED, Defaults.ENABLED);\n                 boolean useJavaContext = getBooleanIfSetOrGetDefault(operationContext, operation, USE_JAVA_CONTEXT, Defaults.USE_JAVA_CONTEXT);\n \n-                ModifiableAdminObject adminObjet = new ModifiableAdminObject(configProperties, className, jndiName, poolName,\n+                ModifiableAdminObject adminObject = new ModifiableAdminObject(configProperties, className, jndiName, poolName,\n                         enabled, useJavaContext);\n \n-                return adminObjet;\n+                return adminObject;\n     }\n \n     private static Long getLongIfSetOrGetDefault(final OperationContext context, final ModelNode dataSourceNode, final SimpleAttributeDefinition key, final Long defaultValue) throws OperationFailedException {"},{"filename":"connector/src/main/java/org/jboss/as/connector/util/AbstractParser.java","diff":"@@ -65,13 +65,13 @@\n      * FIXME Comment this\n      *\n      * @param reader\n-     * @return the string representing the raw eleemnt text\n+     * @return the string representing the raw element text\n      * @throws XMLStreamException\n      */\n     public String rawElementText(XMLStreamReader reader) throws XMLStreamException {\n-        String elementtext = reader.getElementText();\n-        elementtext = elementtext == null || elementtext.trim().length() == 0 ? null : elementtext.trim();\n-        return elementtext;\n+        String elementText = reader.getElementText();\n+        elementText = elementText == null || elementText.trim().length() == 0 ? null : elementText.trim();\n+        return elementText;\n     }\n \n     /**\n@@ -79,7 +79,7 @@ public String rawElementText(XMLStreamReader reader) throws XMLStreamException {\n      *\n      * @param reader\n      * @param attributeName\n-     * @return the string representing raw attribute textx\n+     * @return the string representing raw attribute text\n      */\n     public String rawAttributeText(XMLStreamReader reader, String attributeName) {\n         String attributeString = reader.getAttributeValue(\"\", attributeName) == null ? null : reader.getAttributeValue(\n@@ -90,7 +90,7 @@ public String rawAttributeText(XMLStreamReader reader, String attributeName) {\n \n \n     protected void parseExtension(XMLExtendedStreamReader reader, String enclosingTag, final ModelNode operation,\n-                                  final SimpleAttributeDefinition extensionclassname, final SimpleAttributeDefinition extensionProperties)\n+                                  final SimpleAttributeDefinition extensionClassName, final SimpleAttributeDefinition extensionProperties)\n             throws XMLStreamException, ParserException, ValidateException {\n \n         String className = null;\n@@ -101,7 +101,7 @@ protected void parseExtension(XMLExtendedStreamReader reader, String enclosingTa\n                 case CLASS_NAME: {\n                     requireSingleAttribute(reader, attribute.getLocalName());\n                     final String value = reader.getAttributeValue(0);\n-                    extensionclassname.parseAndSetParameter(value, operation, reader);\n+                    extensionClassName.parseAndSetParameter(value, operation, reader);\n                     break;\n \n                 }"},{"filename":"connector/src/main/java/org/jboss/as/connector/util/Injection.java","diff":"@@ -40,7 +40,7 @@ public Injection() {\n \n     /**\n      * Inject a value into an object property\n-     * @param propertyType The property type as a fully quilified class name\n+     * @param propertyType The property type as a fully qualified class name\n      * @param propertyName The property name\n      * @param propertyValue The property value\n      * @param object The object\n@@ -81,43 +81,43 @@ public void inject(String propertyType, String propertyName, String propertyValu\n         Class parameterClass = null;\n         Object parameterValue = null;\n \n-        String substituredValue = getSubstitutionValue(propertyValue);\n+        String substitutedValue = getSubstitutionValue(propertyValue);\n \n         if (propertyType.equals(\"java.lang.String\")) {\n             parameterClass = String.class;\n-            parameterValue = substituredValue;\n+            parameterValue = substitutedValue;\n         } else if (propertyType.equals(\"byte\") || propertyType.equals(\"java.lang.Byte\")) {\n             parameterClass = Byte.class;\n-            if (substituredValue != null && !substituredValue.trim().equals(\"\"))\n-                parameterValue = Byte.valueOf(substituredValue);\n+            if (substitutedValue != null && !substitutedValue.trim().equals(\"\"))\n+                parameterValue = Byte.valueOf(substitutedValue);\n         } else if (propertyType.equals(\"short\") || propertyType.equals(\"java.lang.Short\")) {\n             parameterClass = Short.class;\n-            if (substituredValue != null && !substituredValue.trim().equals(\"\"))\n-                parameterValue = Short.valueOf(substituredValue);\n+            if (substitutedValue != null && !substitutedValue.trim().equals(\"\"))\n+                parameterValue = Short.valueOf(substitutedValue);\n         } else if (propertyType.equals(\"int\") || propertyType.equals(\"java.lang.Integer\")) {\n             parameterClass = Integer.class;\n-            if (substituredValue != null && !substituredValue.trim().equals(\"\"))\n-                parameterValue = Integer.valueOf(substituredValue);\n+            if (substitutedValue != null && !substitutedValue.trim().equals(\"\"))\n+                parameterValue = Integer.valueOf(substitutedValue);\n         } else if (propertyType.equals(\"long\") || propertyType.equals(\"java.lang.Long\")) {\n             parameterClass = Long.class;\n-            if (substituredValue != null && !substituredValue.trim().equals(\"\"))\n-                parameterValue = Long.valueOf(substituredValue);\n+            if (substitutedValue != null && !substitutedValue.trim().equals(\"\"))\n+                parameterValue = Long.valueOf(substitutedValue);\n         } else if (propertyType.equals(\"float\") || propertyType.equals(\"java.lang.Float\")) {\n             parameterClass = Float.class;\n-            if (substituredValue != null && !substituredValue.trim().equals(\"\"))\n-                parameterValue = Float.valueOf(substituredValue);\n+            if (substitutedValue != null && !substitutedValue.trim().equals(\"\"))\n+                parameterValue = Float.valueOf(substitutedValue);\n         } else if (propertyType.equals(\"double\") || propertyType.equals(\"java.lang.Double\")) {\n             parameterClass = Double.class;\n-            if (substituredValue != null && !substituredValue.trim().equals(\"\"))\n-                parameterValue = Double.valueOf(substituredValue);\n+            if (substitutedValue != null && !substitutedValue.trim().equals(\"\"))\n+                parameterValue = Double.valueOf(substitutedValue);\n         } else if (propertyType.equals(\"boolean\") || propertyType.equals(\"java.lang.Boolean\")) {\n             parameterClass = Boolean.class;\n-            if (substituredValue != null && !substituredValue.trim().equals(\"\"))\n-                parameterValue = Boolean.valueOf(substituredValue);\n+            if (substitutedValue != null && !substitutedValue.trim().equals(\"\"))\n+                parameterValue = Boolean.valueOf(substitutedValue);\n         } else if (propertyType.equals(\"char\") || propertyType.equals(\"java.lang.Character\")) {\n             parameterClass = Character.class;\n-            if (substituredValue != null && !substituredValue.trim().equals(\"\"))\n-                parameterValue = Character.valueOf(substituredValue.charAt(0));\n+            if (substitutedValue != null && !substitutedValue.trim().equals(\"\"))\n+                parameterValue = Character.valueOf(substitutedValue.charAt(0));\n         } else {\n             throw MESSAGES.unknownPropertyType(propertyType, propertyName);\n         }"},{"filename":"connector/src/main/java/org/jboss/as/connector/util/RaServicesFactory.java","diff":"@@ -50,9 +50,9 @@ public static void createDeploymentService(final ManagementResourceRegistration\n         ServiceBuilder builder = serviceTarget\n                 .addService(serviceName, service)\n                 .addDependency(ConnectorServices.IRONJACAMAR_MDR, MetadataRepository.class, service.getMdrInjector())\n-                .addDependency(ConnectorServices.RA_REPOSISTORY_SERVICE, ResourceAdapterRepository.class,\n+                .addDependency(ConnectorServices.RA_REPOSITORY_SERVICE, ResourceAdapterRepository.class,\n                         service.getRaRepositoryInjector())\n-                .addDependency(ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE, ManagementRepository.class,\n+                .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class,\n                         service.getManagementRepositoryInjector())\n                 .addDependency(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE,\n                         ResourceAdapterDeploymentRegistry.class, service.getRegistryInjector())"},{"filename":"connector/src/main/resources/org/jboss/as/connector/subsystems/datasources/LocalDescriptions.properties","diff":"@@ -41,8 +41,8 @@ connection-properties.value=Each connection-property specifies a string name/val\n connection-properties=The connection-properties element allows you to pass in arbitrary connection properties to the Driver.connect(url, props) method\n connection-url=The JDBC driver connection URL\n \n-datasource-class=The fully qualifed name of the JDBC datasource class\n-driver-class=The fully qualifed name of the JDBC driver class\n+datasource-class=The fully qualified name of the JDBC datasource class\n+driver-class=The fully qualified name of the JDBC driver class\n driver-name=Defines the JDBC driver the datasource should use. It is a symbolic name matching the the name of installed driver. In case the driver is deployed as jar, the name is the name of deployment unit\n driver=Defines the JDBC driver the datasource should use. It is a symbolic name matching the the name of installed driver. In case the driver is deployed as jar, the name is the name of deployment unit\n \n@@ -84,7 +84,7 @@ stale-connection-checker-properties=The stale connection checker properties\n track-statements=Whether to check for unclosed statements when a connection is returned to the pool, result sets are closed, a statement is closed or return to the prepared statement cache. Valid values are: \"false\" - do not track statements, \"true\" - track statements and result sets and warn when they are not closed, \"nowarn\" - track statements but do not warn about them being unclosed\n transaction-isolation=Set the java.sql.Connection transaction isolation level. Valid values are: TRANSACTION_READ_UNCOMMITTED, TRANSACTION_READ_COMMITTED, TRANSACTION_REPEATABLE_READ, TRANSACTION_SERIALIZABLE and TRANSACTION_NONE\n \n-url-delimiter=Specifies the delimeter for URLs in connection-url for HA datasources\n+url-delimiter=Specifies the delimiter for URLs in connection-url for HA datasources\n url-selector-strategy-class-name=A class that implements org.jboss.jca.adapters.jdbc.URLSelectorStrategy\n use-fast-fail=Whether to fail a connection allocation on the first try if it is invalid (true) or keep trying until the pool is exhausted of all potential connections (false)\n use-java-context=Setting this to false will bind the datasource into global JNDI\n@@ -97,7 +97,7 @@ validate-on-match=The validate-on-match element specifies if connection validati\n \n wrap-xa-resource=Should the XAResource instances be wrapped in a org.jboss.tm.XAResourceWrapper instance\n \n-xa-datasource-class=The fully qualifed name of the javax.sql.XADataSource implementation\n+xa-datasource-class=The fully qualified name of the javax.sql.XADataSource implementation\n xa-datasource-properties.add=Add a single xa-datasource-property\n xa-datasource-properties.remove=Remove the xa-datasource-property\n xa-datasource-properties.value=Specifies a property value to assign to the XADataSource implementation class. Each property is identified by the name attribute and the property value is given by the xa-datasource-property element content. The property is mapped onto the XADataSource implementation by looking for a JavaBeans style getter method for the property name. If found, the value of the property is set using the JavaBeans setter with the element text translated to the true property type using the java.beans.PropertyEditor"},{"filename":"controller-client/src/main/java/org/jboss/as/controller/client/helpers/domain/DomainClient.java","diff":"@@ -92,11 +92,11 @@\n      * @param gracefulShutdownTimeout maximum period to wait to allow the server\n      *           to gracefully handle long running tasks before shutting down,\n      *           or {@code -1} to shutdown immediately\n-     * @param timeunit time unit in which {@code gracefulShutdownTimeout} is expressed\n+     * @param timeUnit time unit in which {@code gracefulShutdownTimeout} is expressed\n      *\n      * @return the status of the server following the stop. Will not be <code>null</code>\n      */\n-    ServerStatus stopServer(String hostControllerName, String serverName, long gracefulShutdownTimeout, TimeUnit timeunit);\n+    ServerStatus stopServer(String hostControllerName, String serverName, long gracefulShutdownTimeout, TimeUnit timeUnit);\n \n     /**\n      * Restarts the given server.\n@@ -106,11 +106,11 @@\n      * @param gracefulShutdownTimeout maximum period to wait to allow the server\n      *           to gracefully handle long running tasks before shutting down,\n      *           or {@code -1} to shutdown immediately\n-     * @param timeunit time unit in which {@code gracefulShutdownTimeout} is expressed\n+     * @param timeUnit time unit in which {@code gracefulShutdownTimeout} is expressed\n      *\n      * @return the status of the server following the restart. Will not be <code>null</code>\n      */\n-    ServerStatus restartServer(String hostControllerName, String serverName, long gracefulShutdownTimeout, TimeUnit timeunit);\n+    ServerStatus restartServer(String hostControllerName, String serverName, long gracefulShutdownTimeout, TimeUnit timeUnit);\n \n     /**\n      * Factory used to create an {@link org.jboss.as.controller.client.helpers.domain.DomainClient} instance for a remote address"},{"filename":"controller-client/src/main/java/org/jboss/as/controller/client/helpers/domain/package-info.java","diff":"@@ -22,7 +22,7 @@\n \n /**\n  * Convenience API built on top of the {@link org.jboss.as.controller.client.ModelControllerClient core management API}\n- * to make it easier to perform common managment tasks against a JBoss Application Server Managed Domain.\n+ * to make it easier to perform common management tasks against a JBoss Application Server Managed Domain.\n  *\n  * @see DomainClient\n  */"},{"filename":"controller-client/src/main/java/org/jboss/as/controller/client/helpers/standalone/package-info.java","diff":"@@ -22,7 +22,7 @@\n \n /**\n  * Convenience API built on top of the {@link org.jboss.as.controller.client.ModelControllerClient core management API}\n- * to make it easier to perform common managment tasks against a single standalone JBoss Application Server instance.\n+ * to make it easier to perform common management tasks against a single standalone JBoss Application Server instance.\n  *\n  * @see org.jboss.as.controller.client.helpers.standalone.ServerDeploymentManager\n  */"},{"filename":"controller/src/main/java/org/jboss/as/controller/AbstractOperationContext.java","diff":"@@ -300,7 +300,7 @@ private void doCompleteStep() {\n             }\n         } while (currentStage != Stage.DONE);\n \n-        // All steps are completed withuout triggering rollback; time for final processing\n+        // All steps are completed without triggering rollback; time for final processing\n \n         // Prepare persistence of any configuration changes\n         ConfigurationPersister.PersistenceResource persistenceResource = null;"},{"filename":"controller/src/main/java/org/jboss/as/controller/ControllerLogger.java","diff":"@@ -69,7 +69,7 @@\n      * Logs a warning message indicating the address, represented by the {@code address} parameter, could not be\n      * resolved, so cannot match it to any InetAddress.\n      *\n-     * @param address the address that could not be resoloved.\n+     * @param address the address that could not be resolved.\n      */\n     @LogMessage(level = WARN)\n     @Message(id = 14600, value = \"Cannot resolve address %s, so cannot match it to any InetAddress\")"},{"filename":"controller/src/main/java/org/jboss/as/controller/ControllerMessages.java","diff":"@@ -2229,7 +2229,7 @@\n      * @param type the required type\n      * @param operation the operation as a string. May be empty\n      */\n-    @Message(id = 14824, value = \"Could not convert the paramter '%s' to a %s. %s\")\n+    @Message(id = 14824, value = \"Could not convert the parameter '%s' to a %s. %s\")\n     IllegalArgumentException validationFailedCouldNotConvertParamToType(String paramName, ModelType type, String operation);\n \n     /**\n@@ -2345,7 +2345,7 @@\n \n     /**\n      * Creates a string for use in an IllegalArgumentException or a warning message indicating that\n-     * a parameter has a min-length or max-lenght attribute value that is not an integer.\n+     * a parameter has a min-length or max-length attribute value that is not an integer.\n      *\n      * @param minOrMaxLength {@code min} or {@code max}\n      * @param paramName the name of the parameter"},{"filename":"controller/src/main/java/org/jboss/as/controller/OperationContext.java","diff":"@@ -494,7 +494,7 @@\n     /**\n      * Marks a resource to indicate that it's backing service(s) will be restarted.\n      * This is to ensure that a restart only occurs once, even if there are multiple updates.\n-     * When true is returned the caller has \"aquired\" the mark and should proceed with the\n+     * When true is returned the caller has \"acquired\" the mark and should proceed with the\n      * restart, when false, the caller should take no additional action.\n      *\n      * The passed owner is compared by instance when a call to {@link #revertReloadRequired()}."},{"filename":"controller/src/main/java/org/jboss/as/controller/ProxyController.java","diff":"@@ -46,7 +46,7 @@\n     /**\n      * Get the address where this proxy controller applies to in the host ModelController\n      *\n-     * @return the address where this proxy contoller applies.\n+     * @return the address where this proxy controller applies.\n      */\n     PathAddress getProxyNodeAddress();\n "},{"filename":"controller/src/main/java/org/jboss/as/controller/extension/ExtensionSubsystemResourceDefinition.java","diff":"@@ -50,7 +50,7 @@\n import org.jboss.dmr.ModelType;\n \n /**\n- * {@link ResourceDefinition} for an {@link Extension}'s subsytem child resources.\n+ * {@link ResourceDefinition} for an {@link Extension}'s subsystem child resources.\n  *\n  * @author Brian Stansberry (c) 2011 Red Hat Inc.\n  */"},{"filename":"controller/src/main/java/org/jboss/as/controller/operations/global/WriteAttributeHandlers.java","diff":"@@ -188,17 +188,17 @@ public InetAddressValidatingHandler(final boolean nullable, final boolean allowE\n         }\n     }\n \n-    public static class ListValidatatingHandler extends WriteAttributeOperationHandler {\n+    public static class ListValidatingHandler extends WriteAttributeOperationHandler {\n \n-        public ListValidatatingHandler(ParameterValidator elementValidator) {\n+        public ListValidatingHandler(ParameterValidator elementValidator) {\n             this(elementValidator, false, 1, Integer.MAX_VALUE);\n         }\n \n-        public ListValidatatingHandler(ParameterValidator elementValidator, boolean nullable) {\n+        public ListValidatingHandler(ParameterValidator elementValidator, boolean nullable) {\n             this(elementValidator, nullable, 1, Integer.MAX_VALUE);\n         }\n \n-        public ListValidatatingHandler(ParameterValidator elementValidator, boolean nullable, int minSize, int maxSize) {\n+        public ListValidatingHandler(ParameterValidator elementValidator, boolean nullable, int minSize, int maxSize) {\n             super(new ListValidator(elementValidator, nullable, minSize, maxSize));\n         }\n     }"},{"filename":"controller/src/main/java/org/jboss/as/controller/operations/validation/MinMaxValidator.java","diff":"@@ -32,14 +32,14 @@\n     /**\n      * Gets the minimum, if there is one.\n      *\n-     * @return the minimum value, or {@code null} if there is no mimimum\n+     * @return the minimum value, or {@code null} if there is no minimum\n      */\n     Long getMin();\n \n     /**\n      * Gets the maximum, if there is one.\n      *\n-     * @return the maximum value, or {@code null} if there is no mimimum\n+     * @return the maximum value, or {@code null} if there is no minimum\n      */\n     Long getMax();\n }"},{"filename":"controller/src/main/java/org/jboss/as/controller/operations/validation/OperationValidator.java","diff":"@@ -51,7 +51,7 @@\n import org.jboss.dmr.ModelType;\n \n /**\n- * Validates operations against the model controllers descripton providers\n+ * Validates operations against the model controllers description providers\n  *\n  * @author <a href=\"kabir.khan@jboss.com\">Kabir Khan</a>\n  */"},{"filename":"controller/src/main/java/org/jboss/as/controller/parsing/CommonXml.java","diff":"@@ -213,14 +213,14 @@ protected void writeSchemaLocation(final XMLExtendedStreamWriter writer, final M\n \n     protected void writeNamespaces(final XMLExtendedStreamWriter writer, final ModelNode modelNode) throws XMLStreamException {\n         final boolean needXsd = modelNode.hasDefined(SCHEMA_LOCATIONS) && modelNode.get(SCHEMA_LOCATIONS).asInt() > 0;\n-        final boolean hasNamepaces = modelNode.hasDefined(NAMESPACES);\n-        if (!needXsd && !hasNamepaces) {\n+        final boolean hasNamespaces = modelNode.hasDefined(NAMESPACES);\n+        if (!needXsd && !hasNamespaces) {\n             return;\n         }\n \n         boolean wroteXsd = false;\n         final String xsdUri = Namespace.XML_SCHEMA_INSTANCE.getUriString();\n-        if (hasNamepaces) {\n+        if (hasNamespaces) {\n             for (final Property property : modelNode.get(NAMESPACES).asPropertyList()) {\n                 final String uri = property.getValue().asString();\n                 writer.writeNamespace(property.getName(), uri);"},{"filename":"controller/src/main/java/org/jboss/as/controller/parsing/ExtensionParsingContext.java","diff":"@@ -43,7 +43,7 @@\n      * \"subsystem add\" update, without the address or operation name as that information will be automatically\n      * populated.\n      *\n-     * @param namespaceUri the URI of the susbsystem's XML namespace, in string form. Cannot be {@code null}\n+     * @param namespaceUri the URI of the subsystem's XML namespace, in string form. Cannot be {@code null}\n      * @param reader the element reader. Cannot be {@code null}\n      *\n      * @deprecated use {@link #setSubsystemXmlMapping(String, String, XMLElementReader)}\n@@ -58,7 +58,7 @@\n      * populated.\n      *\n      * @param subsystemName the name of the subsystem. Cannot be {@code null}\n-     * @param namespaceUri the URI of the susbsystem's XML namespace, in string form. Cannot be {@code null}\n+     * @param namespaceUri the URI of the sussystem's XML namespace, in string form. Cannot be {@code null}\n      * @param reader the element reader. Cannot be {@code null}\n      *\n      * @throws IllegalStateException if another {@link Extension} has already registered a subsystem with the given\n@@ -69,7 +69,7 @@\n     /**\n      * Set the parser for the per-deployment configuration for this element, if any.\n      *\n-     * @param namespaceUri the URI of the susbsystem's XML namespace, in string form. Cannot be {@code null}\n+     * @param namespaceUri the URI of the subsystem's XML namespace, in string form. Cannot be {@code null}\n      * @param reader the element reader. Cannot be {@code null}\n      *\n      * @throws IllegalStateException if another {@link Extension} has already registered a subsystem with the given\n@@ -89,7 +89,7 @@\n      * (TODO: round this out or remove it.)\n      *\n      * @param subsystemName the name of the subsystem. Cannot be {@code null}\n-     * @param namespaceUri the URI of the susbsystem's XML namespace, in string form. Cannot be {@code null}\n+     * @param namespaceUri the URI of the subsystem's XML namespace, in string form. Cannot be {@code null}\n      * @param reader the element reader. Cannot be {@code null}\n      *\n      * @throws IllegalStateException if another {@link Extension} has already registered a subsystem with the given"},{"filename":"controller/src/main/java/org/jboss/as/controller/persistence/ConfigurationFile.java","diff":"@@ -191,7 +191,7 @@ public boolean accept(File dir, String name) {\n      * returns its name with the prefix removed.\n      *\n      * @param prefix the prefix\n-     * @return the single file that meets the criteriaor {@code null} if none do\n+     * @return the single file that meets the criterion {@code null} if none do\n      * @throws IllegalStateException if more than one file meets the criteria\n      */\n     private String findMainFileFromSnapshotPrefix(final String prefix) {"},{"filename":"controller/src/main/java/org/jboss/as/controller/persistence/ModelMarshallingContext.java","diff":"@@ -38,7 +38,7 @@\n      * Gets the writer that can marshal the subsystem with the given name.\n      *\n      * @param subsystemName the name of the subsystem\n-     * @return the writer, or {@code null} if there is no writer regisered\n+     * @return the writer, or {@code null} if there is no writer registered\n      *          under {@code subsystemName}\n      */\n     XMLElementWriter<SubsystemMarshallingContext> getSubsystemWriter(String subsystemName);\n@@ -48,7 +48,7 @@\n      * subsystem with the given name.\n      *\n      * @param subsystemName the name of the subsystem\n-     * @return the writer, or {@code null} if there is no writer regisered\n+     * @return the writer, or {@code null} if there is no writer registered\n      *          under {@code subsystemName}\n      */\n     XMLElementWriter<SubsystemMarshallingContext> getSubsystemDeploymentWriter(String subsystemName);"},{"filename":"controller/src/main/java/org/jboss/as/controller/remote/ExistingChannelModelControllerClient.java","diff":"@@ -57,7 +57,7 @@ public void close() throws IOException {\n     /**\n      * Create and add model controller handler to a existing management channel handler.\n      *\n-     * @param handler the channle hanlder\n+     * @param handler the channel handler\n      * @return the created client\n      */\n     public static ModelControllerClient createAndAdd(final ManagementChannelHandler handler) {"},{"filename":"demos/legacy/src/main/java/org/jboss/as/demos/managedbean/archive/BeanWithSimpleInjected.java","diff":"@@ -61,7 +61,7 @@ public void initMethod(CDIManagedBean bean) {\n     @PostConstruct\n     public void start() {\n         if(bean2 == null) {\n-            throw new RuntimeException(\"PostContruct called before @Inject method\");\n+            throw new RuntimeException(\"PostConstruct called before @Inject method\");\n         }\n \n         log.info(\"-----> Constructed BeanWithSimpleInjected, simple=\" + simple);"},{"filename":"demos/legacy/src/main/java/org/jboss/as/demos/rar/archive/HelloWorldManagedConnection.java","diff":"@@ -86,7 +86,7 @@ public Object getConnection(Subject subject,\n \n    /**\n     * Used by the container to change the association of an\n-    * application-level connection handle with a ManagedConneciton instance.\n+    * application-level connection handle with a ManagedConnection instance.\n     *\n     * @param   connection  Application-level connection handle\n     * @throws  ResourceException     generic exception if operation fails\n@@ -139,7 +139,7 @@ public void removeConnectionEventListener(ConnectionEventListener listener) {\n    /**\n     * Gets the log writer for this ManagedConnection instance.\n     *\n-    * @return  Character ourput stream associated with this Managed-Connection instance\n+    * @return  Character output stream associated with this Managed-Connection instance\n     * @throws ResourceException     generic exception if operation fails\n     */\n    public PrintWriter getLogWriter() throws ResourceException {\n@@ -167,7 +167,7 @@ public LocalTransaction getLocalTransaction() throws ResourceException {\n    }\n \n    /**\n-    * Returns an <code>javax.transaction.xa.XAresource</code> instance.\n+    * Returns an <code>javax.transaction.xa.XAResource</code> instance.\n     *\n     * @return     XAResource instance\n     * @throws ResourceException     generic exception if operation fails"},{"filename":"demos/pom.xml","diff":"@@ -114,7 +114,7 @@\n         </profile>\n         <!--\n             Name: jpda\n-            Descr: Enable JPDA remote debuging\n+            Descr: Enable JPDA remote debugging\n         -->\n         <profile>\n           <id>jpda</id>"},{"filename":"deployment-repository/src/main/java/org/jboss/as/repository/DeploymentRepositoryLogger.java","diff":"@@ -39,7 +39,7 @@\n interface DeploymentRepositoryLogger extends BasicLogger {\n \n     /**\n-     * A logger with the category of the pacakge name.\n+     * A logger with the category of the package name.\n      */\n     DeploymentRepositoryLogger ROOT_LOGGER = Logger.getMessageLogger(DeploymentRepositoryLogger.class, DeploymentRepositoryLogger.class.getPackage().getName());\n "},{"filename":"deployment-scanner/src/main/java/org/jboss/as/server/deployment/scanner/ExtensibleFilter.java","diff":"@@ -215,7 +215,7 @@ public boolean accept(File file) {\n             // The < 0 index gives the first index greater than name\n             int firstLessIndex = -2 - index;\n             String prefix = prefixes.get(firstLessIndex);\n-            // If name starts with an ingored prefix ignore name\n+            // If name starts with an ignored prefix ignore name\n             if (name.startsWith(prefix))\n                 return false;\n         }\n@@ -227,7 +227,7 @@ public boolean accept(File file) {\n             // The < 0 index gives the first index greater than name\n             int firstLessIndex = -2 - index;\n             String suffix = suffixes.get(firstLessIndex);\n-            // If name ends with an ingored suffix ignore name\n+            // If name ends with an ignored suffix ignore name\n             if (name.endsWith(suffix))\n                 return false;\n         }"},{"filename":"domain-http/interface/src/main/java/org/jboss/as/domain/http/server/security/NonceFactory.java","diff":"@@ -31,7 +31,7 @@\n /**\n  * A simple NonceFactory for single use nonces.\n  * <p/>\n- * At a later point a pluggable mechansims may be added to control the nonce requirements and add additional generation\n+ * At a later point a pluggable mechanisms may be added to control the nonce requirements and add additional generation\n  * strategies. Issues such as expiration will also be handled.\n  * <p/>\n  * This implementation uses a SecureRandom to generate 16 random bytes which will then be converted to hex as 32 characters."},{"filename":"domain-management/src/main/java/org/jboss/as/domain/management/DomainManagementMessages.java","diff":"@@ -185,7 +185,7 @@\n     String jbossHomeNotSet();\n \n     /**\n-     * A message indicating no mgmt-users.properties have been foun.\n+     * A message indicating no mgmt-users.properties have been found.\n      *\n      * @return a {@link String} for the message.\n      */\n@@ -430,7 +430,7 @@\n     /**\n      * Creates an IllegalArgumentException indicating that a value can not be null.\n      *\n-     * @param name - The name of the paramter that can not be null.\n+     * @param name - The name of the parameter that can not be null.\n      * @return an {@link IllegalArgumentException} for the error.\n      */\n     @Message(id = 15248, value = \"'%s' can not be null.\")\n@@ -459,7 +459,7 @@\n     String filePrompt();\n \n     /**\n-     * Propmpt the user for the roles to add the user to\n+     * Prompt the user for the roles to add the user to\n      * @return\n      */\n     @Message(value = \"What roles do you want this user to belong to? (Please enter a comma separated list, or leave blank for none)\")"},{"filename":"domain-management/src/main/java/org/jboss/as/domain/management/security/AddPropertiesUser.java","diff":"@@ -50,7 +50,7 @@\n  */\n public class AddPropertiesUser {\n \n-    private static final String[] badUsernames = {\"admin\", \"administrator\", \"root\"};\n+    private static final String[] BAD_USER_NAMES = {\"admin\", \"administrator\", \"root\"};\n \n     private static final String DEFAULT_MANAGEMENT_REALM = \"ManagementRealm\";\n     private static final String DEFAULT_APPLICATION_REALM = \"ApplicationRealm\";\n@@ -198,7 +198,7 @@ public State execute() {\n     }\n \n     /**\n-     * The first state executed, responsible for searching for the relevent properties files.\n+     * The first state executed, responsible for searching for the relevant properties files.\n      */\n     private class PropertyFileFinder implements State {\n \n@@ -398,7 +398,7 @@ public State execute() {\n             }\n \n             boolean weakUserName = false;\n-            for (String current : badUsernames) {\n+            for (String current : BAD_USER_NAMES) {\n                 if (current.equals(values.userName.toLowerCase())) {\n                     weakUserName = true;\n                     break;"},{"filename":"domain-management/src/main/java/org/jboss/as/domain/management/security/DomainCallbackHandler.java","diff":"@@ -36,7 +36,7 @@\n     Class<Callback>[] getSupportedCallbacks();\n \n     /**\n-     * Is this DomainCallbackHanler ready for handling remote requests.\n+     * Is this DomainCallbackHandler ready for handling remote requests.\n      *\n      * To be used by the HTTP interface to display an error if the administrator\n      * has not completed the set-up of their AS installation."},{"filename":"ee-deployment/src/main/java/org/jboss/as/ee/deployment/spi/DeploymentManagerImpl.java","diff":"@@ -78,7 +78,7 @@\n public class DeploymentManagerImpl implements DeploymentManager {\n \n     /**\n-     * The URI deployment factory recoginzes: http://org.jboss.as.ee.deployment/jsr88\n+     * The URI deployment factory recognizes: http://org.jboss.as.ee.deployment/jsr88\n      */\n     public static final String DEPLOYER_URI = \"http://org.jboss.as.ee.deployment/jsr88\";\n \n@@ -362,7 +362,7 @@ private ProgressObject doDistribute(Target[] targets, ModuleType type, InputStre\n                 targetModuleIDs[i] = new TargetModuleIDImpl(target, moduleID, null, type);\n             }\n \n-            // delete all temp files, except the depoyment\n+            // delete all temp files, except the deployment\n             for (int i = 0; i < tmpFiles.size(); i++) {\n                 File file = tmpFiles.get(i);\n                 if (file.equals(deployment) == false)\n@@ -391,7 +391,7 @@ private ProgressObject doDistribute(Target[] targets, ModuleType type, InputStre\n     private void initDeploymentMetaData() throws IOException {\n         File metaTmpFile = mapDeploymentPlan.get(DeploymentMetaData.ENTRY_NAME);\n         if (metaTmpFile == null)\n-            throw new IOException(MESSAGES.deployementPlanDoesNotContainEntry(DeploymentMetaData.ENTRY_NAME));\n+            throw new IOException(MESSAGES.deploymentPlanDoesNotContainEntry(DeploymentMetaData.ENTRY_NAME));\n \n         try {\n             SAXReader reader = new SAXReader();"},{"filename":"ee-deployment/src/main/java/org/jboss/as/ee/deployment/spi/DeploymentMessages.java","diff":"@@ -80,7 +80,7 @@\n     String moduleTypeNotSupported(ModuleType type);\n \n     @Message(id = 16162, value = \"Deployment plan does not contain entry: %s\")\n-    String deployementPlanDoesNotContainEntry(String entryname);\n+    String deploymentPlanDoesNotContainEntry(String entryName);\n \n     @Message(id = 16163, value = \"Opaque deployment URI not implemented\")\n     String opaqueDeploymentUriNotImplemented();"},{"filename":"ee-deployment/src/main/java/org/jboss/as/ee/deployment/spi/DeploymentWorker.java","diff":"@@ -35,7 +35,7 @@\n import static org.jboss.as.ee.deployment.spi.DeploymentMessages.MESSAGES;\n \n /**\n- * A thread that deployes the given deployment on all targets contained in the progress object. It sends events to the progress\n+ * A thread that deploys the given deployment on all targets contained in the progress object. It sends events to the progress\n  * object.\n  *\n  * @author Thomas.Diesler@jboss.com"},{"filename":"ee-deployment/src/main/java/org/jboss/as/ee/deployment/spi/beans/AbstractJBossConfigBean.java","diff":"@@ -84,7 +84,7 @@ public void removePropertyChangeListener(PropertyChangeListener pcl) {\n     }\n \n     /**\n-     * Removes the xpath of a given configbean from the list of this bean's xpaths (children so to speak). Then calls death.\n+     * Removes the xpath of a given config bean from the list of this bean's xpaths (children so to speak). Then calls death.\n      */\n     public void removeDConfigBean(DConfigBean bean) throws BeanNotFoundException {\n         // childList.remove(bean);"},{"filename":"ee-deployment/src/main/java/org/jboss/as/ee/deployment/spi/configurations/WarConfiguration.java","diff":"@@ -92,7 +92,7 @@ public void removeDConfigBean(DConfigBeanRoot bean) throws BeanNotFoundException\n     public void save(OutputStream stream) throws ConfigurationException {\n         JarOutputStream jos;\n \n-        // Setup deployment plan meta data with propriatary descriptor (jboss-web.xml)\n+        // Setup deployment plan meta data with proprietary descriptor (jboss-web.xml)\n         DeploymentMetaData metaData = new DeploymentMetaData(\"WRONG.war\");\n \n         try {"},{"filename":"ee-deployment/src/main/java/org/jboss/as/ee/deployment/spi/factories/DeploymentFactoryImpl.java","diff":"@@ -34,7 +34,7 @@\n import static org.jboss.as.ee.deployment.spi.DeploymentLogger.ROOT_LOGGER;\n \n /**\n- * The DeploymentFactory interface is a deployment driver for a J2EE plaform product.\n+ * The DeploymentFactory interface is a deployment driver for a J2EE platform product.\n  *\n  * It returns a DeploymentManager object which represents a connection to a specific J2EE platform product. Each application\n  * server vendor must provide an implementation of this class in order for the J2EE Deployment API to work with their product."},{"filename":"ee/src/main/java/org/jboss/as/ee/component/BasicComponent.java","diff":"@@ -169,7 +169,7 @@ protected BasicComponentInstance constructComponentInstance(ManagedReference ins\n     }\n \n     /**\n-     * Method that can be overriden to perform setup on the instance after it has been created\n+     * Method that can be overridden to perform setup on the instance after it has been created\n      * @param basicComponentInstance The component instance\n      * @param context The interceptor factory context used to construct the instance\n      */"},{"filename":"ee/src/main/java/org/jboss/as/ee/component/ComponentConfiguration.java","diff":"@@ -58,7 +58,7 @@\n     // Core component config\n     private final ClassIndex classIndex;\n     private final ModuleLoader moduleLoader;\n-    private final ClassLoader moduleClassLoder;\n+    private final ClassLoader moduleClassLoader;\n \n     private ComponentCreateServiceFactory componentCreateServiceFactory = ComponentCreateServiceFactory.BASIC;\n \n@@ -87,10 +87,10 @@\n \n     private final Set<Object> interceptorContextKeys = new HashSet<Object>();\n \n-    public ComponentConfiguration(final ComponentDescription componentDescription, final ClassIndex classIndex, final ClassLoader moduleClassLoder, final ModuleLoader moduleLoader) {\n+    public ComponentConfiguration(final ComponentDescription componentDescription, final ClassIndex classIndex, final ClassLoader moduleClassLoader, final ModuleLoader moduleLoader) {\n         this.componentDescription = componentDescription;\n         this.classIndex = classIndex;\n-        this.moduleClassLoder = moduleClassLoder;\n+        this.moduleClassLoader = moduleClassLoader;\n         this.moduleLoader = moduleLoader;\n     }\n \n@@ -415,8 +415,8 @@ public void setNamespaceContextInterceptorFactory(InterceptorFactory interceptor\n         this.namespaceContextInterceptorFactory = interceptorFactory;\n     }\n \n-    public ClassLoader getModuleClassLoder() {\n-        return moduleClassLoder;\n+    public ClassLoader getModuleClassLoader() {\n+        return moduleClassLoader;\n     }\n \n     public ModuleLoader getModuleLoader() {"},{"filename":"ee/src/main/java/org/jboss/as/ee/component/ComponentDescription.java","diff":"@@ -154,8 +154,8 @@ public ComponentDescription(final String componentName, final String componentCl\n         configurators.addLast(FIRST_CONFIGURATOR);\n     }\n \n-    public ComponentConfiguration createConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoder, final ModuleLoader moduleLoader) {\n-        return new ComponentConfiguration(this, classIndex, moduleClassLoder, moduleLoader);\n+    public ComponentConfiguration createConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoader, final ModuleLoader moduleLoader) {\n+        return new ComponentConfiguration(this, classIndex, moduleClassLoader, moduleLoader);\n     }\n \n     /**"},{"filename":"ee/src/main/java/org/jboss/as/ee/component/deployers/ComponentInstallProcessor.java","diff":"@@ -143,7 +143,7 @@ protected void deployComponent(final DeploymentPhaseContext phaseContext, final\n         //don't start components until all bindings are up\n         startBuilder.addDependency(bindingDependencyService);\n         final ServiceName contextServiceName;\n-        //set up the naming context if nessesary\n+        //set up the naming context if necessary\n         if (configuration.getComponentDescription().getNamingMode() == ComponentNamingMode.CREATE) {\n             final NamingStoreService contextService = new NamingStoreService();\n             contextServiceName = configuration.getComponentDescription().getContextServiceName();"},{"filename":"ee/src/main/java/org/jboss/as/ee/component/deployers/EarMessageDestinationProcessor.java","diff":"@@ -27,7 +27,7 @@ public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitPro\n                 if (metadata.getEarEnvironmentRefsGroup() != null) {\n                     if (metadata.getEarEnvironmentRefsGroup().getMessageDestinations() != null) {\n                         for (final MessageDestinationMetaData destination : metadata.getEarEnvironmentRefsGroup().getMessageDestinations()) {\n-                            //TODO: should these be two seperate metadata attributes?\n+                            //TODO: should these be two separate metadata attributes?\n                             if (destination.getJndiName() != null) {\n                                 eeModuleDescription.addMessageDestination(destination.getName(), destination.getJndiName());\n                             } else if (destination.getLookupName() != null) {"},{"filename":"ee/src/main/java/org/jboss/as/ee/component/interceptors/InterceptorClassDescription.java","diff":"@@ -48,7 +48,7 @@ public InterceptorClassDescription(final MethodIdentifier aroundInvoke, final Me\n     }\n \n     /**\n-     * Merges two descriptors, either of the paraemters will be null.\n+     * Merges two descriptors, either of the parameters will be null.\n      * <p/>\n      * this method will never return null;\n      *"},{"filename":"ee/src/main/java/org/jboss/as/ee/component/interceptors/InterceptorOrder.java","diff":"@@ -135,7 +135,7 @@ private ComponentPassivation() {\n         public static final int EJB_SECURITY_AUTHORIZATION_INTERCEPTOR = 0x300;\n         public static final int INVOCATION_CONTEXT_INTERCEPTOR = 0x400;\n         // should happen before the CMT/BMT interceptors\n-        public static final int REMOTE_TRANSACTION_PROPOGATION_INTERCEPTOR = 0x450;\n+        public static final int REMOTE_TRANSACTION_PROPAGATION_INTERCEPTOR = 0x450;\n         public static final int CMT_TRANSACTION_INTERCEPTOR = 0x500;\n         public static final int HOME_METHOD_INTERCEPTOR = 0x600;\n         public static final int ASSOCIATING_INTERCEPTOR = 0x700;"},{"filename":"ee/src/main/java/org/jboss/as/ee/component/serialization/WriteReplaceInterface.java","diff":"@@ -24,7 +24,7 @@\n import java.io.IOException;\n \n /**\n- * Interface used to allow the proxy to supprt serialization. Currently used to work around\n+ * Interface used to allow the proxy to support serialization. Currently used to work around\n  * a limitation in the ProxyFactory\n  * @author Stuart Douglas\n  */"},{"filename":"ee/src/main/java/org/jboss/as/ee/datasource/DataSourceTransactionProxyHandler.java","diff":"@@ -38,7 +38,7 @@\n  * Proxy handler that automatically enlists XA resources returned from a datasource.\n  * <p/>\n  * If getConnection() is called and the datasource is an XA datasource then getXAConnection() is called\n- * instead and the resource is enlised in the transaction\n+ * instead and the resource is enlisted in the transaction\n  *\n  * @author Stuart Douglas\n  */\n@@ -61,16 +61,16 @@ public DataSourceTransactionProxyHandler(final Object delegate, final Transactio\n     public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n         if (method.getName().equals(\"getConnection\") && method.getParameterTypes().length == 0 && delegate instanceof XADataSource) {\n             final XADataSource xa = (XADataSource) delegate;\n-            final XAConnection xacon = xa.getXAConnection();\n+            final XAConnection xaConn = xa.getXAConnection();\n             final Object transactionKey = synchronizationRegistry.getTransactionKey();\n             if (!registeredTransactions.contains(transactionKey)) {\n                 if (transactionManager.getTransaction() != null && transactionActive(transactionManager.getTransaction().getStatus())) {\n-                    transactionManager.getTransaction().enlistResource(xacon.getXAResource());\n+                    transactionManager.getTransaction().enlistResource(xaConn.getXAResource());\n                     synchronizationRegistry.registerInterposedSynchronization(new Sync(transactionKey));\n                     registeredTransactions.add(transactionKey);\n                 }\n             }\n-            return xacon.getConnection();\n+            return xaConn.getConnection();\n         } else {\n             final Object ret = method.invoke(delegate, args);\n             return ret;"},{"filename":"ee/src/main/java/org/jboss/as/ee/managedbean/processors/ManagedBeanAnnotationProcessor.java","diff":"@@ -117,7 +117,7 @@ public void configure(final DeploymentPhaseContext context, final ComponentConfi\n                     final ManagedBeanAssociatingInterceptorFactory associatingInterceptorFactory = new ManagedBeanAssociatingInterceptorFactory(contextKey);\n                     configuration.addClientInterceptor(associatingInterceptorFactory, InterceptorOrder.Client.ASSOCIATING_INTERCEPTOR);\n                     configuration.addClientPreDestroyInterceptor(new ManagedBeanDestroyInterceptorFactory(contextKey), InterceptorOrder.ClientPreDestroy.INSTANCE_DESTROY);\n-                    configuration.addViewInterceptor(new ImmediateInterceptorFactory(new TCCLInterceptor(componentConfiguration.getModuleClassLoder())), InterceptorOrder.View.TCCL_INTERCEPTOR);\n+                    configuration.addViewInterceptor(new ImmediateInterceptorFactory(new TCCLInterceptor(componentConfiguration.getModuleClassLoader())), InterceptorOrder.View.TCCL_INTERCEPTOR);\n                 }\n             });\n             viewDescription.getBindingNames().addAll(Arrays.asList(\"java:module/\" + beanName, \"java:app/\" + moduleDescription.getModuleName() + \"/\" + beanName));"},{"filename":"ee/src/main/java/org/jboss/as/ee/metadata/AbstractEEAnnotationProcessor.java","diff":"@@ -62,7 +62,7 @@ public final void deploy(final DeploymentPhaseContext phaseContext) throws Deplo\n     }\n \n     /**\n-     * Method that can be overriden to do any additional processing\n+     * Method that can be overridden to do any additional processing\n      * @param phaseContext The phase context\n      * @param deploymentUnit The deployment unit\n      */"},{"filename":"ee/src/main/java/org/jboss/as/ee/metadata/MethodAnnotationAggregator.java","diff":"@@ -41,7 +41,7 @@\n /**\n  * Class which can turn a pre-runtime description of annotations into a runtime description.\n  * <p/>\n- * This correctly handles overriden methods, so the annotations on overriden methods will not show up in the result\n+ * This correctly handles overridden methods, so the annotations on overridden methods will not show up in the result\n  *\n  * @author Stuart Douglas\n  */\n@@ -70,7 +70,7 @@\n                     for (Map.Entry<MethodIdentifier, List<T>> entry : annotationData.getMethodLevelAnnotations().entrySet()) {\n                         final Method method = classIndex.getMethod(entry.getKey());\n                         if (method != null) {\n-                            //we do not have to worry about private methods being overriden\n+                            //we do not have to worry about private methods being overridden\n                             if (Modifier.isPrivate(method.getModifiers()) || !methodIdentifiers.contains(entry.getKey())) {\n                                 methods.put(method, entry.getValue());\n                             }\n@@ -86,7 +86,7 @@\n             //we store all the method identifiers\n             //so we can check if a method is overriden\n             for (Method method : classIndex.getMethods()) {\n-                //we do not have to worry about private methods being overriden\n+                //we do not have to worry about private methods being overridden\n                 if (!Modifier.isPrivate(method.getModifiers())) {\n                     methodIdentifiers.add(MethodIdentifier.getIdentifierForMethod(method));\n                 }"},{"filename":"ee/src/main/java/org/jboss/as/ee/structure/EarMetaDataParsingProcessor.java","diff":"@@ -45,7 +45,7 @@\n import static org.jboss.as.ee.EeMessages.MESSAGES;\n \n /**\n- * Deployment processor responsible for parsing the applicaiton.xml file of an ear.\n+ * Deployment processor responsible for parsing the application.xml file of an ear.\n  *\n  * @author John Bailey\n  */"},{"filename":"ee/src/main/java/org/jboss/as/ee/structure/EjbJarDeploymentProcessor.java","diff":"@@ -46,7 +46,7 @@\n public class EjbJarDeploymentProcessor implements DeploymentUnitProcessor {\n \n     private static final DotName STATELESS = DotName.createSimple(\"javax.ejb.Stateless\");\n-    private static final DotName STATEFULL = DotName.createSimple(\"javax.ejb.Stateful\");\n+    private static final DotName STATEFUL = DotName.createSimple(\"javax.ejb.Stateful\");\n     private static final DotName MESSAGE_DRIVEN = DotName.createSimple(\"javax.ejb.MessageDriven\");\n     private static final DotName SINGLETON = DotName.createSimple(\"javax.ejb.Singleton\");\n \n@@ -80,7 +80,7 @@ public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitPro\n             } else {\n                 final Index index = resourceRoot.getAttachment(Attachments.ANNOTATION_INDEX);\n                 if (index != null) {\n-                    if (!index.getAnnotations(STATEFULL).isEmpty() ||\n+                    if (!index.getAnnotations(STATEFUL).isEmpty() ||\n                             !index.getAnnotations(STATELESS).isEmpty() ||\n                             !index.getAnnotations(MESSAGE_DRIVEN).isEmpty() ||\n                             !index.getAnnotations(SINGLETON).isEmpty()) {"},{"filename":"ee/src/main/java/org/jboss/as/ee/subsystem/EeExtension.java","diff":"@@ -143,7 +143,7 @@ public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) th\n             requireNoAttributes(reader);\n \n             final ModelNode eeSubSystem = createEESubSystemAddOperation();\n-            // add the subsytem to the ModelNode(s)\n+            // add the subsystem to the ModelNode(s)\n             list.add(eeSubSystem);\n \n             // elements"},{"filename":"ee/src/main/java/org/jboss/as/ee/subsystem/EeSubsystemAdd.java","diff":"@@ -133,7 +133,7 @@ protected void execute(DeploymentProcessorTarget processorTarget) {\n \n                 processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EE_MODULE_NAME, new EEModuleNameProcessor());\n                 processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EE_ANNOTATIONS, new EEAnnotationProcessor());\n-                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_LIEFCYCLE_ANNOTATION, new LifecycleAnnotationParsingProcessor());\n+                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_LIFECYCLE_ANNOTATION, new LifecycleAnnotationParsingProcessor());\n                 processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_AROUNDINVOKE_ANNOTATION, new AroundInvokeAnnotationParsingProcessor());\n                 processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EAR_SUBDEPLOYMENTS_ISOLATION_DEFAULT, isolationProcessor);\n                 processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_DATA_SOURCE_DEFINITION_ANNOTATION, new DataSourceDefinitionAnnotationParser());"},{"filename":"ee/src/main/java/org/jboss/as/ee/utils/DescriptorUtils.java","diff":"@@ -88,17 +88,17 @@ public static String makeDescriptor(Constructor<?> c) {\n \n     /**\n      * returns an array of String representations of the parameter types. Primitives are returned as their native\n-     * representations, while clases are returned in the internal descriptor form e.g. Ljava/lang/Integer;\n+     * representations, while classes are returned in the internal descriptor form e.g. Ljava/lang/Integer;\n      */\n     public static String[] parameterDescriptors(String methodDescriptor) {\n         int i = 1; // char 0 is a '('\n         List<String> ret = new ArrayList<String>();\n-        int arraystart = -1;\n+        int arrayStart = -1;\n         while (methodDescriptor.charAt(i) != ')') {\n             String type = null;\n             if (methodDescriptor.charAt(i) == '[') {\n-                if (arraystart == -1) {\n-                    arraystart = i;\n+                if (arrayStart == -1) {\n+                    arrayStart = i;\n                 }\n             } else {\n                 if (methodDescriptor.charAt(i) == 'L') {\n@@ -107,19 +107,19 @@ public static String makeDescriptor(Constructor<?> c) {\n                     while (methodDescriptor.charAt(i) != ';') {\n                         ++i;\n                     }\n-                    if (arraystart == -1) {\n+                    if (arrayStart == -1) {\n                         type = methodDescriptor.substring(start, i);\n                     } else {\n-                        type = methodDescriptor.substring(arraystart, i);\n+                        type = methodDescriptor.substring(arrayStart, i);\n                     }\n                 } else {\n-                    if (arraystart == -1) {\n+                    if (arrayStart == -1) {\n                         type = methodDescriptor.charAt(i) + \"\";\n                     } else {\n-                        type = methodDescriptor.substring(arraystart, i + 1);\n+                        type = methodDescriptor.substring(arrayStart, i + 1);\n                     }\n                 }\n-                arraystart = -1;\n+                arrayStart = -1;\n                 ret.add(type);\n             }\n             ++i;"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/EjbLogger.java","diff":"@@ -65,7 +65,7 @@\n     EjbLogger EJB3_LOGGER = Logger.getMessageLogger(EjbLogger.class, \"org.jboss.ejb3\");\n \n     /**\n-     * logger use to log EJB invocation eorrors\n+     * logger use to log EJB invocation errors\n      */\n     EjbLogger EJB3_INVOCATION_LOGGER = Logger.getMessageLogger(EjbLogger.class, \"org.jboss.ejb3.invocation\");\n \n@@ -244,7 +244,7 @@\n      * Logs an error message indicating an error during retyring timeout for timer\n      */\n     @LogMessage(level = ERROR)\n-    @Message(id = 14122, value = \"Error during retyring timeout for timer: %s\")\n+    @Message(id = 14122, value = \"Error during retrying timeout for timer: %s\")\n     void errorDuringRetryTimeout(Timer timer, @Cause Throwable e);\n \n     /**"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/EjbMessages.java","diff":"@@ -93,7 +93,7 @@\n      * @return a {@link IllegalArgumentException} for the error.\n      */\n     @Message(id = 14302, value = \"Method name cannot be null\")\n-    IllegalArgumentException methodeNameIsNull();\n+    IllegalArgumentException methodNameIsNull();\n \n     /**\n      * Creates an exception indicating the bean home interface was not set\n@@ -166,7 +166,7 @@\n      * Creates an exception indicating the NamespaceContextSelector was not set\n      *\n      * @param name the jndi name\n-     * @param e    cause of the exeception\n+     * @param e    cause of the exception\n      *\n      * @return a {@link RuntimeException} for the error.\n      */\n@@ -189,7 +189,7 @@\n      *\n      * @param namespaceContextSelector\n      * @param jndiContext              the jndi context it was looked up on\n-     * @param ne                       cause of the exeception\n+     * @param ne                       cause of the exception\n      *\n      * @return a {@link IllegalArgumentException} for the error.\n      */\n@@ -468,7 +468,7 @@\n      * @return a {@link NoSuchEJBException} for the error.\n      */\n     @Message(id = 14344, value = \"Instance of %s with primary key %s has been removed\")\n-    NoSuchEntityException instaceWasRemoved(String componentName, Object primaryKey);\n+    NoSuchEntityException instanceWasRemoved(String componentName, Object primaryKey);\n \n     /**\n      * Creates an exception indicating unexpected component\n@@ -1641,7 +1641,7 @@\n \n     /**\n      * Creates an exception indicating Method for view shouldn't be\n-     * marked for both @PemitAll and @DenyAll at the same time\n+     * marked for both @PermitAll and @DenyAll at the same time\n      *\n      * @return an {@link IllegalStateException} for the error.\n      */"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/EJBBusinessMethod.java","diff":"@@ -52,7 +52,7 @@ public EJBBusinessMethod(String methodName, Class<?>... methodParamTypes) {\n \n     public EJBBusinessMethod(MethodIntf view, String methodName, Class<?>... paramTypes) {\n         if (methodName == null) {\n-            throw MESSAGES.methodeNameIsNull();\n+            throw MESSAGES.methodNameIsNull();\n         }\n         this.methodName = methodName;\n         this.methodParamTypes = paramTypes == null ? new Class<?>[0] : paramTypes;"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/EJBComponentDescription.java","diff":"@@ -122,7 +122,7 @@\n     private String runAsPrincipal;\n \n     /**\n-     * Roles mapped with secuirty-role\n+     * Roles mapped with security-role\n      */\n     private SecurityRolesMetaData securityRoles;\n \n@@ -234,7 +234,7 @@ public void configure(final DeploymentPhaseContext context, final ComponentDescr\n                     if(!ejbSetupActions.isEmpty()) {\n                         configuration.addTimeoutViewInterceptor(AdditionalSetupInterceptor.factory(ejbSetupActions), InterceptorOrder.View.EE_SETUP);\n                     }\n-                    configuration.addTimeoutViewInterceptor(new ImmediateInterceptorFactory(new TCCLInterceptor(configuration.getModuleClassLoder())), InterceptorOrder.View.TCCL_INTERCEPTOR);\n+                    configuration.addTimeoutViewInterceptor(new ImmediateInterceptorFactory(new TCCLInterceptor(configuration.getModuleClassLoader())), InterceptorOrder.View.TCCL_INTERCEPTOR);\n                     configuration.addTimeoutViewInterceptor(configuration.getNamespaceContextInterceptorFactory(), InterceptorOrder.View.JNDI_NAMESPACE_INTERCEPTOR);\n                     configuration.addTimeoutViewInterceptor(CurrentInvocationContextInterceptor.FACTORY, InterceptorOrder.View.INVOCATION_CONTEXT_INTERCEPTOR);\n                     if (isSecurityEnabled()) {\n@@ -309,7 +309,7 @@ protected void setupViewInterceptors(final EJBViewDescription view) {\n             @Override\n             public void configure(DeploymentPhaseContext context, ComponentConfiguration componentConfiguration, ViewDescription description, ViewConfiguration viewConfiguration) throws DeploymentUnitProcessingException {\n                 viewConfiguration.addViewInterceptor(LoggingInterceptor.FACTORY, InterceptorOrder.View.EJB_EXCEPTION_LOGGING_INTERCEPTOR);\n-                viewConfiguration.addViewInterceptor(new ImmediateInterceptorFactory(new TCCLInterceptor(componentConfiguration.getModuleClassLoder())), InterceptorOrder.View.TCCL_INTERCEPTOR);\n+                viewConfiguration.addViewInterceptor(new ImmediateInterceptorFactory(new TCCLInterceptor(componentConfiguration.getModuleClassLoader())), InterceptorOrder.View.TCCL_INTERCEPTOR);\n \n                 //If this is the EJB 2.x local or home view add the exception transformer interceptor\n                 if (view.getMethodIntf() == MethodIntf.LOCAL && EJBLocalObject.class.isAssignableFrom(viewConfiguration.getViewClass())) {\n@@ -354,7 +354,7 @@ public void configure(final DeploymentPhaseContext context, final ComponentConfi\n                     }\n                 });\n             }\n-            // add the remote tx propogating interceptor\n+            // add the remote tx propagating interceptor\n             view.getConfigurators().add(new EJBRemoteTransactionsViewConfigurator());\n         }\n "},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/Ejb2xViewType.java","diff":"@@ -3,7 +3,7 @@\n /**\n  * An enum that is used as a marker for EJB 2.x views.\n  *\n- * {@link MethodIntf} is not sufficent for this, as it cannot differentiate\n+ * {@link MethodIntf} is not sufficient for this, as it cannot differentiate\n  * between EJB 3 business and EJB 2 component views\n  *\n  * @author Stuart Douglas"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/MethodIntfHelper.java","diff":"@@ -31,7 +31,7 @@\n     // centralize this hack\n     public static MethodIntf of(final InterceptorContext invocation) {\n         //for timer invocations there is no view, so the methodInf is attached directly\n-        //to the context. Otherwise we retrive it from the invoked view\n+        //to the context. Otherwise we retrieve it from the invoked view\n         MethodIntf methodIntf = invocation.getPrivateData(MethodIntf.class);\n         if (methodIntf == null) {\n             final ComponentView componentView = invocation.getPrivateData(ComponentView.class);"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/allowedmethods/AllowedMethodsInformation.java","diff":"@@ -91,7 +91,7 @@ public static void checkAllowed(final MethodType methodType) {\n     }\n \n     /**\n-     * transaction sync is not afected by the current invocation, as multiple ejb methods may be invoked from afterCompletion\n+     * transaction sync is not affected by the current invocation, as multiple ejb methods may be invoked from afterCompletion\n      */\n     private void checkTransactionSync(MethodType methodType) {\n         //first we have to check the synchronization status"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/entity/EntityBeanComponentCreateService.java","diff":"@@ -82,7 +82,7 @@ public EntityBeanComponentCreateService(final ComponentConfiguration componentCo\n         remoteClass = (Class<EJBObject>) load(classLoader, beanMetaData.getRemote());\n         primaryKeyClass = (Class<Object>) load(classLoader, beanMetaData.getPrimKeyClass());\n \n-        final InterceptorFactory tcclInterceptorFactory = new ImmediateInterceptorFactory(new TCCLInterceptor(componentConfiguration.getModuleClassLoder()));\n+        final InterceptorFactory tcclInterceptorFactory = new ImmediateInterceptorFactory(new TCCLInterceptor(componentConfiguration.getModuleClassLoader()));\n         final InterceptorFactory namespaceContextInterceptorFactory = componentConfiguration.getNamespaceContextInterceptorFactory();\n \n "},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/entity/EntityBeanComponentDescription.java","diff":"@@ -125,8 +125,8 @@ public void configure(DeploymentPhaseContext context, ComponentConfiguration com\n \n \n     @Override\n-    public final ComponentConfiguration createConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoder, final ModuleLoader moduleLoader) {\n-        final ComponentConfiguration configuration = createEntityBeanConfiguration(classIndex, moduleClassLoder, moduleLoader);\n+    public final ComponentConfiguration createConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoader, final ModuleLoader moduleLoader) {\n+        final ComponentConfiguration configuration = createEntityBeanConfiguration(classIndex, moduleClassLoader, moduleLoader);\n         configuration.getCreateDependencies().add(new ConfigInjectingConfigurator(this));\n         // add the timer interceptor\n         getConfigurators().add(new ComponentConfigurator() {\n@@ -138,8 +138,8 @@ public void configure(final DeploymentPhaseContext context, final ComponentDescr\n         return configuration;\n     }\n \n-    protected ComponentConfiguration createEntityBeanConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoder, final ModuleLoader moduleLoader) {\n-        final ComponentConfiguration configuration = new ComponentConfiguration(this, classIndex, moduleClassLoder, moduleLoader);\n+    protected ComponentConfiguration createEntityBeanConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoader, final ModuleLoader moduleLoader) {\n+        final ComponentConfiguration configuration = new ComponentConfiguration(this, classIndex, moduleClassLoader, moduleLoader);\n         // setup the component create service\n         configuration.setComponentCreateServiceFactory(EntityBeanComponentCreateService.FACTORY);\n         return configuration;"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/entity/EntityBeanObjectViewConfigurator.java","diff":"@@ -150,7 +150,7 @@ protected InterceptorFactory getEjbCreateInterceptorFactory() {\n     }\n \n     protected InterceptorFactory getEjbRemoveInterceptorFactory(final Method remove) {\n-        //for BMP beans we just inoke the ejb remove method as normal, and allow the ejb remove\n+        //for BMP beans we just invoke the ejb remove method as normal, and allow the ejb remove\n         //method to handle the actual removal\n         return new ImmediateInterceptorFactory(new ComponentDispatcherInterceptor(remove));\n     }"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/entity/EntityBeanRemoteViewInstanceFactory.java","diff":"@@ -81,7 +81,7 @@ private Object invokeCreate(final Component component, final Map<Object, Object>\n             throw new IllegalStateException(\"Unexpected component: \" + component + \" Expected \" + EntityBeanComponent.class);\n         }\n         final EntityBeanComponent entityBeanComponent = (EntityBeanComponent) component;\n-        //grab an unasociated entity bean from the pool\n+        //grab an unassociated entity bean from the pool\n         final EntityBeanComponentInstance instance = entityBeanComponent.acquireUnAssociatedInstance();\n \n         //call the ejbCreate method"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/entity/interceptors/EntityBeanAssociatingInterceptor.java","diff":"@@ -62,7 +62,7 @@ public Object processInvocation(final InterceptorContext context) throws Excepti\n \n             if (instance.isRemoved()) {\n                 component.getCache().release(instance, true);\n-                throw MESSAGES.instaceWasRemoved(component.getComponentName(), primaryKey);\n+                throw MESSAGES.instanceWasRemoved(component.getComponentName(), primaryKey);\n             }\n         } catch (javax.ejb.NoSuchEntityException e) {\n             //if this is a timer service invocation we throw a special exception"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/entity/interceptors/EntityBeanSynchronizationInterceptor.java","diff":"@@ -89,7 +89,7 @@ public Object processInvocation(InterceptorContext context) throws Exception {\n                         final Object primaryKey = context.getPrivateData(EntityBeanComponent.PRIMARY_KEY_CONTEXT_KEY);\n                         component.getCache().release(instance, true);\n                         lock.unlock();\n-                        throw MESSAGES.instaceWasRemoved(component.getComponentName(), primaryKey);\n+                        throw MESSAGES.instanceWasRemoved(component.getComponentName(), primaryKey);\n                     }\n                 }\n "},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/messagedriven/MessageDrivenComponentDescription.java","diff":"@@ -108,8 +108,8 @@ public void configure(final DeploymentPhaseContext context, final ComponentDescr\n     }\n \n     @Override\n-    public ComponentConfiguration createConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoder, final ModuleLoader moduleLoader) {\n-        final ComponentConfiguration mdbComponentConfiguration = new ComponentConfiguration(this, classIndex, moduleClassLoder, moduleLoader);\n+    public ComponentConfiguration createConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoader, final ModuleLoader moduleLoader) {\n+        final ComponentConfiguration mdbComponentConfiguration = new ComponentConfiguration(this, classIndex, moduleClassLoader, moduleLoader);\n         // setup the component create service\n         mdbComponentConfiguration.setComponentCreateServiceFactory(new MessageDrivenComponentCreateServiceFactory());\n "},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/singleton/SingletonComponentDescription.java","diff":"@@ -97,9 +97,9 @@ public void configure(final DeploymentPhaseContext context, final ComponentDescr\n     }\n \n     @Override\n-    public ComponentConfiguration createConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoder, final ModuleLoader moduleLoader) {\n+    public ComponentConfiguration createConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoader, final ModuleLoader moduleLoader) {\n \n-        ComponentConfiguration singletonComponentConfiguration = new ComponentConfiguration(this, classIndex, moduleClassLoder, moduleLoader);\n+        ComponentConfiguration singletonComponentConfiguration = new ComponentConfiguration(this, classIndex, moduleClassLoader, moduleLoader);\n         // setup the component create service\n         singletonComponentConfiguration.setComponentCreateServiceFactory(new SingletonComponentCreateServiceFactory(this.isInitOnStartup(), dependsOn));\n "},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/stateful/StatefulComponentDescription.java","diff":"@@ -157,9 +157,9 @@ public void configure(DeploymentPhaseContext context, ComponentDescription descr\n     }\n \n     @Override\n-    public ComponentConfiguration createConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoder, final ModuleLoader moduleLoader) {\n+    public ComponentConfiguration createConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoader, final ModuleLoader moduleLoader) {\n \n-        final ComponentConfiguration statefulComponentConfiguration = new ComponentConfiguration(this, classIndex, moduleClassLoder, moduleLoader);\n+        final ComponentConfiguration statefulComponentConfiguration = new ComponentConfiguration(this, classIndex, moduleClassLoader, moduleLoader);\n         // setup the component create service\n         statefulComponentConfiguration.setComponentCreateServiceFactory(new StatefulComponentCreateServiceFactory());\n "},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/stateful/StatefulSessionComponentCreateService.java","diff":"@@ -77,7 +77,7 @@ public StatefulSessionComponentCreateService(final ComponentConfiguration compon\n         super(componentConfiguration, ejbJarConfiguration);\n \n         final StatefulComponentDescription componentDescription = (StatefulComponentDescription) componentConfiguration.getComponentDescription();\n-        final InterceptorFactory tcclInterceptorFactory = new ImmediateInterceptorFactory(new TCCLInterceptor(componentConfiguration.getModuleClassLoder()));\n+        final InterceptorFactory tcclInterceptorFactory = new ImmediateInterceptorFactory(new TCCLInterceptor(componentConfiguration.getModuleClassLoader()));\n         final InterceptorFactory namespaceContextInterceptorFactory = componentConfiguration.getNamespaceContextInterceptorFactory();\n \n         this.afterBeginMethod = componentDescription.getAfterBegin();\n@@ -95,7 +95,7 @@ public StatefulSessionComponentCreateService(final ComponentConfiguration compon\n         this.marshallingConfiguration = new MarshallingConfiguration();\n         this.marshallingConfiguration.setSerializedCreator(new SunReflectiveCreator());\n         this.marshallingConfiguration.setExternalizerCreator(new ReflectiveCreator());\n-        this.marshallingConfiguration.setClassResolver(new ClassLoaderAwareClassResolver(ModularClassResolver.getInstance(componentConfiguration.getModuleLoader()), componentConfiguration.getModuleClassLoder()));\n+        this.marshallingConfiguration.setClassResolver(new ClassLoaderAwareClassResolver(ModularClassResolver.getInstance(componentConfiguration.getModuleLoader()), componentConfiguration.getModuleClassLoader()));\n         this.marshallingConfiguration.setSerializabilityChecker(new StatefulSessionBeanSerializabilityChecker(componentConfiguration.getComponentClass()));\n         this.marshallingConfiguration.setClassTable(new StatefulSessionBeanClassTable());\n         this.serializableInterceptorContextKeys = componentConfiguration.getInterceptorContextKeys();"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/component/stateless/StatelessComponentDescription.java","diff":"@@ -79,8 +79,8 @@ public StatelessComponentDescription(final String componentName, final String co\n     }\n \n     @Override\n-    public ComponentConfiguration createConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoder, final ModuleLoader moduleLoader) {\n-        final ComponentConfiguration statelessComponentConfiguration = new ComponentConfiguration(this, classIndex, moduleClassLoder, moduleLoader);\n+    public ComponentConfiguration createConfiguration(final ClassIndex classIndex, final ClassLoader moduleClassLoader, final ModuleLoader moduleLoader) {\n+        final ComponentConfiguration statelessComponentConfiguration = new ComponentConfiguration(this, classIndex, moduleClassLoader, moduleLoader);\n         // setup the component create service\n         statelessComponentConfiguration.setComponentCreateServiceFactory(new StatelessComponentCreateServiceFactory());\n "},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/deployment/ApplicableMethodInformation.java","diff":"@@ -11,7 +11,7 @@\n import static org.jboss.as.ejb3.EjbMessages.MESSAGES;\n \n /**\n- * Metadata store for method level information that can be applied to a method via versious different deployment\n+ * Metadata store for method level information that can be applied to a method via various different deployment\n  * descriptor styles\n  *\n  * @author Stuart Douglas"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/deployment/ApplicationExceptions.java","diff":"@@ -55,7 +55,7 @@ public void addApplicationException(Class<?> exceptionClass, org.jboss.as.ejb3.t\n         if (applicationException == null) {\n             throw new IllegalArgumentException(\"ApplicationException cannot be null\");\n         }\n-        // EJB 3.1 sepc, section 14.1.1\n+        // EJB 3.1 spec, section 14.1.1\n         // application exception *must* be of type Exception\n         if (!Exception.class.isAssignableFrom(exceptionClass)) {\n             throw new IllegalArgumentException(\"[EJB 3.1 spec, section 14.1.1] Class: \" + exceptionClass + \" cannot be \" +"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/deployment/processors/AbstractDeploymentUnitProcessor.java","diff":"@@ -51,7 +51,7 @@\n \n     /**\n      * If this is an appclient we want to make the components as not installable, so we can still look up which EJB's are in\n-     * the deployment, but do not actuall install them\n+     * the deployment, but do not actual install them\n      */\n     protected final boolean appclient;\n "},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/deployment/processors/AnnotatedEJBComponentDescriptionDeploymentUnitProcessor.java","diff":"@@ -39,7 +39,7 @@\n \n     /**\n      * If this is an appclient we want to make the components as not installable, so we can still look up which EJB's are in\n-     * the deployment, but do not actuall install them\n+     * the deployment, but do not actually install them\n      */\n     protected final boolean appclient;\n "},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/deployment/processors/EJBClientDescriptorMetaDataProcessor.java","diff":"@@ -85,7 +85,7 @@ public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitPro\n                 final ServiceName localEjbReceiverServiceName = passByValue == true ? LocalEjbReceiver.BY_VALUE_SERVICE_NAME : LocalEjbReceiver.BY_REFERENCE_SERVICE_NAME;\n                 serviceBuilder.addDependency(localEjbReceiverServiceName, LocalEjbReceiver.class, service.getLocalEjbReceiverInjector());\n             } else {\n-                // setup a dependency on the default local ejb receiver service configured at the subsytem level\n+                // setup a dependency on the default local ejb receiver service configured at the subsystem level\n                 serviceBuilder.addDependency(LocalEjbReceiver.DEFAULT_LOCAL_EJB_RECEIVER_SERVICE_NAME, LocalEjbReceiver.class, service.getLocalEjbReceiverInjector());\n             }\n         }"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/deployment/processors/EJBComponentDescriptionFactory.java","diff":"@@ -43,7 +43,7 @@\n \n     /**\n      * If this is an appclient we want to make the components as not installable, so we can still look up which EJB's are in\n-     * the deployment, but do not actuall install them\n+     * the deployment, but do not actually install them\n      */\n     protected final boolean appclient;\n "},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/deployment/processors/EjbJndiBindingsDeploymentUnitProcessor.java","diff":"@@ -197,7 +197,7 @@ private void registerRemoteBinding(final EJBComponentDescription componentDescri\n         moduleDescription.getBindingConfigurations().add(new BindingConfiguration(jndiName, new RemoteViewInjectionSource(null, moduleDescription.getEarApplicationName(), moduleDescription.getModuleName(), moduleDescription.getDistinctName(), componentDescription.getComponentName(), viewDescription.getViewClassName(), componentDescription.isStateful(), viewClassLoader)));\n         componentDescription.getConfigurators().add(new ComponentConfigurator() {\n             public void configure(DeploymentPhaseContext context, ComponentDescription description, ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n-                viewClassLoader.setValue(Values.immediateValue(configuration.getModuleClassLoder()));\n+                viewClassLoader.setValue(Values.immediateValue(configuration.getModuleClassLoader()));\n             }\n         });\n     }"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/deployment/processors/MessageDrivenComponentDescriptionFactory.java","diff":"@@ -129,7 +129,7 @@ private void processMessageBeans(final DeploymentUnit deploymentUnit, final Coll\n                         }\n                     }\n                 } else if (beanMetaData instanceof JBossGenericBeanMetaData) {\n-                    //TODO: fix the heirachy so this is not needed\n+                    //TODO: fix the hierarchy so this is not needed\n                     final JBossGenericBeanMetaData mdb = (JBossGenericBeanMetaData) beanMetaData;\n                     messagingType = mdb.getMessagingType();\n                     final ActivationConfigMetaData activationConfigMetaData = mdb.getActivationConfig();\n@@ -259,7 +259,7 @@ private Properties getActivationConfigProperties(final AnnotationInstance messag\n     }\n \n     /**\n-     * Returns the name of the resource adapter which will be used as the default RA for MDBs (unless overriden by\n+     * Returns the name of the resource adapter which will be used as the default RA for MDBs (unless overridden by\n      * the MDBs).\n      *\n      * @param serviceRegistry"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/deployment/processors/dd/AssemblyDescriptorProcessor.java","diff":"@@ -76,7 +76,7 @@ public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitPro\n \n     private void processMessageDestinations(final MessageDestinationsMetaData destinations, final EEModuleDescription eeModuleDescription) {\n         for(final MessageDestinationMetaData destination : destinations) {\n-            //TODO: should these be two seperate metadata attributes?\n+            //TODO: should these be two separate metadata attributes?\n             if(destination.getJndiName() != null) {\n                 eeModuleDescription.addMessageDestination(destination.getName(), destination.getJndiName());\n             } else if(destination.getLookupName() != null) {"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/deployment/processors/dd/DeploymentDescriptorMethodProcessor.java","diff":"@@ -52,7 +52,7 @@\n import static org.jboss.as.ejb3.EjbMessages.MESSAGES;\n \n /**\n- * Deployment descriptor that resolves interceptor methods definined in ejb-jar.xml that could not be resolved at\n+ * Deployment descriptor that resolves interceptor methods defined in ejb-jar.xml that could not be resolved at\n  * DD parse time.\n  *\n  * @author Stuart Douglas"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/deployment/processors/dd/InterceptorClassDeploymentDescriptorProcessor.java","diff":"@@ -82,15 +82,15 @@ public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentU\n \n             AroundTimeoutsMetaData aroundTimeouts = interceptor.getAroundTimeouts();\n             if (aroundTimeouts != null) {\n-                for (AroundTimeoutMetaData arountTimeout : aroundTimeouts) {\n+                for (AroundTimeoutMetaData aroundTimeout : aroundTimeouts) {\n                     final InterceptorClassDescription.Builder builder = InterceptorClassDescription.builder();\n-                    String methodName = arountTimeout.getMethodName();\n+                    String methodName = aroundTimeout.getMethodName();\n                     MethodIdentifier methodIdentifier = MethodIdentifier.getIdentifier(Object.class, methodName, InvocationContext.class);\n                     builder.setAroundTimeout(methodIdentifier);\n-                    if (arountTimeout.getClassName() == null || arountTimeout.getClassName().isEmpty()) {\n+                    if (aroundTimeout.getClassName() == null || aroundTimeout.getClassName().isEmpty()) {\n                         eeModuleDescription.addInterceptorMethodOverride(interceptorClassName, builder.build());\n                     } else {\n-                        eeModuleDescription.addInterceptorMethodOverride(arountTimeout.getClassName(), builder.build());\n+                        eeModuleDescription.addInterceptorMethodOverride(aroundTimeout.getClassName(), builder.build());\n                     }\n                 }\n             }"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/deployment/processors/merging/AsynchronousMergingProcessor.java","diff":"@@ -61,7 +61,7 @@\n import org.jboss.msc.service.ServiceName;\n import static org.jboss.as.ejb3.EjbMessages.MESSAGES;\n /**\n- * Merging processor that handles EJB asyn methods, and adds a configurator to configure any that are found.\n+ * Merging processor that handles EJB async methods, and adds a configurator to configure any that are found.\n  *\n  * @author Stuart Douglas\n  */\n@@ -97,9 +97,9 @@ protected void handleDeploymentDescriptor(final DeploymentUnit deploymentUnit, f\n         if (data != null) {\n             if (data instanceof SessionBean31MetaData) {\n                 final SessionBean31MetaData sessionBeanData = (SessionBean31MetaData) data;\n-                final AsyncMethodsMetaData asyn = sessionBeanData.getAsyncMethods();\n-                if (asyn != null) {\n-                    for (AsyncMethodMetaData method : asyn) {\n+                final AsyncMethodsMetaData async = sessionBeanData.getAsyncMethods();\n+                if (async != null) {\n+                    for (AsyncMethodMetaData method : async) {\n                         final Collection<Method> methods = MethodResolutionUtils.resolveMethods(method.getMethodName(), method.getMethodParams(), componentClass, deploymentReflectionIndex);\n                         for(final Method m : methods ) {\n                             description.addAsynchronousMethod(MethodIdentifier.getIdentifierForMethod(m));"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/deployment/processors/merging/HomeViewMergingProcessor.java","diff":"@@ -44,7 +44,7 @@\n import java.util.Collection;\n import static org.jboss.as.ejb3.EjbMessages.MESSAGES;\n /**\n- * Merging procesor for home and local home views\n+ * Merging processor for home and local home views\n  *\n  * @author Stuart Douglas\n  */\n@@ -157,7 +157,7 @@ private void processComponentConfig(final DeploymentUnit deploymentUnit, final E\n                 }\n             }\n         }\n-        //now allow the annotations to be overriden by the DD\n+        //now allow the annotations to be overridden by the DD\n         final SessionBeanMetaData descriptorData = description.getDescriptorData();\n         if (descriptorData != null) {\n "},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/deployment/processors/merging/InitMethodMergingProcessor.java","diff":"@@ -82,7 +82,7 @@ protected void handleDeploymentDescriptor(final DeploymentUnit deploymentUnit, f\n             for (Method method : index.getMethods()) {\n                 if (method.getName().startsWith(\"ejbCreate\")) {\n                     //if there is additional metadata specified for this method\n-                    //it will be overriden below\n+                    //it will be overridden below\n                     if (!description.getInitMethods().containsKey(method)) {\n                         description.addInitMethod(method, null);\n                     }"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/iiop/EjbCorbaServant.java","diff":"@@ -289,7 +289,7 @@ public OutputStream _invoke(final String opName, final InputStream in, final Res\n                         final Object[] params = op.readParams((org.omg.CORBA_2_3.portable.InputStream) in);\n \n                         if (!home && opName.equals(\"isIdentical\") && params.length == 1) {\n-                            //handle isIdential specially\n+                            //handle isIdentical specially\n                             Object val = params[0];\n                             if (val instanceof org.omg.CORBA.Object) {\n                                 retVal = handleIsIdentical((org.omg.CORBA.Object) val);"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/iiop/EjbIIOPService.java","diff":"@@ -466,7 +466,7 @@ public synchronized void stop(final StopContext context) {\n                     marshaller.finish();\n                     return beanReferenceFactory.createReferenceWithId(stream.toByteArray(), beanRepositoryIds[0]);\n                 }\n-                throw new RuntimeException(\"Unkown locator type \" + locator);\n+                throw new RuntimeException(\"Unknown locator type \" + locator);\n             } else {\n                 throw new IllegalArgumentException(\"Provided locator \" + locator + \" was not for EJB \" + ejbComponent);\n             }"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/iiop/EjbIIOPTransactionInterceptor.java","diff":"@@ -30,7 +30,7 @@ public Object processInvocation(final InterceptorContext invocation) throws Exce\n             final EJBComponent component = (EJBComponent) invocation.getPrivateData(Component.class);\n \n             //for timer invocations there is no view, so the methodInf is attached directly\n-            //to the context. Otherwise we retrive it from the invoked view\n+            //to the context. Otherwise we retrieve it from the invoked view\n             MethodIntf methodIntf = invocation.getPrivateData(MethodIntf.class);\n             if (methodIntf == null) {\n                 final ComponentView componentView = invocation.getPrivateData(ComponentView.class);"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/iiop/POARegistry.java","diff":"@@ -42,7 +42,7 @@\n import org.omg.PortableServer.ServantRetentionPolicyValue;\n \n /**\n- * Registry that maintains 2 different servant resistries\n+ * Registry that maintains 2 different servant registries\n  * <p/>\n  * <ul>\n  * <li>a <code>ServantRegistry</code> with a transient POA per servant;</li>"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/remote/DescriptorBasedEJBClientContextService.java","diff":"@@ -84,8 +84,8 @@ public synchronized void start(StartContext startContext) throws StartException\n         }\n         // now process the remoting receivers\n         final Collection<Connection> connections = this.createRemotingConnections();\n-        for (final Connection conection : connections) {\n-            context.registerConnection(conection);\n+        for (final Connection connection : connections) {\n+            context.registerConnection(connection);\n         }\n         logger.debug(\"Added \" + connections.size() + \" remoting EJB receivers to descriptor based EJB client context named \" + startContext.getController().getName());\n         this.ejbClientContext = context;"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/remote/EJBRemoteConnectorService.java","diff":"@@ -100,7 +100,7 @@ public void start(StartContext context) throws StartException {\n         final ServiceContainer serviceContainer = context.getController().getServiceContainer();\n         final ServiceController streamServerServiceController = serviceContainer.getRequiredService(this.remotingConnectorServiceName);\n         final AbstractStreamServerService streamServerService = (AbstractStreamServerService) streamServerServiceController.getService();\n-        // we can only work off a remoting connector which is backed by a socketbinding\n+        // we can only work off a remoting connector which is backed by a socket binding\n         if (streamServerService instanceof InjectedSocketBindingStreamServerService) {\n             this.remotingServer = (InjectedSocketBindingStreamServerService) streamServerService;\n         }\n@@ -244,12 +244,12 @@ public void handleMessage(Channel channel, MessageInputStream messageInputStream\n                         final DeploymentRepository deploymentRepository = EJBRemoteConnectorService.this.deploymentRepositoryInjectedValue.getValue();\n                         final RegistryCollector<String, List<ClientMapping>> clientMappingRegistryCollector = EJBRemoteConnectorService.this.clusterRegistryCollector.getValue();\n                         // populate the client-mapping cache which will be used for getting the client-mapping(s)\n-                        // of each node's EJB remoting connector's socketbinding. The population the cache is done lazily\n+                        // of each node's EJB remoting connector's socket binding. The population the cache is done lazily\n                         // to handle the case where the cache service isn't started until the EJBs accessing that cache are\n                         // deployed. The populate method is smart enough to populate the cache only once even if invoked multiple\n                         // times\n                         //EJBRemoteConnectorService.this.populateClientMappingsCache(serviceContainer);\n-                        // the registry will be available when the clustering subsytem is present, so get the value optionally\n+                        // the registry will be available when the clustering subsystem is present, so get the value optionally\n                         final VersionOneProtocolChannelReceiver receiver = new VersionOneProtocolChannelReceiver(channel, deploymentRepository,\n                                 EJBRemoteConnectorService.this.ejbRemoteTransactionsRepositoryInjectedValue.getValue(), clientMappingRegistryCollector,\n                                 marshallerFactory, executorService.getValue());"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/remote/EJBRemoteTransactionsViewConfigurator.java","diff":"@@ -31,7 +31,7 @@\n import org.jboss.as.server.deployment.DeploymentUnitProcessingException;\n \n /**\n- * Responsible for setting up a {@link EJBRemoteTransactionPropogatingInterceptor} for a (remote) view.\n+ * Responsible for setting up a {@link EJBRemoteTransactionPropagatingInterceptor} for a (remote) view.\n  * This view configurator does <i>not</i> check whether the view is remote or not. It's the responsibility\n  * of whoever sets up this view configurator to make sure that the view being configured is a remote view\n  *\n@@ -42,10 +42,10 @@\n     @Override\n     public void configure(final DeploymentPhaseContext context, final ComponentConfiguration componentConfiguration,\n                           final ViewDescription viewDescription, final ViewConfiguration viewConfiguration) throws DeploymentUnitProcessingException {\n-        // setup a view interceptor which propogates remote transactions. This interceptor\n+        // setup a view interceptor which propagates remote transactions. This interceptor\n         // should appear before the CMT/BMT interceptors so that the latter interceptors know about any existing\n         // tx for the invocation\n-        viewConfiguration.addViewInterceptor(EJBRemoteTransactionPropogatingInterceptorFactory.INSTANCE, InterceptorOrder.View.REMOTE_TRANSACTION_PROPOGATION_INTERCEPTOR);\n+        viewConfiguration.addViewInterceptor(EJBRemoteTransactionPropagatingInterceptorFactory.INSTANCE, InterceptorOrder.View.REMOTE_TRANSACTION_PROPAGATION_INTERCEPTOR);\n \n     }\n }"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/remote/EJBRemotingConnectorClientMappingsEntryProviderService.java","diff":"@@ -65,7 +65,7 @@ public void start(StartContext context) throws StartException {\n         final ServiceContainer serviceContainer = context.getController().getServiceContainer();\n         final ServiceController streamServerServiceController = serviceContainer.getRequiredService(this.remotingConnectorServiceName);\n         final AbstractStreamServerService streamServerService = (AbstractStreamServerService) streamServerServiceController.getService();\n-        // we can only work off a remoting connector which is backed by a socketbinding\n+        // we can only work off a remoting connector which is backed by a socket binding\n         if (streamServerService instanceof InjectedSocketBindingStreamServerService) {\n             this.remotingServer = (InjectedSocketBindingStreamServerService) streamServerService;\n         }"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/remote/LocalEjbReceiver.java","diff":"@@ -119,7 +119,7 @@ protected void processInvocation(final EJBClientInvocationContext invocation, fi\n         paramConfig.setClassCloner(new ClassLoaderClassCloner(ejb.getDeploymentClassLoader()));\n         final ObjectCloner parameterCloner = ObjectCloners.getSerializingObjectClonerFactory().createCloner(paramConfig);\n \n-        //TODO: this is not very efficent\n+        //TODO: this is not very efficient\n         final Method method = view.getMethod(invocation.getInvokedMethod().getName(), DescriptorUtils.methodDescriptor(invocation.getInvokedMethod()));\n \n         final boolean async = view.isAsynchronous(method);"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/remote/protocol/versionone/VersionOneProtocolChannelReceiver.java","diff":"@@ -187,7 +187,7 @@ public void listenerAdded(DeploymentRepository repository) {\n         final Map<DeploymentModuleIdentifier, ModuleDeployment> availableModules = this.deploymentRepository.getModules();\n         if (availableModules != null && !availableModules.isEmpty()) {\n             try {\n-                logger.debug(\"Sending initial module availabilty message, containing \" + availableModules.size() + \" module(s) to channel \" + this.channel);\n+                logger.debug(\"Sending initial module availability message, containing \" + availableModules.size() + \" module(s) to channel \" + this.channel);\n                 this.sendModuleAvailability(availableModules.keySet().toArray(new DeploymentModuleIdentifier[availableModules.size()]));\n             } catch (IOException e) {\n                 logger.warn(\"Could not send initial module availability report to channel \" + this.channel, e);"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/remote/protocol/versionone/XidTransactionBeforeCompletionTask.java","diff":"@@ -59,7 +59,7 @@ protected void manageTransaction() throws Throwable {\n             // do beforeCompletion()\n             subordinateTransaction.doBeforeCompletion();\n         } finally {\n-            // disassociate the tx that was asssociated (resumed) on this thread.\n+            // disassociate the tx that was associated (resumed) on this thread.\n             // This needs to be done explicitly because the SubOrdinationManager isn't responsible\n             // for clearing the tx context from the thread\n             this.transactionsRepository.getTransactionManager().suspend();"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/remote/protocol/versionone/XidTransactionCommitTask.java","diff":"@@ -131,7 +131,7 @@ protected void manageTransaction() throws Throwable {\n \n \n         } finally {\n-            // disassociate the tx that was asssociated (resumed) on this thread.\n+            // disassociate the tx that was associated (resumed) on this thread.\n             // This needs to be done explicitly because the SubOrdinationManager isn't responsible\n             // for clearing the tx context from the thread\n             this.transactionsRepository.getTransactionManager().suspend();"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/remote/protocol/versionone/XidTransactionForgetTask.java","diff":"@@ -69,7 +69,7 @@ protected void manageTransaction() throws Throwable {\n \n         } finally {\n             SubordinationManager.getTransactionImporter().removeImportedTransaction(xid);\n-            // disassociate the tx that was asssociated (resumed) on this thread.\n+            // disassociate the tx that was associated (resumed) on this thread.\n             // This needs to be done explicitly because the SubOrdinationManager isn't responsible\n             // for clearing the tx context from the thread\n             this.transactionsRepository.getTransactionManager().suspend();"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/remote/protocol/versionone/XidTransactionPrepareTask.java","diff":"@@ -147,7 +147,7 @@ private int prepareTransaction() throws Throwable {\n                     throw new XAException(XAException.XA_RBOTHER);\n             }\n         } finally {\n-            // disassociate the tx that was asssociated (resumed) on this thread.\n+            // disassociate the tx that was associated (resumed) on this thread.\n             // This needs to be done explicitly because the SubOrdinationManager isn't responsible\n             // for clearing the tx context from the thread\n             this.transactionsRepository.getTransactionManager().suspend();"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/remote/protocol/versionone/XidTransactionRollbackTask.java","diff":"@@ -106,7 +106,7 @@ protected void manageTransaction() throws Throwable {\n \n             throw new XAException(XAException.XAER_RMERR);\n         } finally {\n-            // disassociate the tx that was asssociated (resumed) on this thread.\n+            // disassociate the tx that was associated (resumed) on this thread.\n             // This needs to be done explicitly because the SubOrdinationManager isn't responsible\n             // for clearing the tx context from the thread\n             this.transactionsRepository.getTransactionManager().suspend();"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/subsystem/EJB3RemoteServiceAdd.java","diff":"@@ -124,7 +124,7 @@ protected void performBoottime(OperationContext context, ModelNode operation, Mo\n         // TODO: Externalize (expose via management API if needed) the version and the marshalling strategy\n         final EJBRemoteConnectorService ejbRemoteConnectorService = new EJBRemoteConnectorService((byte) 0x01, new String[]{\"river\"}, remotingServerServiceName);\n         final ServiceBuilder<EJBRemoteConnectorService> ejbRemoteConnectorServiceBuilder = serviceTarget.addService(EJBRemoteConnectorService.SERVICE_NAME, ejbRemoteConnectorService);\n-        // add dependency on the Remoting subsytem endpoint\n+        // add dependency on the Remoting subsystem endpoint\n         ejbRemoteConnectorServiceBuilder.addDependency(RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, ejbRemoteConnectorService.getEndpointInjector());\n         // add dependency on the remoting server (which allows remoting connector to connect to it)\n         ejbRemoteConnectorServiceBuilder.addDependency(remotingServerServiceName);"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/subsystem/EJB3Subsystem11Parser.java","diff":"@@ -428,10 +428,10 @@ private void parseStrictMaxPool(final XMLExtendedStreamReader reader, List<Model\n                 case MAX_POOL_SIZE:\n                     maxPoolSize = StrictMaxPoolResourceDefinition.MAX_POOL_SIZE.parse(value, reader).asInt();\n                     break;\n-                case INSTANCE_AQUISITION_TIMEOUT:\n+                case INSTANCE_ACQUISITION_TIMEOUT:\n                     timeout = StrictMaxPoolResourceDefinition.INSTANCE_ACQUISITION_TIMEOUT.parse(value, reader).asLong();\n                     break;\n-                case INSTANCE_AQUISITION_TIMEOUT_UNIT:\n+                case INSTANCE_ACQUISITION_TIMEOUT_UNIT:\n                     unit = StrictMaxPoolResourceDefinition.INSTANCE_ACQUISITION_TIMEOUT_UNIT.parse(value, reader).asString();\n                     break;\n "},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/subsystem/EJB3Subsystem12Parser.java","diff":"@@ -804,10 +804,10 @@ private void parseStrictMaxPool(final XMLExtendedStreamReader reader, List<Model\n                 case MAX_POOL_SIZE:\n                     maxPoolSize = StrictMaxPoolResourceDefinition.MAX_POOL_SIZE.parse(value, reader).asInt();\n                     break;\n-                case INSTANCE_AQUISITION_TIMEOUT:\n+                case INSTANCE_ACQUISITION_TIMEOUT:\n                     timeout = StrictMaxPoolResourceDefinition.INSTANCE_ACQUISITION_TIMEOUT.parse(value, reader).asLong();\n                     break;\n-                case INSTANCE_AQUISITION_TIMEOUT_UNIT:\n+                case INSTANCE_ACQUISITION_TIMEOUT_UNIT:\n                     unit = StrictMaxPoolResourceDefinition.INSTANCE_ACQUISITION_TIMEOUT_UNIT.parse(value, reader).asString();\n                     break;\n "},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/subsystem/EJB3SubsystemAdd.java","diff":"@@ -153,7 +153,7 @@ protected void performBoottime(final OperationContext context, ModelNode operati\n         //setup IIOP related stuff\n         //This goes here rather than in EJB3IIOPAdd as it affects the server when it is acting as an iiop client\n         //setup our dynamic stub factory\n-        DelegatingStubFactoryFactory.setOverridenDynamicFactory(new DynamicStubFactoryFactory());\n+        DelegatingStubFactoryFactory.setOverriddenDynamicFactory(new DynamicStubFactoryFactory());\n \n         //setup the substitution service, that translates between ejb proxies and IIOP stubs\n         final RemoteObjectSubstitutionService substitutionService = new RemoteObjectSubstitutionService();\n@@ -288,7 +288,7 @@ protected void execute(DeploymentProcessorTarget processorTarget) {\n         if (!appclient) {\n             final EJBUtilities utilities = new EJBUtilities();\n             newControllers.add(serviceTarget.addService(EJBUtilities.SERVICE_NAME, utilities)\n-                    .addDependency(ConnectorServices.RA_REPOSISTORY_SERVICE, ResourceAdapterRepository.class, utilities.getResourceAdapterRepositoryInjector())\n+                    .addDependency(ConnectorServices.RA_REPOSITORY_SERVICE, ResourceAdapterRepository.class, utilities.getResourceAdapterRepositoryInjector())\n                     .addDependency(SimpleSecurityManagerService.SERVICE_NAME, SimpleSecurityManager.class, utilities.getSecurityManagerInjector())\n                     .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, TransactionManager.class, utilities.getTransactionManagerInjector())\n                     .addDependency(TxnServices.JBOSS_TXN_SYNCHRONIZATION_REGISTRY, TransactionSynchronizationRegistry.class, utilities.getTransactionSynchronizationRegistryInjector())\n@@ -309,7 +309,7 @@ protected void execute(DeploymentProcessorTarget processorTarget) {\n     }\n \n     private void addRemoteInvocationServices(final OperationContext context, final List<ServiceController<?>> newControllers,\n-                                             final ModelNode ejbSubsytemModel, final boolean appclient) throws OperationFailedException {\n+                                             final ModelNode ejbSubsystemModel, final boolean appclient) throws OperationFailedException {\n \n         final ServiceTarget serviceTarget = context.getServiceTarget();\n         // Add the tccl based client context selector\n@@ -329,7 +329,7 @@ private void addRemoteInvocationServices(final OperationContext context, final L\n         if (!appclient) {\n             // get the node name\n             final String nodeName = SecurityActions.getSystemProperty(ServerEnvironment.NODE_NAME);\n-            //the default spec compliant EJB reciever\n+            //the default spec compliant EJB receiver\n             final LocalEjbReceiver byValueLocalEjbReceiver = new LocalEjbReceiver(nodeName, false);\n             newControllers.add(serviceTarget.addService(LocalEjbReceiver.BY_VALUE_SERVICE_NAME, byValueLocalEjbReceiver)\n                     .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byValueLocalEjbReceiver.getDeploymentRepository())\n@@ -344,7 +344,7 @@ private void addRemoteInvocationServices(final OperationContext context, final L\n                     .install());\n \n             // setup the default local ejb receiver service\n-            EJBRemoteInvocationPassByValueWriteHandler.INSTANCE.updateDefaultLocalEJBReceiverService(context, ejbSubsytemModel, newControllers);\n+            EJBRemoteInvocationPassByValueWriteHandler.INSTANCE.updateDefaultLocalEJBReceiverService(context, ejbSubsystemModel, newControllers);\n             // add the default local ejb receiver to the client context\n             clientContextServiceBuilder.addDependency(LocalEjbReceiver.DEFAULT_LOCAL_EJB_RECEIVER_SERVICE_NAME, LocalEjbReceiver.class, clientContextService.getDefaultLocalEJBReceiverInjector());\n         }"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/subsystem/EJB3SubsystemXMLAttribute.java","diff":"@@ -50,8 +50,8 @@\n \n     IDLE_TIMEOUT(\"idle-timeout\"),\n     IDLE_TIMEOUT_UNIT(\"idle-timeout-unit\"),\n-    INSTANCE_AQUISITION_TIMEOUT(\"instance-acquisition-timeout\"),\n-    INSTANCE_AQUISITION_TIMEOUT_UNIT(\"instance-acquisition-timeout-unit\"),\n+    INSTANCE_ACQUISITION_TIMEOUT(\"instance-acquisition-timeout\"),\n+    INSTANCE_ACQUISITION_TIMEOUT_UNIT(\"instance-acquisition-timeout-unit\"),\n \n     KEEPALIVE_TIME(\"keepalive-time\"),\n "},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/subsystem/StrictMaxPoolResourceDefinition.java","diff":"@@ -60,7 +60,7 @@\n                     .build();\n     public static final SimpleAttributeDefinition INSTANCE_ACQUISITION_TIMEOUT =\n             new SimpleAttributeDefinitionBuilder(EJB3SubsystemModel.INSTANCE_ACQUISITION_TIMEOUT, ModelType.LONG, true)\n-                    .setXmlName(EJB3SubsystemXMLAttribute.INSTANCE_AQUISITION_TIMEOUT.getLocalName())\n+                    .setXmlName(EJB3SubsystemXMLAttribute.INSTANCE_ACQUISITION_TIMEOUT.getLocalName())\n                     .setDefaultValue(new ModelNode().set(StrictMaxPoolConfig.DEFAULT_TIMEOUT))\n                     .setAllowExpression(true)\n                     .setValidator(new LongRangeValidator(1, Integer.MAX_VALUE, true, true))\n@@ -68,7 +68,7 @@\n                     .build();\n     public static final SimpleAttributeDefinition INSTANCE_ACQUISITION_TIMEOUT_UNIT =\n             new SimpleAttributeDefinitionBuilder(EJB3SubsystemModel.INSTANCE_ACQUISITION_TIMEOUT_UNIT, ModelType.STRING, true)\n-                    .setXmlName(EJB3SubsystemXMLAttribute.INSTANCE_AQUISITION_TIMEOUT_UNIT.getLocalName())\n+                    .setXmlName(EJB3SubsystemXMLAttribute.INSTANCE_ACQUISITION_TIMEOUT_UNIT.getLocalName())\n                     .setValidator(TimeUnitValidator.ANY_OPTIONAL)\n                     .setDefaultValue(new ModelNode().set(StrictMaxPoolConfig.DEFAULT_TIMEOUT_UNIT.name()))\n                     .setFlags(AttributeAccess.Flag.RESTART_NONE)"},{"filename":"ejb3/src/main/java/org/jboss/as/ejb3/timerservice/CalendarTimer.java","diff":"@@ -53,7 +53,7 @@\n \n     /**\n      * Represents whether this is an auto-timer or a normal\n-     * programatically created timer\n+     * programmatically created timer\n      */\n     private final boolean autoTimer;\n "},{"filename":"host-controller/src/main/java/org/jboss/as/domain/controller/LocalHostControllerInfo.java","diff":"@@ -105,7 +105,7 @@\n      * Gets the port of the remote domain controller\n      * @return the port number\n      */\n-    int getRemoteDomainControllertPort();\n+    int getRemoteDomainControllerPort();\n \n     /**\n      * Gets the current state of the host controller process."},{"filename":"host-controller/src/main/java/org/jboss/as/domain/controller/operations/ApplyRemoteMasterDomainModelHandler.java","diff":"@@ -90,7 +90,7 @@\n public class ApplyRemoteMasterDomainModelHandler implements OperationStepHandler, DescriptionProvider {\n     public static final String OPERATION_NAME = \"apply-remote-domain-model\";\n \n-    private final Set<String> appliedExensions = new HashSet<String>();\n+    private final Set<String> appliedExtensions = new HashSet<String>();\n     private final HostFileRepository fileRepository;\n     private final ContentRepository contentRepository;\n     private final ExtensionRegistry extensionRegistry;\n@@ -135,8 +135,8 @@ public void execute(OperationContext context, ModelNode operation) throws Operat\n             final Resource resource = getResource(resourceAddress, rootResource, context);\n             if (resourceAddress.size() == 1 && resourceAddress.getElement(0).getKey().equals(EXTENSION)) {\n                 final String module = resourceAddress.getElement(0).getValue();\n-                if (!appliedExensions.contains(module)) {\n-                    appliedExensions.add(module);\n+                if (!appliedExtensions.contains(module)) {\n+                    appliedExtensions.add(module);\n                     initializeExtension(module);\n                 }\n             }"},{"filename":"host-controller/src/main/java/org/jboss/as/domain/controller/operations/DomainServerLifecycleHandlers.java","diff":"@@ -86,11 +86,11 @@ public static void registerServerGroupHandlers(ManagementResourceRegistration re\n         registration.registerOperationHandler(RestartServersLifecycleHandler.OPERATION_NAME, RestartServersLifecycleHandler.SERVER_GROUP_INSTANCE, RestartServersLifecycleHandler.SERVER_GROUP_INSTANCE);\n     }\n \n-    private abstract static class AbstractHackLifecyleHandler implements OperationStepHandler, DescriptionProvider {\n+    private abstract static class AbstractHackLifecycleHandler implements OperationStepHandler, DescriptionProvider {\n         volatile ServerInventory serverInventory;\n         final boolean domain;\n \n-        protected AbstractHackLifecyleHandler(final boolean domain) {\n+        protected AbstractHackLifecycleHandler(final boolean domain) {\n             this.domain = domain;\n         }\n \n@@ -126,7 +126,7 @@ String getServerGroupName(final ModelNode operation) {\n \n     }\n \n-    private static class StopServersLifecycleHandler extends AbstractHackLifecyleHandler {\n+    private static class StopServersLifecycleHandler extends AbstractHackLifecycleHandler {\n         static final String OPERATION_NAME = STOP_SERVERS_NAME;\n         static final StopServersLifecycleHandler DOMAIN_INSTANCE = new StopServersLifecycleHandler(true);\n         static final StopServersLifecycleHandler SERVER_GROUP_INSTANCE = new StopServersLifecycleHandler(false);\n@@ -165,7 +165,7 @@ public ModelNode getModelDescription(Locale locale) {\n         }\n     }\n \n-    private static class StartServersLifecycleHandler extends AbstractHackLifecyleHandler {\n+    private static class StartServersLifecycleHandler extends AbstractHackLifecycleHandler {\n         static final String OPERATION_NAME = START_SERVERS_NAME;\n         static final StartServersLifecycleHandler DOMAIN_INSTANCE = new StartServersLifecycleHandler(true);\n         static final StartServersLifecycleHandler SERVER_GROUP_INSTANCE = new StartServersLifecycleHandler(false);\n@@ -212,7 +212,7 @@ public ModelNode getModelDescription(Locale locale) {\n         }\n     }\n \n-    private static class RestartServersLifecycleHandler extends AbstractHackLifecyleHandler {\n+    private static class RestartServersLifecycleHandler extends AbstractHackLifecycleHandler {\n         static final String OPERATION_NAME = RESTART_SERVERS_NAME;\n         static final RestartServersLifecycleHandler DOMAIN_INSTANCE = new RestartServersLifecycleHandler(true);\n         static final RestartServersLifecycleHandler SERVER_GROUP_INSTANCE = new RestartServersLifecycleHandler(false);"},{"filename":"host-controller/src/main/java/org/jboss/as/domain/controller/operations/coordination/OperationCoordinatorStepHandler.java","diff":"@@ -95,7 +95,7 @@ void execute(OperationContext context, ModelNode operation) throws OperationFail\n         if (!localHostControllerInfo.isMasterDomainController()\n                 && !routing.isLocalOnly(localHostControllerInfo.getLocalHostName())) {\n             // We cannot handle this ourselves\n-            routetoMasterDomainController(context, operation);\n+            routeToMasterDomainController(context, operation);\n         }\n         else if (routing.getSingleHost() != null && !localHostControllerInfo.getLocalHostName().equals(routing.getSingleHost())) {\n             if (HOST_CONTROLLER_LOGGER.isTraceEnabled()) {\n@@ -127,7 +127,7 @@ private ExecutorService getExecutorService() {\n         return executorService == null ? Executors.newSingleThreadExecutor() : executorService;\n     }\n \n-    private void routetoMasterDomainController(OperationContext context, ModelNode operation) {\n+    private void routeToMasterDomainController(OperationContext context, ModelNode operation) {\n         // Per discussion on 2011/03/07, routing requests from a slave to the\n         // master may overly complicate the security infrastructure. Therefore,\n         // the ability to do this is being disabled until it's clear that it's"},{"filename":"host-controller/src/main/java/org/jboss/as/domain/controller/operations/deployment/DeploymentAddHandler.java","diff":"@@ -94,7 +94,7 @@ public DeploymentAddHandler() {\n     /**\n      * Constructor for a master Host Controller\n      *\n-     * @param contentRepository the master content repository. If {@code null} this handler will function as a slave hander would.\n+     * @param contentRepository the master content repository. If {@code null} this handler will function as a slave handler would.\n      */\n     public DeploymentAddHandler(final ContentRepository contentRepository) {\n         this.contentRepository = contentRepository;"},{"filename":"host-controller/src/main/java/org/jboss/as/domain/controller/operations/deployment/DeploymentUploadBytesHandler.java","diff":"@@ -56,7 +56,7 @@ public DeploymentUploadBytesHandler() {\n     /**\n      * Constructor for a master Host Controller\n      *\n-     * @param repository the master content repository. If {@code null} this handler will function as a slave hander would.\n+     * @param repository the master content repository. If {@code null} this handler will function as a slave handler would.\n      */\n     public DeploymentUploadBytesHandler(final ContentRepository repository) {\n         super(repository);"},{"filename":"host-controller/src/main/java/org/jboss/as/domain/controller/operations/deployment/DeploymentUploadURLHandler.java","diff":"@@ -58,7 +58,7 @@ public DeploymentUploadURLHandler() {\n     /**\n      * Constructor for a master Host Controller\n      *\n-     * @param repository the master content repository. If {@code null} this handler will function as a slave hander would.\n+     * @param repository the master content repository. If {@code null} this handler will function as a slave handler would.\n      */\n     public DeploymentUploadURLHandler(final ContentRepository repository) {\n         super(repository);"},{"filename":"host-controller/src/main/java/org/jboss/as/host/controller/HostCommunicationServices.java","diff":"@@ -31,8 +31,8 @@\n  */\n class HostCommunicationServices {\n \n-    static DomainServerMain.HostControllerCommunicationActivator createServerCommuncationActivator(final InetSocketAddress managementSocket, final String serverName, final String serverProcessName,\n-            final byte[] authKey, final boolean managementSubsystemEndpoint) {\n+    static DomainServerMain.HostControllerCommunicationActivator createServerCommunicationActivator(final InetSocketAddress managementSocket, final String serverName, final String serverProcessName,\n+                                                                                                    final byte[] authKey, final boolean managementSubsystemEndpoint) {\n         return new DomainServerMain.HostControllerCommunicationActivator(managementSocket, serverName, serverProcessName, authKey, managementSubsystemEndpoint);\n     }\n "},{"filename":"host-controller/src/main/java/org/jboss/as/host/controller/HostControllerLogger.java","diff":"@@ -299,7 +299,7 @@\n     void stoppingServer(String serverName);\n \n     /**\n-     * Logs a warning message indicating the server is not in the exepected state.\n+     * Logs a warning message indicating the server is not in the expected state.\n      *\n      * @param serverName the name of the server.\n      * @param expected   the expected state."},{"filename":"host-controller/src/main/java/org/jboss/as/host/controller/ManagedServer.java","diff":"@@ -284,7 +284,7 @@ public void execute(final ManagedServer server) throws Exception {\n                         PathAddress.pathAddress(PathElement.pathElement(HOST, hostControllerName), serverPath),\n                         ProxyOperationAddressTranslator.SERVER);\n             }\n-        // TODO we just check that we are in the correct state, perhaps introuce a new state\n+        // TODO we just check that we are in the correct state, perhaps introduce a new state\n         }, InternalState.SERVER_STARTING, InternalState.SERVER_STARTING);\n         return proxyController;\n     }\n@@ -624,7 +624,7 @@ public void execute(ManagedServer server) throws Exception {\n             // Get the standalone boot updates\n             final List<ModelNode> bootUpdates = bootConfiguration.getBootUpdates();\n             // Send std.in\n-            final ServiceActivator hostControllerCommActivator = HostCommunicationServices.createServerCommuncationActivator(managementSocket, serverName, serverProcessName, authKey, bootConfiguration.isManagementSubsystemEndpoint());\n+            final ServiceActivator hostControllerCommActivator = HostCommunicationServices.createServerCommunicationActivator(managementSocket, serverName, serverProcessName, authKey, bootConfiguration.isManagementSubsystemEndpoint());\n             final ServerStartTask startTask = new ServerStartTask(hostControllerName, serverName, 0, Collections.<ServiceActivator>singletonList(hostControllerCommActivator), bootUpdates);\n             final Marshaller marshaller = MARSHALLER_FACTORY.createMarshaller(CONFIG);\n             final OutputStream os = processControllerClient.sendStdin(serverProcessName);"},{"filename":"host-controller/src/main/java/org/jboss/as/host/controller/RemoteDomainConnectionService.java","diff":"@@ -180,7 +180,7 @@ public synchronized void register() throws IOException {\n                     throw MESSAGES.connectionToMasterTimeout(e, retries, timeout);\n                 }\n                 try {\n-                    HostControllerLogger.ROOT_LOGGER.cannotConnect(localHostInfo.getRemoteDomainControllerHost(), localHostInfo.getRemoteDomainControllertPort());\n+                    HostControllerLogger.ROOT_LOGGER.cannotConnect(localHostInfo.getRemoteDomainControllerHost(), localHostInfo.getRemoteDomainControllerPort());\n                     ReconnectPolicy.CONNECT.wait(retries);\n                 } catch (InterruptedException ie) {\n                     throw MESSAGES.connectionToMasterInterrupted();\n@@ -261,7 +261,7 @@ public synchronized void start(StartContext context) throws StartException {\n \n             // Gather the required information to connect to the remote DC\n             final ProtocolChannelClient.Configuration configuration = new ProtocolChannelClient.Configuration();\n-            configuration.setUri(new URI(\"remote://\" + NetworkUtils.formatPossibleIpv6Address(localHostInfo.getRemoteDomainControllerHost()) + \":\" + localHostInfo.getRemoteDomainControllertPort()));\n+            configuration.setUri(new URI(\"remote://\" + NetworkUtils.formatPossibleIpv6Address(localHostInfo.getRemoteDomainControllerHost()) + \":\" + localHostInfo.getRemoteDomainControllerPort()));\n             configuration.setEndpoint(endpointInjector.getValue());\n \n             final SecurityRealm realm = securityRealmInjector.getOptionalValue();"},{"filename":"host-controller/src/main/java/org/jboss/as/host/controller/operations/LocalHostControllerInfoImpl.java","diff":"@@ -115,7 +115,7 @@ public String getRemoteDomainControllerHost() {\n         return remoteDcHost;\n     }\n \n-    public int getRemoteDomainControllertPort() {\n+    public int getRemoteDomainControllerPort() {\n         return remoteDcPort;\n     }\n "},{"filename":"host-controller/src/main/java/org/jboss/as/host/controller/parsing/HostXml.java","diff":"@@ -776,7 +776,7 @@ private void parseRemoteDomainController1_1(final XMLExtendedStreamReader reader\n             final Element element = Element.forName(reader.getLocalName());\n             switch (element) {\n                 case IGNORED_RESOURCE: {\n-                    parseIgnoredResoure(reader, address, expectedNs, list, types);\n+                    parseIgnoredResource(reader, address, expectedNs, list, types);\n                     break;\n                 }\n                 default:\n@@ -844,7 +844,7 @@ private void parseRemoteDomainControllerAttributes(final XMLExtendedStreamReader\n         list.add(update);\n     }\n \n-    private void parseIgnoredResoure(final XMLExtendedStreamReader reader, final ModelNode address,\n+    private void parseIgnoredResource(final XMLExtendedStreamReader reader, final ModelNode address,\n             Namespace expectedNs, final List<ModelNode> list, final Set<String> foundTypes) throws XMLStreamException {\n \n         ModelNode op = new ModelNode();"},{"filename":"host-controller/src/test/java/org/jboss/as/domain/controller/operations/AbstractOperationTestCase.java","diff":"@@ -123,7 +123,7 @@ public String getRemoteDomainControllerHost() {\n             return null;\n         }\n \n-        public int getRemoteDomainControllertPort() {\n+        public int getRemoteDomainControllerPort() {\n             return 0;\n         }\n "},{"filename":"jacorb/src/main/java/org/jboss/as/jacorb/JacORBSubsystemParser.java","diff":"@@ -302,7 +302,7 @@ private void parseORBConfig_1_1(XMLExtendedStreamReader reader, ModelNode node)\n \n     /**\n      * <p>\n-     * Parses the ORB {@code connection} section of the JacORB susbsytem configuration.\n+     * Parses the ORB {@code connection} section of the JacORB subsystem configuration.\n      * </p>\n      *\n      * @param reader the {@code XMLExtendedStreamReader} used to read the configuration XML.\n@@ -410,7 +410,7 @@ private void parsePOAConfig(XMLExtendedStreamReader reader, ModelNode node) thro\n \n     /**\n      * <p>\n-     * Parses the {@code naming} section of the JacORB susbsytem configuration.\n+     * Parses the {@code naming} section of the JacORB subsystem configuration.\n      * </p>\n      *\n      * @param reader the {@code XMLExtendedStreamReader} used to read the configuration XML.\n@@ -522,7 +522,7 @@ private void parseSecurityConfig_1_1(XMLExtendedStreamReader reader, ModelNode n\n \n     /**\n      * <p>\n-     * Parses the {@code properties} section of the JacORB subssytem configuration.\n+     * Parses the {@code properties} section of the JacORB subsystem configuration.\n      * </p>\n      *\n      * @param reader the {@code XMLExtendedStreamReader} used to read the configuration XML.\n@@ -727,10 +727,10 @@ private void writeORBConfig(XMLExtendedStreamWriter writer, ModelNode node) thro\n \n         boolean writeORB = this.isWritable(node, JacORBSubsystemDefinitions.ORB_ATTRIBUTES);\n         boolean writeORBConnection = this.isWritable(node, JacORBSubsystemDefinitions.ORB_CONN_ATTRIBUTES);\n-        boolean writeORBInitialzers = this.isWritable(node, JacORBSubsystemDefinitions.ORB_INIT_ATTRIBUTES);\n+        boolean writeORBInitializer = this.isWritable(node, JacORBSubsystemDefinitions.ORB_INIT_ATTRIBUTES);\n \n         // if no connection or initializers properties are available, just write the orb properties (if any) in an empty element.\n-        if (!writeORBConnection && !writeORBInitialzers) {\n+        if (!writeORBConnection && !writeORBInitializer) {\n             if (writeORB) {\n                 writer.writeEmptyElement(JacORBSubsystemConstants.ORB);\n                 this.writeAttributes(writer, node, JacORBSubsystemDefinitions.ORB_ATTRIBUTES);\n@@ -744,7 +744,7 @@ private void writeORBConfig(XMLExtendedStreamWriter writer, ModelNode node) thro\n                 writer.writeEmptyElement(JacORBSubsystemConstants.ORB_CONN);\n                 this.writeAttributes(writer, node, JacORBSubsystemDefinitions.ORB_CONN_ATTRIBUTES);\n             }\n-            if (writeORBInitialzers) {\n+            if (writeORBInitializer) {\n                 writer.writeEmptyElement(JacORBSubsystemConstants.ORB_INIT);\n                 this.writeAttributes(writer, node, JacORBSubsystemDefinitions.ORB_INIT_ATTRIBUTES);\n             }"},{"filename":"jacorb/src/main/java/org/jboss/as/jacorb/ORBInitializer.java","diff":"@@ -27,7 +27,7 @@\n \n /**\n  * <p>\n- * Enumeration of {@code ORB} initializer groups. Each member contains one or more initiliazer classes that belong to a\n+ * Enumeration of {@code ORB} initializer groups. Each member contains one or more initializer classes that belong to a\n  * specific group.\n  * </p>\n  *"},{"filename":"jacorb/src/main/java/org/jboss/as/jacorb/csiv2/CSIv2Policy.java","diff":"@@ -51,7 +51,7 @@\n \n     /**\n      * <p>\n-     * Creates an instance of {@code CSIv2Policy} with the specified tagged compoonents.\n+     * Creates an instance of {@code CSIv2Policy} with the specified tagged components.\n      * </p>\n      *\n      * @param sslTaggedComponent a {@code TaggedComponent} that contains the encoded SSL info."},{"filename":"jacorb/src/main/java/org/jboss/as/jacorb/csiv2/CSIv2Util.java","diff":"@@ -384,7 +384,7 @@ public static TaggedComponent createTransportMech(IORTransportConfigMetaData tco\n      * @return the constructed {@code TransportAddress} array.\n      */\n     public static TransportAddress[] createTransportAddress(String host, int port) {\n-        // idl type is unsighned sort, so we need this trick\n+        // idl type is unsigned sort, so we need this trick\n         short short_port = (port > 32767) ? (short) (port - 65536) : (short) port;\n \n         TransportAddress ta = new TransportAddress(host, short_port);"},{"filename":"jacorb/src/main/java/org/jboss/as/jacorb/deployment/JacORBDependencyProcessor.java","diff":"@@ -49,7 +49,7 @@ public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentU\n         final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n         moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, CORBA_ID, false, false, false, false));\n         moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JAVAX_RMI_API_ID, false, false, false, false));\n-        //we need to add jacorb, as the orb is initaled from the context class loader of the deployment\n+        //we need to add jacorb, as the orb is initialized from the context class loader of the deployment\n         moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JACORB_ID, false, false, false, false));\n     }\n "},{"filename":"jacorb/src/main/java/org/jboss/as/jacorb/rmi/AttributeAnalysis.java","diff":"@@ -88,7 +88,7 @@ private AttributeAnalysis(String javaName, AttributeMode mode, Method accessor,\n                 mutatorAnalysis = new OperationAnalysis(mutator);\n             }\n \n-            setIDLName(getIDLName()); // Fixup operation names\n+            setIDLName(getIDLName()); // Fix operation names\n         }\n     }\n "},{"filename":"jacorb/src/main/java/org/jboss/as/jacorb/rmi/ContainerAnalysis.java","diff":"@@ -594,12 +594,12 @@ protected void fixupOverloadedOperationNames()\n                 continue; // This method is not mapped.\n \n             // Calculate new IDL name\n-            ParameterAnalysis[] parms = oa.getParameters();\n+            ParameterAnalysis[] params = oa.getParameters();\n             StringBuffer b = new StringBuffer(oa.getIDLName());\n-            if (parms.length == 0)\n+            if (params.length == 0)\n                 b.append(\"__\");\n-            for (int j = 0; j < parms.length; ++j) {\n-                String s = parms[j].getTypeIDLName();\n+            for (int j = 0; j < params.length; ++j) {\n+                String s = params[j].getTypeIDLName();\n \n                 if (s.startsWith(\"::\"))\n                     s = s.substring(2);"},{"filename":"jacorb/src/main/java/org/jboss/as/jacorb/rmi/DelegatingStubFactoryFactory.java","diff":"@@ -17,7 +17,7 @@\n     private final PresentationManager.StubFactoryFactory staticFactory;\n     private final PresentationManager.StubFactoryFactory dynamicFactory;\n \n-    private static volatile PresentationManager.StubFactoryFactory overridenDynamicFactory;\n+    private static volatile PresentationManager.StubFactoryFactory overriddenDynamicFactory;\n \n     public DelegatingStubFactoryFactory() {\n         staticFactory = new StubFactoryFactoryStaticImpl();\n@@ -33,8 +33,8 @@ public DelegatingStubFactoryFactory() {\n         } catch (Exception e) {\n \n         }\n-        if (overridenDynamicFactory != null) {\n-            return overridenDynamicFactory.createStubFactory(className, isIDLStub, remoteCodeBase, expectedClass, classLoader);\n+        if (overriddenDynamicFactory != null) {\n+            return overriddenDynamicFactory.createStubFactory(className, isIDLStub, remoteCodeBase, expectedClass, classLoader);\n \n         } else {\n             return dynamicFactory.createStubFactory(className, isIDLStub, remoteCodeBase, expectedClass, classLoader);\n@@ -57,11 +57,11 @@ public boolean createsDynamicStubs() {\n         return true;\n     }\n \n-    public static PresentationManager.StubFactoryFactory getOverridenDynamicFactory() {\n-        return overridenDynamicFactory;\n+    public static PresentationManager.StubFactoryFactory getOverriddenDynamicFactory() {\n+        return overriddenDynamicFactory;\n     }\n \n-    public static void setOverridenDynamicFactory(final PresentationManager.StubFactoryFactory overridenDynamicFactory) {\n-        DelegatingStubFactoryFactory.overridenDynamicFactory = overridenDynamicFactory;\n+    public static void setOverriddenDynamicFactory(final PresentationManager.StubFactoryFactory overriddenDynamicFactory) {\n+        DelegatingStubFactoryFactory.overriddenDynamicFactory = overriddenDynamicFactory;\n     }\n }"},{"filename":"jacorb/src/main/java/org/jboss/as/jacorb/rmi/PrimitiveAnalysis.java","diff":"@@ -50,7 +50,7 @@ private PrimitiveAnalysis(final Class cls, final String idlName, final String ja\n \n \n     /**\n-     * Get a singleton instance representing one of the peimitive types.\n+     * Get a singleton instance representing one of the primitive types.\n      */\n     public static PrimitiveAnalysis getPrimitiveAnalysis(final Class cls) {\n         if (cls == null)"},{"filename":"jacorb/src/main/java/org/jboss/as/jacorb/rmi/WorkCacheManager.java","diff":"@@ -47,7 +47,7 @@\n  * <p/>\n  * Besides caching work already done, this caches work in progress,\n  * as we need to know about this to handle cyclic graphs of analyses.\n- * When a thread re-enters the <code>getAnalysis()</code> metohd, an\n+ * When a thread re-enters the <code>getAnalysis()</code> method, an\n  * unfinished analysis will be returned if the same thread is already\n  * working on this analysis.\n  *"},{"filename":"jacorb/src/main/java/org/jboss/as/jacorb/rmi/ir/InterfaceRepository.java","diff":"@@ -776,7 +776,7 @@ else if (Exception.class.isAssignableFrom(compType)) // exception type\n                 typeCode = vbDef.type();\n         }\n \n-        // Return the box of higest dimension.\n+        // Return the box of highest dimension.\n         return vbDef;\n     }\n "},{"filename":"jacorb/src/main/resources/idl/CSI.idl","diff":"@@ -92,7 +92,7 @@ module CSI {\n     // shall directly certify the one preceding it. The first certificate\n     // in the chain shall certify the attribute certificate. The ASN.1\n     // representation of (X.509) Certificate is as defined in [IETF RFC 2459].\n-    // The ASN.1 representation of (X.509) AtributeCertificate is as defined\n+    // The ASN.1 representation of (X.509) AttributeCertificate is as defined\n     // in [IETF ID PKIXAC].  \n \n     const AuthorizationElementType X509AttributeCertChain = OMGVMCID | 1;"},{"filename":"jaxr/src/main/java/org/jboss/as/jaxr/extension/JAXRDependencyProcessor.java","diff":"@@ -49,12 +49,12 @@ public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitPro\n         final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n \n         final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n-        addDepdenency(moduleSpecification, moduleLoader, APACHE_SCOUT);\n-        addDepdenency(moduleSpecification, moduleLoader, JBOSS_JAXR);\n+        addDependency(moduleSpecification, moduleLoader, APACHE_SCOUT);\n+        addDependency(moduleSpecification, moduleLoader, JBOSS_JAXR);\n \n     }\n \n-    private void addDepdenency(ModuleSpecification moduleSpecification, ModuleLoader moduleLoader, ModuleIdentifier moduleIdentifier) {\n+    private void addDependency(ModuleSpecification moduleSpecification, ModuleLoader moduleLoader, ModuleIdentifier moduleIdentifier) {\n         moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, moduleIdentifier, false, false, true, false));\n     }\n "},{"filename":"jaxrs/src/main/java/org/jboss/as/jaxrs/JaxrsAnnotations.java","diff":"@@ -40,7 +40,7 @@\n     GET(\"GET\"),\n     HEAD(\"HEAD\"),\n     HEADER_PARAM(\"HeaderParam\"),\n-    HTTP_MTHOD(\"HttpMethod\"),\n+    HTTP_METHOD(\"HttpMethod\"),\n     MATRIX_PARAM(\"MatrixParam\"),\n     PATH(\"Path\"),\n     PATH_PARAM(\"PathParam\"),"},{"filename":"jaxrs/src/main/java/org/jboss/as/jaxrs/deployment/JaxrsComponentDeployer.java","diff":"@@ -18,7 +18,7 @@\n import static org.jboss.as.jaxrs.JaxrsLogger.JAXRS_LOGGER;\n \n /**\n- * Integrate's JAX-RS with other component types such as managed beans and EJB's\n+ * Integrates JAX-RS with other component types such as managed beans and EJB's\n  * <p/>\n  * This is not needed if beans.xml is present, as in this case the integration is handed by the more general\n  * integration with CDI."},{"filename":"jaxrs/src/main/java/org/jboss/as/jaxrs/deployment/JaxrsDependencyProcessor.java","diff":"@@ -64,28 +64,28 @@ public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitPro\n         final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n \n         final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n-        addDepdenency(moduleSpecification, moduleLoader, JAXB_API);\n+        addDependency(moduleSpecification, moduleLoader, JAXB_API);\n \n         if (!JaxrsDeploymentMarker.isJaxrsDeployment(deploymentUnit)) {\n             return;\n         }\n-        addDepdenency(moduleSpecification, moduleLoader, RESTEASY_ATOM);\n-        addDepdenency(moduleSpecification, moduleLoader, RESTEASY_JAXRS);\n-        addDepdenency(moduleSpecification, moduleLoader, RESTEASY_JAXB);\n-        addDepdenency(moduleSpecification, moduleLoader, RESTEASY_JACKSON);\n-        addDepdenency(moduleSpecification, moduleLoader, RESTEASY_JETTISON);\n-        addDepdenency(moduleSpecification, moduleLoader, RESTEASY_JSAPI);\n-        addDepdenency(moduleSpecification, moduleLoader, RESTEASY_MULTIPART);\n-        addDepdenency(moduleSpecification, moduleLoader, RESTEASY_YAML);\n-        addDepdenency(moduleSpecification, moduleLoader, JACKSON_CORE_ASL);\n+        addDependency(moduleSpecification, moduleLoader, RESTEASY_ATOM);\n+        addDependency(moduleSpecification, moduleLoader, RESTEASY_JAXRS);\n+        addDependency(moduleSpecification, moduleLoader, RESTEASY_JAXB);\n+        addDependency(moduleSpecification, moduleLoader, RESTEASY_JACKSON);\n+        addDependency(moduleSpecification, moduleLoader, RESTEASY_JETTISON);\n+        addDependency(moduleSpecification, moduleLoader, RESTEASY_JSAPI);\n+        addDependency(moduleSpecification, moduleLoader, RESTEASY_MULTIPART);\n+        addDependency(moduleSpecification, moduleLoader, RESTEASY_YAML);\n+        addDependency(moduleSpecification, moduleLoader, JACKSON_CORE_ASL);\n \n         if (WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n-            addDepdenency(moduleSpecification, moduleLoader, RESTEASY_CDI);\n+            addDependency(moduleSpecification, moduleLoader, RESTEASY_CDI);\n         }\n \n     }\n \n-    private void addDepdenency(ModuleSpecification moduleSpecification, ModuleLoader moduleLoader,\n+    private void addDependency(ModuleSpecification moduleSpecification, ModuleLoader moduleLoader,\n                                ModuleIdentifier moduleIdentifier) {\n         moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, moduleIdentifier, false, false, true, false));\n     }"},{"filename":"jmx/src/main/java/org/jboss/as/jmx/Attribute.java","diff":"@@ -35,7 +35,7 @@\n     SHOW_MODEL(CommonAttributes.SHOW_MODEL),\n     SERVER_BINDING(CommonAttributes.SERVER_BINDING),\n     REGISTRY_BINDING(CommonAttributes.REGISTRY_BINDING),\n-    USE_MANAGEMENT_ENDPOINT(CommonAttributes.USE_MANAGMENT_ENDPOINT),\n+    USE_MANAGEMENT_ENDPOINT(CommonAttributes.USE_MANAGEMENT_ENDPOINT),\n     VALUE(CommonAttributes.VALUE)\n     ;\n     private final String name;"},{"filename":"jmx/src/main/java/org/jboss/as/jmx/CommonAttributes.java","diff":"@@ -35,6 +35,6 @@\n     String REGISTRY_BINDING = \"registry-binding\";\n     String REMOTING_CONNECTOR = \"remoting-connector\";\n     String JMX_CONNECTOR = \"jmx-connector\";\n-    String USE_MANAGMENT_ENDPOINT = \"use-management-endpoint\";\n+    String USE_MANAGEMENT_ENDPOINT = \"use-management-endpoint\";\n     String VALUE = \"value\";\n }"},{"filename":"jmx/src/main/java/org/jboss/as/jmx/JmxLogger.java","diff":"@@ -57,7 +57,7 @@\n     void cannotShutdownRmiRegistry(@Cause Throwable cause);\n \n     /**\n-     * Creates an exception indicating the JMX connector could not undbind from the registry.\n+     * Creates an exception indicating the JMX connector could not unbind from the registry.\n      *\n      * @param cause the cause of the error.\n      */\n@@ -66,7 +66,7 @@\n     void cannotStopConnectorServer(@Cause Throwable cause);\n \n     /**\n-     * Creates an exception indicating the JMX connector could not undbind from the registry.\n+     * Creates an exception indicating the JMX connector could not unbind from the registry.\n      *\n      * @param cause the cause of the error.\n      */"},{"filename":"jmx/src/main/java/org/jboss/as/jmx/JmxMessages.java","diff":"@@ -90,7 +90,7 @@\n      * @param cause the cause of the error.\n      * @param name  the name of the attribute.\n      *\n-     * @return a {@link ReflectionException} for the errror.\n+     * @return a {@link ReflectionException} for the error.\n      */\n     @Message(id = 11333, value = \"Could not set %s\")\n     ReflectionException cannotSetAttribute(@Cause Exception cause, String name);"},{"filename":"jmx/src/main/java/org/jboss/as/jmx/RemotingConnectorAdd.java","diff":"@@ -32,7 +32,7 @@\n import org.jboss.msc.service.ServiceController;\n import org.jboss.msc.service.ServiceTarget;\n \n-import static org.jboss.as.jmx.CommonAttributes.USE_MANAGMENT_ENDPOINT;\n+import static org.jboss.as.jmx.CommonAttributes.USE_MANAGEMENT_ENDPOINT;\n \n /**\n  * @author Stuart Douglas\n@@ -46,7 +46,7 @@ private RemotingConnectorAdd() {\n \n     @Override\n     protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n-        if(operation.hasDefined(USE_MANAGMENT_ENDPOINT)) {\n+        if(operation.hasDefined(USE_MANAGEMENT_ENDPOINT)) {\n             RemotingConnectorResource.USE_MANAGEMENT_ENDPOINT.validateAndSet(operation, model);\n         }\n     }\n@@ -56,7 +56,7 @@ protected void performRuntime(OperationContext context, ModelNode operation, Mod\n             ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers)\n             throws OperationFailedException {\n         boolean useManagementEndpoint = true;\n-        if(model.hasDefined(USE_MANAGMENT_ENDPOINT)) {\n+        if(model.hasDefined(USE_MANAGEMENT_ENDPOINT)) {\n              useManagementEndpoint = RemotingConnectorResource.USE_MANAGEMENT_ENDPOINT.resolveModelAttribute(context, model).asBoolean();\n         }\n "},{"filename":"jmx/src/main/java/org/jboss/as/jmx/RemotingConnectorResource.java","diff":"@@ -41,7 +41,7 @@\n public class RemotingConnectorResource extends SimpleResourceDefinition {\n \n     static final PathElement REMOTE_CONNECTOR_CONFIG_PATH = PathElement.pathElement(REMOTING_CONNECTOR, JMX);\n-    static final SimpleAttributeDefinition USE_MANAGEMENT_ENDPOINT = new SimpleAttributeDefinitionBuilder(CommonAttributes.USE_MANAGMENT_ENDPOINT, ModelType.BOOLEAN, true)\n+    static final SimpleAttributeDefinition USE_MANAGEMENT_ENDPOINT = new SimpleAttributeDefinitionBuilder(CommonAttributes.USE_MANAGEMENT_ENDPOINT, ModelType.BOOLEAN, true)\n             .setDefaultValue(new ModelNode(true)).build();\n     static final RemotingConnectorResource INSTANCE = new RemotingConnectorResource();\n "},{"filename":"jmx/src/main/java/org/jboss/as/jmx/model/ObjectNameAddressUtil.java","diff":"@@ -44,7 +44,7 @@\n class ObjectNameAddressUtil {\n \n     private static final EscapedCharacter[] ESCAPED_KEY_CHARACTERS;\n-    private static final EscapedCharacter[] ECAPED_VALUE_CHARACTERS;\n+    private static final EscapedCharacter[] ESCAPED_VALUE_CHARACTERS;\n     static {\n         List<EscapedCharacter> keys = new ArrayList<EscapedCharacter>();\n         List<EscapedCharacter> values = new ArrayList<EscapedCharacter>();\n@@ -61,7 +61,7 @@\n         values.add(new EscapedCharacter(','));\n \n         ESCAPED_KEY_CHARACTERS = keys.toArray(new EscapedCharacter[keys.size()]);\n-        ECAPED_VALUE_CHARACTERS = keys.toArray(new EscapedCharacter[values.size()]);\n+        ESCAPED_VALUE_CHARACTERS = keys.toArray(new EscapedCharacter[values.size()]);\n     }\n \n     static ObjectName createObjectName(final PathAddress pathAddress) {\n@@ -80,7 +80,7 @@ static ObjectName createObjectName(final PathAddress pathAddress) {\n             }\n             appendEscapedCharacter(ESCAPED_KEY_CHARACTERS, sb, element.getKey());\n             sb.append(\"=\");\n-            appendEscapedCharacter(ECAPED_VALUE_CHARACTERS, sb, element.getValue());\n+            appendEscapedCharacter(ESCAPED_VALUE_CHARACTERS, sb, element.getValue());\n         }\n         try {\n             return ObjectName.getInstance(sb.toString());"},{"filename":"jpa/core/src/main/java/org/jboss/as/jpa/config/PersistenceUnitMetadataImpl.java","diff":"@@ -78,7 +78,7 @@\n     // optional:  collection of jar file names that contain entity classes\n     private List<String> jarFiles = new ArrayList<String>(1);\n \n-    private List<URL> jarfilesUrls = new ArrayList<URL>();\n+    private List<URL> jarFilesUrls = new ArrayList<URL>();\n \n     private URL persistenceUnitRootUrl;\n \n@@ -196,8 +196,8 @@ public URL getPersistenceUnitRootUrl() {\n     }\n \n     @Override\n-    public void setAnnotationIndex(Map<URL, Index> indexs) {\n-        annotationIndex = indexs;\n+    public void setAnnotationIndex(Map<URL, Index> indexes) {\n+        annotationIndex = indexes;\n     }\n \n     @Override\n@@ -242,12 +242,12 @@ public void setMappingFiles(List<String> mappingFiles) {\n \n     @Override\n     public List<URL> getJarFileUrls() {\n-        return jarfilesUrls;\n+        return jarFilesUrls;\n     }\n \n     @Override\n-    public void setJarFileUrls(List<URL> jarfilesUrls) {\n-        this.jarfilesUrls = jarfilesUrls;\n+    public void setJarFileUrls(List<URL> jarFilesUrls) {\n+        this.jarFilesUrls = jarFilesUrls;\n     }\n \n "},{"filename":"jpa/core/src/main/java/org/jboss/as/jpa/injectors/PersistenceUnitInjectionSource.java","diff":"@@ -48,7 +48,7 @@\n \n /**\n  * Represents the PersistenceUnit injected into a component.\n- * TODO:  support injecting into a HibernateSessionFactory.  Initially, hack it by checknig injectionTypeName parameter\n+ * TODO:  support injecting into a HibernateSessionFactory.  Initially, hack it by checking injectionTypeName parameter\n  * for HibernateSessionFactory.  If/when JPA supports unwrap on the EMF, switch to that.\n  *\n  * @author Scott Marlow"},{"filename":"jpa/core/src/main/java/org/jboss/as/jpa/processor/JPAAnnotationParseProcessor.java","diff":"@@ -91,7 +91,7 @@ public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitPro\n \n         // @PersistenceUnit\n         List<AnnotationInstance> persistenceUnits = index.getAnnotations(PERSISTENCE_UNIT_ANNOTATION_NAME);\n-        // create binding and injection configurations out of the @PersistenceUnit annotaitons\n+        // create binding and injection configurations out of the @PersistenceUnit annotations\n         this.processPersistenceAnnotations(deploymentUnit, eeModuleDescription, persistenceUnits, applicationClasses);\n \n         // if we found any @PersistenceContext or @PersistenceUnit annotations then mark this as a JPA deployment"},{"filename":"jpa/core/src/main/java/org/jboss/as/jpa/processor/JPADeploymentMarker.java","diff":"@@ -47,7 +47,7 @@ public static void mark(DeploymentUnit unit) {\n     }\n \n     /**\n-     * retuns true if the {@link DeploymentUnit} is part of a JPA deployment\n+     * return true if the {@link DeploymentUnit} is part of a JPA deployment\n      */\n     public static boolean isJPADeployment(DeploymentUnit unit) {\n         if (unit.getParent() == null) {"},{"filename":"jpa/core/src/main/java/org/jboss/as/jpa/puparser/PersistenceUnitXmlParser.java","diff":"@@ -144,7 +144,7 @@ public static PersistenceUnitMetadataHolder parse(final XMLStreamReader reader)\n     private static PersistenceUnitMetadata parsePU(XMLStreamReader reader, Version version) throws XMLStreamException {\n         PersistenceUnitMetadata pu = new PersistenceUnitMetadataImpl();\n         List<String> classes = new ArrayList<String>(1);\n-        List<String> jarfiles = new ArrayList<String>(1);\n+        List<String> jarFiles = new ArrayList<String>(1);\n         List<String> mappingFiles = new ArrayList<String>(1);\n         Properties properties = new Properties();\n \n@@ -212,7 +212,7 @@ private static PersistenceUnitMetadata parsePU(XMLStreamReader reader, Version v\n \n                 case JARFILE:\n                     String file = reader.getElementText();\n-                    jarfiles.add(file);\n+                    jarFiles.add(file);\n                     break;\n \n                 case JTADATASOURCE:\n@@ -253,7 +253,7 @@ private static PersistenceUnitMetadata parsePU(XMLStreamReader reader, Version v\n             JPA_LOGGER.trace(\"parse persistence.xml: reached ending persistence-unit tag\");\n         }\n         pu.setManagedClassNames(classes);\n-        pu.setJarFiles(jarfiles);\n+        pu.setJarFiles(jarFiles);\n         pu.setMappingFiles(mappingFiles);\n         pu.setProperties(properties);\n         return pu;"},{"filename":"jpa/hibernate3/src/main/java/org/jboss/as/jpa/hibernate3/HibernateAnnotationScanner.java","diff":"@@ -69,24 +69,24 @@ public static void clearThreadLocalPersistenceUnitMetadata() {\n     }\n \n \n-    private static void cachePackages(PersistenceUnitMetadata pu, URL jartoScan, Set<Package> packages) {\n+    private static void cachePackages(PersistenceUnitMetadata pu, URL jarToScan, Set<Package> packages) {\n         synchronized (PACKAGES_IN_JAR_CACHE) {\n             Map<URL, Set<Package>> packagesByUrl = PACKAGES_IN_JAR_CACHE.get(pu);\n             if (packagesByUrl == null) {\n                 packagesByUrl = new HashMap<URL, Set<Package>>();\n                 PACKAGES_IN_JAR_CACHE.put(pu, packagesByUrl);\n             }\n-            packagesByUrl.put(jartoScan, packages);\n+            packagesByUrl.put(jarToScan, packages);\n         }\n     }\n \n-    private static Set<Package> getCachedPackages(PersistenceUnitMetadata pu, URL jartoScan){\n+    private static Set<Package> getCachedPackages(PersistenceUnitMetadata pu, URL jarToScan){\n         synchronized (PACKAGES_IN_JAR_CACHE) {\n             Map<URL, Set<Package>> packagesByUrl = PACKAGES_IN_JAR_CACHE.get(pu);\n             if (packagesByUrl == null) {\n                 return Collections.emptySet();\n             }\n-            Set<Package> packages = packagesByUrl.get(jartoScan);\n+            Set<Package> packages = packagesByUrl.get(jarToScan);\n             if (packages == null) {\n                 return Collections.emptySet();\n             }\n@@ -95,17 +95,17 @@ private static void cachePackages(PersistenceUnitMetadata pu, URL jartoScan, Set\n         }\n     }\n \n-    private static void cacheClasses(PersistenceUnitMetadata pu, URL jartoScan, Class<? extends Annotation> annotation, Set<Class<?>> classes){\n+    private static void cacheClasses(PersistenceUnitMetadata pu, URL jarToScan, Class<? extends Annotation> annotation, Set<Class<?>> classes){\n         synchronized (CLASSES_IN_JAR_CACHE) {\n             Map<URL, Map<Class<? extends Annotation>, Set<Class<?>>>> classesByURL = CLASSES_IN_JAR_CACHE.get(pu);\n             if (classesByURL == null) {\n                 classesByURL = new HashMap<URL, Map<Class<? extends Annotation>, Set<Class<?>>>>();\n                 CLASSES_IN_JAR_CACHE.put(pu, classesByURL);\n             }\n-            Map<Class<? extends Annotation>, Set<Class<?>>> classesByAnnotation = classesByURL.get(jartoScan);\n+            Map<Class<? extends Annotation>, Set<Class<?>>> classesByAnnotation = classesByURL.get(jarToScan);\n             if (classesByAnnotation == null) {\n                 classesByAnnotation = new HashMap<Class<? extends Annotation>, Set<Class<?>>>();\n-                classesByURL.put(jartoScan, classesByAnnotation);\n+                classesByURL.put(jarToScan, classesByAnnotation);\n             }\n             classesByAnnotation.put(annotation, classes);\n         }\n@@ -143,11 +143,11 @@ static void cleanup(PersistenceUnitMetadata pu) {\n     }\n \n     @Override\n-    public Set<Package> getPackagesInJar(URL jartoScan, Set<Class<? extends Annotation>> annotationsToLookFor) {\n-        if (jartoScan == null) {\n-            throw MESSAGES.nullVar(\"jartoScan\");\n+    public Set<Package> getPackagesInJar(URL jarToScan, Set<Class<? extends Annotation>> annotationsToLookFor) {\n+        if (jarToScan == null) {\n+            throw MESSAGES.nullVar(\"jarToScan\");\n         }\n-        JPA_LOGGER.tracef(\"getPackagesInJar url=%s annotations=%s\", jartoScan.getPath(), annotationsToLookFor);\n+        JPA_LOGGER.tracef(\"getPackagesInJar url=%s annotations=%s\", jarToScan.getPath(), annotationsToLookFor);\n         Set<Class<?>> resultClasses = new HashSet<Class<?>>();\n \n         PersistenceUnitMetadata pu = persistenceUnitMetadataTLS.get();\n@@ -156,13 +156,13 @@ static void cleanup(PersistenceUnitMetadata pu) {\n         }\n \n         if (annotationsToLookFor.size() > 0) {  // Hibernate doesn't pass any annotations currently\n-            resultClasses = getClassesInJar(jartoScan, annotationsToLookFor);\n+            resultClasses = getClassesInJar(jarToScan, annotationsToLookFor);\n         } else {\n             if (pu.getAnnotationIndex() != null) {\n-                Index index = getJarFileIndex(jartoScan, pu);\n+                Index index = getJarFileIndex(jarToScan, pu);\n                 if (index == null) {\n                     JPA_LOGGER.tracef(\"No classes to scan for annotations in jar '%s' (jars with classes '%s')\",\n-                        jartoScan, pu.getAnnotationIndex().keySet());\n+                        jarToScan, pu.getAnnotationIndex().keySet());\n                     return new HashSet<Package>();\n                 }\n                 Collection<ClassInfo> allClasses = index.getKnownClasses();\n@@ -189,10 +189,10 @@ static void cleanup(PersistenceUnitMetadata pu) {\n                 }\n             }\n             Set<Package> packages = new HashSet<Package>(uniquePackages.values());\n-            cachePackages(pu, jartoScan, packages);\n+            cachePackages(pu, jarToScan, packages);\n             return new HashSet<Package>(packages);\n         } else {\n-            return getCachedPackages(pu, jartoScan);\n+            return getCachedPackages(pu, jarToScan);\n         }\n     }\n "},{"filename":"jpa/hibernate4/src/main/java/org/jboss/as/jpa/hibernate4/HibernateAnnotationScanner.java","diff":"@@ -68,24 +68,24 @@ public static void clearThreadLocalPersistenceUnitMetadata() {\n         PERSISTENCE_UNIT_METADATA_TLS.remove();\n     }\n \n-    private static void cachePackages(PersistenceUnitMetadata pu, URL jartoScan, Set<Package> packages) {\n+    private static void cachePackages(PersistenceUnitMetadata pu, URL jarToScan, Set<Package> packages) {\n         synchronized (PACKAGES_IN_JAR_CACHE) {\n             Map<URL, Set<Package>> packagesByUrl = PACKAGES_IN_JAR_CACHE.get(pu);\n             if (packagesByUrl == null) {\n                 packagesByUrl = new HashMap<URL, Set<Package>>();\n                 PACKAGES_IN_JAR_CACHE.put(pu, packagesByUrl);\n             }\n-            packagesByUrl.put(jartoScan, packages);\n+            packagesByUrl.put(jarToScan, packages);\n         }\n     }\n \n-    private static Set<Package> getCachedPackages(PersistenceUnitMetadata pu, URL jartoScan){\n+    private static Set<Package> getCachedPackages(PersistenceUnitMetadata pu, URL jarToScan){\n         synchronized (PACKAGES_IN_JAR_CACHE) {\n             Map<URL, Set<Package>> packagesByUrl = PACKAGES_IN_JAR_CACHE.get(pu);\n             if (packagesByUrl == null) {\n                 return Collections.emptySet();\n             }\n-            Set<Package> packages = packagesByUrl.get(jartoScan);\n+            Set<Package> packages = packagesByUrl.get(jarToScan);\n             if (packages == null) {\n                 return Collections.emptySet();\n             }\n@@ -94,30 +94,30 @@ private static void cachePackages(PersistenceUnitMetadata pu, URL jartoScan, Set\n         }\n     }\n \n-    private static void cacheClasses(PersistenceUnitMetadata pu, URL jartoScan, Class<? extends Annotation> annotation, Set<Class<?>> classes){\n+    private static void cacheClasses(PersistenceUnitMetadata pu, URL jarToScan, Class<? extends Annotation> annotation, Set<Class<?>> classes){\n         synchronized (CLASSES_IN_JAR_CACHE) {\n             Map<URL, Map<Class<? extends Annotation>, Set<Class<?>>>> classesByURL = CLASSES_IN_JAR_CACHE.get(pu);\n             if (classesByURL == null) {\n                 classesByURL = new HashMap<URL, Map<Class<? extends Annotation>, Set<Class<?>>>>();\n                 CLASSES_IN_JAR_CACHE.put(pu, classesByURL);\n             }\n-            Map<Class<? extends Annotation>, Set<Class<?>>> classesByAnnotation = classesByURL.get(jartoScan);\n+            Map<Class<? extends Annotation>, Set<Class<?>>> classesByAnnotation = classesByURL.get(jarToScan);\n             if (classesByAnnotation == null) {\n                 classesByAnnotation = new HashMap<Class<? extends Annotation>, Set<Class<?>>>();\n-                classesByURL.put(jartoScan, classesByAnnotation);\n+                classesByURL.put(jarToScan, classesByAnnotation);\n             }\n             classesByAnnotation.put(annotation, classes);\n         }\n \n     }\n \n-    private static Set<Class<?>> getCachedClasses(PersistenceUnitMetadata pu, URL jartoScan, Set<Class<? extends Annotation>> annotationsToLookFor){\n+    private static Set<Class<?>> getCachedClasses(PersistenceUnitMetadata pu, URL jarToScan, Set<Class<? extends Annotation>> annotationsToLookFor){\n         synchronized (CLASSES_IN_JAR_CACHE) {\n             Map<URL, Map<Class<? extends Annotation>, Set<Class<?>>>> classesByURL = CLASSES_IN_JAR_CACHE.get(pu);\n             if (classesByURL == null) {\n                 return Collections.emptySet();\n             }\n-            Map<Class<? extends Annotation>, Set<Class<?>>> classesByAnnotation = classesByURL.get(jartoScan);\n+            Map<Class<? extends Annotation>, Set<Class<?>>> classesByAnnotation = classesByURL.get(jarToScan);\n             if (classesByAnnotation == null) {\n                 return Collections.emptySet();\n             }\n@@ -142,11 +142,11 @@ static void cleanup(PersistenceUnitMetadata pu) {\n     }\n \n     @Override\n-    public Set<Package> getPackagesInJar(URL jartoScan, Set<Class<? extends Annotation>> annotationsToLookFor) {\n-        if (jartoScan == null) {\n-            throw MESSAGES.nullVar(\"jartoScan\");\n+    public Set<Package> getPackagesInJar(URL jarToScan, Set<Class<? extends Annotation>> annotationsToLookFor) {\n+        if (jarToScan == null) {\n+            throw MESSAGES.nullVar(\"jarToScan\");\n         }\n-        JPA_LOGGER.tracef(\"getPackagesInJar url=%s annotations=%s\", jartoScan.getPath(), annotationsToLookFor);\n+        JPA_LOGGER.tracef(\"getPackagesInJar url=%s annotations=%s\", jarToScan.getPath(), annotationsToLookFor);\n         Set<Class<?>> resultClasses = new HashSet<Class<?>>();\n \n         PersistenceUnitMetadata pu = PERSISTENCE_UNIT_METADATA_TLS.get();\n@@ -155,13 +155,13 @@ static void cleanup(PersistenceUnitMetadata pu) {\n         }\n \n         if (annotationsToLookFor.size() > 0) {  // Hibernate doesn't pass any annotations currently\n-            resultClasses = getClassesInJar(jartoScan, annotationsToLookFor);\n+            resultClasses = getClassesInJar(jarToScan, annotationsToLookFor);\n         } else {\n             if (pu.getAnnotationIndex() != null) {\n-                Index index = getJarFileIndex(jartoScan, pu);\n+                Index index = getJarFileIndex(jarToScan, pu);\n                 if (index == null) {\n                     JPA_LOGGER.tracef(\"No classes to scan for annotations in jar '%s' (jars with classes '%s')\",\n-                        jartoScan, pu.getAnnotationIndex().keySet());\n+                        jarToScan, pu.getAnnotationIndex().keySet());\n                     return new HashSet<Package>();\n                 }\n                 Collection<ClassInfo> allClasses = index.getKnownClasses();\n@@ -188,32 +188,32 @@ static void cleanup(PersistenceUnitMetadata pu) {\n                 }\n             }\n             Set<Package> packages = new HashSet<Package>(uniquePackages.values());\n-            cachePackages(pu, jartoScan, packages);\n+            cachePackages(pu, jarToScan, packages);\n             return new HashSet<Package>(packages);\n         } else {\n-            return getCachedPackages(pu, jartoScan);\n+            return getCachedPackages(pu, jarToScan);\n         }\n     }\n \n-    private Index getJarFileIndex(final URL jartoScan, final PersistenceUnitMetadata pu) {\n-        return pu.getAnnotationIndex().get(jartoScan);\n+    private Index getJarFileIndex(final URL jarToScan, final PersistenceUnitMetadata pu) {\n+        return pu.getAnnotationIndex().get(jarToScan);\n     }\n \n     @Override\n-    public Set<Class<?>> getClassesInJar(URL jartoScan, Set<Class<? extends Annotation>> annotationsToLookFor) {\n-        if (jartoScan == null) {\n-            throw MESSAGES.nullVar(\"jartoScan\");\n+    public Set<Class<?>> getClassesInJar(URL jarToScan, Set<Class<? extends Annotation>> annotationsToLookFor) {\n+        if (jarToScan == null) {\n+            throw MESSAGES.nullVar(\"jarToScan\");\n         }\n-        JPA_LOGGER.tracef(\"getClassesInJar url=%s annotations=%s\", jartoScan.getPath(), annotationsToLookFor);\n+        JPA_LOGGER.tracef(\"getClassesInJar url=%s annotations=%s\", jarToScan.getPath(), annotationsToLookFor);\n         PersistenceUnitMetadata pu = PERSISTENCE_UNIT_METADATA_TLS.get();\n         if (pu == null) {\n             throw MESSAGES.missingPersistenceUnitMetadata();\n         }\n         if (pu.getAnnotationIndex() != null) {\n-            Index index = getJarFileIndex(jartoScan, pu);\n+            Index index = getJarFileIndex(jarToScan, pu);\n             if (index == null) {\n                 JPA_LOGGER.tracef(\"No classes to scan for annotations in jar '%s' (jars with classes '%s')\",\n-                    jartoScan, pu.getAnnotationIndex().keySet());\n+                    jarToScan, pu.getAnnotationIndex().keySet());\n                 return new HashSet<Class<?>>();\n             }\n             if (annotationsToLookFor == null) {\n@@ -246,29 +246,29 @@ private Index getJarFileIndex(final URL jartoScan, final PersistenceUnitMetadata\n                         }\n                     }\n                 }\n-                cacheClasses(pu, jartoScan, annClass, classesForAnnotation);\n+                cacheClasses(pu, jarToScan, annClass, classesForAnnotation);\n             }\n             return result;\n         } else {\n-            return getCachedClasses(pu, jartoScan, annotationsToLookFor);\n+            return getCachedClasses(pu, jarToScan, annotationsToLookFor);\n         }\n     }\n \n     @Override\n-    public Set<NamedInputStream> getFilesInJar(URL jartoScan, Set<String> filePatterns) {\n-        if (jartoScan == null)\n-            throw MESSAGES.nullVar(\"jartoScan\");\n+    public Set<NamedInputStream> getFilesInJar(URL jarToScan, Set<String> filePatterns) {\n+        if (jarToScan == null)\n+            throw MESSAGES.nullVar(\"jarToScan\");\n         if (filePatterns == null)\n             throw MESSAGES.nullVar(\"filePatterns\");\n \n         Set<NamedInputStream> result = new HashSet<NamedInputStream>();\n         Map<String, Set<NamedInputStream>> map;\n         map = new HashMap<String, Set<NamedInputStream>>();\n-        findFiles(jartoScan, filePatterns, map, result);\n+        findFiles(jarToScan, filePatterns, map, result);\n         return result;\n     }\n \n-    private void findFiles(URL jartoScan, Set<String> filePatterns, Map<String, Set<NamedInputStream>> map, Set<NamedInputStream> result) {\n+    private void findFiles(URL jarToScan, Set<String> filePatterns, Map<String, Set<NamedInputStream>> map, Set<NamedInputStream> result) {\n         if (filePatterns.isEmpty()) {\n             for (Set<NamedInputStream> nims : map.values())\n                 result.addAll(nims);\n@@ -278,7 +278,7 @@ private void findFiles(URL jartoScan, Set<String> filePatterns, Map<String, Set<\n                 Set<NamedInputStream> niss = map.get(pattern);\n                 if (niss == null) {\n                     if (root == null)\n-                        root = getFile(jartoScan);\n+                        root = getFile(jarToScan);\n \n                     try {\n                         List<VirtualFile> children = root.getChildrenRecursively(new HibernatePatternFilter(pattern));"},{"filename":"jpa/hibernate4/src/main/java/org/jboss/as/jpa/hibernate4/management/HibernateManagementAdaptor.java","diff":"@@ -232,7 +232,7 @@ void handle(final ModelNode response, final String name, ManagementLookup stats,\n         });\n \n         /**\n-         * Get global number of entity fetchs\n+         * Get global number of entity fetches\n          * @return entity fetch (from DB)\n          */\n         jpaHibernateRegistration.registerMetric(OPERATION_ENTITY_FETCH_COUNT, new AbstractMetricsHandler() {"},{"filename":"jpa/hibernate4/src/main/java/org/jboss/as/jpa/hibernate4/management/HibernateStatisticsResource.java","diff":"@@ -267,8 +267,8 @@ private boolean hasEntity(PathElement element) {\n         boolean result = false;\n         final Statistics stats = getStatistics();\n         if (stats != null) {\n-            final String emtityName = element.getValue();\n-            result = stats.getEntityStatistics(emtityName) != null;\n+            final String entityName = element.getValue();\n+            result = stats.getEntityStatistics(entityName) != null;\n         }\n         return result;\n     }"},{"filename":"jpa/spi/src/main/java/org/jboss/as/jpa/spi/PersistenceUnitMetadata.java","diff":"@@ -64,7 +64,7 @@\n \n     void setPersistenceUnitRootUrl(URL persistenceUnitRootUrl);\n \n-    void setAnnotationIndex(Map<URL, Index> indexs);\n+    void setAnnotationIndex(Map<URL, Index> indexes);\n \n     Map<URL, Index> getAnnotationIndex();\n \n@@ -76,7 +76,7 @@\n \n     void setMappingFiles(List<String> mappingFiles);\n \n-    void setJarFileUrls(List<URL> jarfilesUrls);\n+    void setJarFileUrls(List<URL> jarFilesUrls);\n \n     List<String> getJarFiles();\n "},{"filename":"logging/src/main/java/org/jboss/as/logging/LoggingMessages.java","diff":"@@ -118,7 +118,7 @@\n     String failedToSetHandlerEncoding();\n \n     /**\n-     * A message indicating the handler, represented by the {@code name} parameter, is alredy assigned.\n+     * A message indicating the handler, represented by the {@code name} parameter, is already assigned.\n      *\n      * @param name the handler name.\n      *"},{"filename":"logging/src/main/resources/org/jboss/as/logging/LocalDescriptions.properties","diff":"@@ -62,8 +62,8 @@ async.queue-length=The queue length to use before flushing writing\n async.overflow-action=Specify what action to take when the overflowing.  The valid options are 'block' and 'discard'\n async.handler.add=Add a new ASYNC handler.\n async.handler.update=Update the properties of an existing ASYNC handler.\n-async.handler.subhandlers=The Handlers associated with this asycn handler.\n-async.handler.handler=The subhandler associated with this asycn handler.\n+async.handler.subhandlers=The Handlers associated with this async handler.\n+async.handler.handler=The subhandler associated with this async handler.\n async.handler.assign-subhandler=Assign a subhandler to the ASYNC handler.\n async.handler.unassign-subhandler=Unassign a subhandler from the ASYNC handler.\n "},{"filename":"mail/src/main/java/org/jboss/as/mail/extension/MailMessages.java","diff":"@@ -60,6 +60,6 @@\n      * @param outgoingSocketBindingRef the name of the socket binding configuration.\n      * @return a {@link RuntimeException} for the error.\n      */\n-    @Message(id = 15451, value = \"Unknwon host for outbound socket binding configuration '%s'.\")\n-    RuntimeException unknownOutboundSocketBindingDesintation(@Cause UnknownHostException cause, String outgoingSocketBindingRef);\n+    @Message(id = 15451, value = \"Unknown host for outbound socket binding configuration '%s'.\")\n+    RuntimeException unknownOutboundSocketBindingDestination(@Cause UnknownHostException cause, String outgoingSocketBindingRef);\n }"},{"filename":"mail/src/main/java/org/jboss/as/mail/extension/MailSessionService.java","diff":"@@ -105,7 +105,7 @@ private InetSocketAddress getServerSocketAddress(MailSessionServer server) throw\n         try {\n             destinationAddress = binding.getDestinationAddress();\n         } catch (UnknownHostException uhe) {\n-            throw MailMessages.MESSAGES.unknownOutboundSocketBindingDesintation(uhe, ref);\n+            throw MailMessages.MESSAGES.unknownOutboundSocketBindingDestination(uhe, ref);\n         }\n         return new InetSocketAddress(destinationAddress, binding.getDestinationPort());\n     }"},{"filename":"mail/src/main/resources/org/jboss/as/mail/extension/LocalDescriptions.properties","diff":"@@ -12,6 +12,6 @@ mail-session.server=Mail session server\n mail-session.server.add=adds smtp server\n mail-session.server.remove=removes server\n mail-session.server.outbound-socket-binding-ref=Outbound Socket binding to POP3 server\n-mail-session.server.ssl=Does server requres SSL?\n+mail-session.server.ssl=Does server requires SSL?\n mail-session.server.username=Username to authenticate on server\n mail-session.server.password=Password to authenticate on server"},{"filename":"messaging/src/main/java/org/jboss/as/messaging/AbstractQueueControlHandler.java","diff":"@@ -378,7 +378,7 @@ protected void executeRuntimeStep(OperationContext context, ModelNode operation)\n                 context.getResult().set(control.listConsumersAsJSON());\n             } else {\n                 // TODO LIST_MESSAGE_COUNTER, LIST_MESSAGE_COUNTER_HISTORY, LIST_CONSUMERS\n-                handback = handleAdditonalOperation(operationName, operation, context, control.getDelegate());\n+                handback = handleAdditionalOperation(operationName, operation, context, control.getDelegate());\n                 reversible = handback == null;\n             }\n         } catch (RuntimeException e) {\n@@ -394,7 +394,7 @@ protected void executeRuntimeStep(OperationContext context, ModelNode operation)\n                 } else if (RESUME.equals(operationName)) {\n                     control.pause();\n                 } else {\n-                    revertAdditonalOperation(operationName, operation, context, control.getDelegate(), handback);\n+                    revertAdditionalOperation(operationName, operation, context, control.getDelegate(), handback);\n                 }\n             } catch (Exception e) {\n                 ROOT_LOGGER.revertOperationFailed(e, getClass().getSimpleName(),\n@@ -406,11 +406,11 @@ protected void executeRuntimeStep(OperationContext context, ModelNode operation)\n \n     protected abstract DelegatingQueueControl<T> getQueueControl(HornetQServer hqServer, String queueName);\n \n-    protected abstract Object handleAdditonalOperation(final String operationName, final ModelNode operation,\n-                                                     final OperationContext context, T queueControl) throws OperationFailedException;\n+    protected abstract Object handleAdditionalOperation(final String operationName, final ModelNode operation,\n+                                                        final OperationContext context, T queueControl) throws OperationFailedException;\n \n-    protected abstract void revertAdditonalOperation(final String operationName, final ModelNode operation,\n-                                                     final OperationContext context, T queueControl, Object handback);\n+    protected abstract void revertAdditionalOperation(final String operationName, final ModelNode operation,\n+                                                      final OperationContext context, T queueControl, Object handback);\n \n     protected abstract boolean isJMS();\n "},{"filename":"messaging/src/main/java/org/jboss/as/messaging/HornetQServerAdd.java","diff":"@@ -143,7 +143,7 @@\n \n     static final String DEFAULT_BINDINGS_DIR = \"bindings\";\n     static final String DEFAULT_JOURNAL_DIR = \"journal\";\n-    static final String DEFAULT_LARGE_MESSSAGE_DIR = \"largemessages\";\n+    static final String DEFAULT_LARGE_MESSAGE_DIR = \"largemessages\";\n     static final String DEFAULT_PAGING_DIR = \"paging\";\n \n     public static final HornetQServerAdd INSTANCE = new HornetQServerAdd();\n@@ -209,7 +209,7 @@ public void execute(OperationContext context, ModelNode operation) throws Operat\n \n                 final ServiceName bindingsPath = createDirectoryService(DEFAULT_BINDINGS_DIR, model.get(PATH, BINDINGS_DIRECTORY), serviceTarget, operation, newControllers, verificationHandler);\n                 final ServiceName journalPath = createDirectoryService(DEFAULT_JOURNAL_DIR, model.get(PATH, JOURNAL_DIRECTORY), serviceTarget, operation, newControllers, verificationHandler);\n-                final ServiceName largeMessagePath = createDirectoryService(DEFAULT_LARGE_MESSSAGE_DIR, model.get(PATH, LARGE_MESSAGES_DIRECTORY), serviceTarget, operation, newControllers, verificationHandler);\n+                final ServiceName largeMessagePath = createDirectoryService(DEFAULT_LARGE_MESSAGE_DIR, model.get(PATH, LARGE_MESSAGES_DIRECTORY), serviceTarget, operation, newControllers, verificationHandler);\n                 final ServiceName pagingPath = createDirectoryService(DEFAULT_PAGING_DIR, model.get(PATH, PAGING_DIRECTORY), serviceTarget, operation, newControllers, verificationHandler);\n \n                 // Create the HornetQ Service\n@@ -223,7 +223,7 @@ public void execute(OperationContext context, ModelNode operation) throws Operat\n \n                 serviceBuilder.addDependency(bindingsPath, String.class, hqService.getPathInjector(DEFAULT_BINDINGS_DIR));\n                 serviceBuilder.addDependency(journalPath, String.class, hqService.getPathInjector(DEFAULT_JOURNAL_DIR));\n-                serviceBuilder.addDependency(largeMessagePath, String.class, hqService.getPathInjector(DEFAULT_LARGE_MESSSAGE_DIR));\n+                serviceBuilder.addDependency(largeMessagePath, String.class, hqService.getPathInjector(DEFAULT_LARGE_MESSAGE_DIR));\n                 serviceBuilder.addDependency(pagingPath, String.class, hqService.getPathInjector(DEFAULT_PAGING_DIR));\n \n                 // Add security"},{"filename":"messaging/src/main/java/org/jboss/as/messaging/HornetQServerControlWriteHandler.java","diff":"@@ -78,7 +78,7 @@ protected boolean applyUpdateToRuntime(final OperationContext context, final Mod\n                 return false;\n             } else if (hqService.getState() != ServiceController.State.UP) {\n                 // Service is installed but not up?\n-                //throw new IllegalStateException(String.format(\"Cannot apply attribue %s to runtime; service %s is not in state %s, it is in state %s\",\n+                //throw new IllegalStateException(String.format(\"Cannot apply attribute %s to runtime; service %s is not in state %s, it is in state %s\",\n                 //            attributeName, MessagingServices.JBOSS_MESSAGING, ServiceController.State.UP, hqService.getState()));\n                 // No, don't barf; just let the update apply to the model and put the server in a reload-required state\n                 return true;"},{"filename":"messaging/src/main/java/org/jboss/as/messaging/HornetQServerRemove.java","diff":"@@ -95,7 +95,7 @@ static void removeHornetQServer(String serverName, OperationContext context, Res\n         }\n         context.removeService(hqServiceName.append(HornetQServerAdd.PATH_BASE).append(HornetQServerAdd.DEFAULT_BINDINGS_DIR));\n         context.removeService(hqServiceName.append(HornetQServerAdd.PATH_BASE).append(HornetQServerAdd.DEFAULT_JOURNAL_DIR));\n-        context.removeService(hqServiceName.append(HornetQServerAdd.PATH_BASE).append(HornetQServerAdd.DEFAULT_LARGE_MESSSAGE_DIR));\n+        context.removeService(hqServiceName.append(HornetQServerAdd.PATH_BASE).append(HornetQServerAdd.DEFAULT_LARGE_MESSAGE_DIR));\n         context.removeService(hqServiceName.append(HornetQServerAdd.PATH_BASE).append(HornetQServerAdd.DEFAULT_PAGING_DIR));\n     }\n }"},{"filename":"messaging/src/main/java/org/jboss/as/messaging/MessagingLogger.java","diff":"@@ -99,7 +99,7 @@\n \n     /**\n      * Logs an error message indicating the class, represented by the {@code className} parameter, caught an exception\n-     * attempting to revert the operation, represented by the {@code operation} parameter, at the address, respresented\n+     * attempting to revert the operation, represented by the {@code operation} parameter, at the address, represented\n      * by the {@code address} parameter.\n      *\n      * @param cause     the cause of the error."},{"filename":"messaging/src/main/java/org/jboss/as/messaging/QueueControlHandler.java","diff":"@@ -75,8 +75,8 @@ public ModelNode getModelDescription(Locale locale) {\n     }\n \n     @Override\n-    protected Object handleAdditonalOperation(String operationName, ModelNode operation, OperationContext context,\n-                                            QueueControl queueControl) throws OperationFailedException {\n+    protected Object handleAdditionalOperation(String operationName, ModelNode operation, OperationContext context,\n+                                               QueueControl queueControl) throws OperationFailedException {\n         try {\n             if (LIST_SCHEDULED_MESSAGES.equals(operationName)) {\n                 String json = queueControl.listScheduledMessagesAsJSON();\n@@ -97,7 +97,7 @@ protected Object handleAdditonalOperation(String operationName, ModelNode operat\n     }\n \n     @Override\n-    protected void revertAdditonalOperation(String operationName, ModelNode operation, OperationContext context, QueueControl queueControl, Object handback) {\n+    protected void revertAdditionalOperation(String operationName, ModelNode operation, OperationContext context, QueueControl queueControl, Object handback) {\n         // no-op\n     }\n "},{"filename":"messaging/src/main/java/org/jboss/as/messaging/deployment/MessagingXmlInstallDeploymentUnitProcessor.java","diff":"@@ -30,7 +30,7 @@\n import static org.jboss.as.messaging.CommonAttributes.SELECTOR;\n \n /**\n- * Processor that handles the installation of the messaging subsystems depoyable XML\n+ * Processor that handles the installation of the messaging subsystems deployable XML\n  *\n  * @author Stuart Douglas\n  */"},{"filename":"messaging/src/main/java/org/jboss/as/messaging/jms/ConnectionFactoryWriteAttributeHandler.java","diff":"@@ -94,7 +94,7 @@ protected boolean applyUpdateToRuntime(final OperationContext context, final Mod\n                 return false;\n             } else if (hqService.getState() != ServiceController.State.UP) {\n                 // Service is installed but not up?\n-                //throw new IllegalStateException(String.format(\"Cannot apply attribue %s to runtime; service %s is not in state %s, it is in state %s\",\n+                //throw new IllegalStateException(String.format(\"Cannot apply attribute %s to runtime; service %s is not in state %s, it is in state %s\",\n                 //            attributeName, MessagingServices.JBOSS_MESSAGING, ServiceController.State.UP, hqService.getState()));\n                 // No, don't barf; just let the update apply to the model and put the server in a reload-required state\n                 return true;"},{"filename":"messaging/src/main/java/org/jboss/as/messaging/jms/JMSQueueControlHandler.java","diff":"@@ -171,14 +171,14 @@ public String listConsumersAsJSON() throws Exception {\n     }\n \n     @Override\n-    protected Object handleAdditonalOperation(String operationName, ModelNode operation, OperationContext context,\n-                                            JMSQueueControl queueControl) throws OperationFailedException {\n+    protected Object handleAdditionalOperation(String operationName, ModelNode operation, OperationContext context,\n+                                               JMSQueueControl queueControl) throws OperationFailedException {\n         throwUnimplementedOperationException(operationName);\n         return null;\n     }\n \n     @Override\n-    protected void revertAdditonalOperation(String operationName, ModelNode operation, OperationContext context, JMSQueueControl queueControl, Object handback) {\n+    protected void revertAdditionalOperation(String operationName, ModelNode operation, OperationContext context, JMSQueueControl queueControl, Object handback) {\n         // no-op\n     }\n }"},{"filename":"messaging/src/main/java/org/jboss/as/messaging/jms/PooledConnectionFactoryService.java","diff":"@@ -116,7 +116,7 @@\n     private static final List<LocalizedXsdString> EMPTY_LOCL = Collections.emptyList();\n     private static final String CONNECTOR_CLASSNAME = \"ConnectorClassName\";\n     private static final String CONNECTION_PARAMETERS = \"ConnectionParameters\";\n-    private static final String HQ_ACTIVIATION = \"org.hornetq.ra.inflow.HornetQActivationSpec\";\n+    private static final String HQ_ACTIVATION = \"org.hornetq.ra.inflow.HornetQActivationSpec\";\n     private static final String HQ_CONN_DEF = \"HornetQConnectionDefinition\";\n     private static final String HQ_ADAPTER = \"org.hornetq.ra.HornetQResourceAdapter\";\n     private static final String RAMANAGED_CONN_FACTORY = \"org.hornetq.ra.HornetQRAManagedConnectionFactory\";\n@@ -262,9 +262,9 @@ private void createService(ServiceTarget serviceTarget, ServiceContainer contain\n                     .addService(ConnectorServices.RESOURCE_ADAPTER_ACTIVATOR_SERVICE.append(name), activator)\n                     .addDependency(ConnectorServices.IRONJACAMAR_MDR, MetadataRepository.class,\n                             activator.getMdrInjector())\n-                    .addDependency(ConnectorServices.RA_REPOSISTORY_SERVICE, ResourceAdapterRepository.class,\n+                    .addDependency(ConnectorServices.RA_REPOSITORY_SERVICE, ResourceAdapterRepository.class,\n                             activator.getRaRepositoryInjector())\n-                    .addDependency(ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE, ManagementRepository.class,\n+                    .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class,\n                             activator.getManagementRepositoryInjector())\n                     .addDependency(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE,\n                             ResourceAdapterDeploymentRegistry.class, activator.getRegistryInjector())\n@@ -328,7 +328,7 @@ private InboundResourceAdapter createInbound() {\n             final ConfigProperty configProp = new ConfigPropertyImpl(EMPTY_LOCL, str(activationConfigProp), str(STRING_TYPE), null, null);\n             jmsActivationConfigProps.add(configProp);\n         }\n-        Activationspec16Impl activation = new Activationspec16Impl(str(HQ_ACTIVIATION), destination, jmsActivationConfigProps, null);\n+        Activationspec16Impl activation = new Activationspec16Impl(str(HQ_ACTIVATION), destination, jmsActivationConfigProps, null);\n         List<MessageListener> messageListeners = Collections.<MessageListener>singletonList(new MessageListenerImpl(str(JMS_MESSAGE_LISTENER), activation, null));\n         Messageadapter message = new MessageAdapterImpl(messageListeners, null);\n "},{"filename":"messaging/src/main/resources/org/jboss/as/messaging/LocalDescriptions.properties","diff":"@@ -284,8 +284,8 @@ queue.list-consumers-as-json.reply=A string in JSON format\n broadcast-group=A broadcast group is the means by which a server broadcasts connectors over the network.\n broadcast-group.add=Add a broadcast group.\n broadcast-group.remove=Remove a broadcast group.\n-broadcast-group.local-bind-address=The local bind address that the datagram socket is bound to. If you have multiple network interfaces on your server, you would specify which one you wish to use for broadcasts by setting this attrbute. If this attribute is not specified then the socket will be bound to the wildcard address, an IP address chosen by the kernel.\n-broadcast-group.local-bind-port=The local port to which the datagram socket is bound. Normally you would just use the default value of -1 which signifies that an anonymous port should be used. This parameter is alawys specified in conjunction with local-bind-address.\n+broadcast-group.local-bind-address=The local bind address that the datagram socket is bound to. If you have multiple network interfaces on your server, you would specify which one you wish to use for broadcasts by setting this attribute. If this attribute is not specified then the socket will be bound to the wildcard address, an IP address chosen by the kernel.\n+broadcast-group.local-bind-port=The local port to which the datagram socket is bound. Normally you would just use the default value of -1 which signifies that an anonymous port should be used. This parameter is always specified in conjunction with local-bind-address.\n broadcast-group.group-address=The multicast address to which the data will be broadcast. It is a class D IP address in the range 224.0.0.0 to 239.255.255.255, inclusive. The address 224.0.0.0 is reserved and is not available for use.\n broadcast-group.group-port=The UDP port number used for broadcasting.\n broadcast-group.broadcast-period=The period in milliseconds between consecutive broadcasts.\n@@ -312,7 +312,7 @@ bridge.remove=Operation removing a bridge.\n bridge.queue-name=The unique name of the local queue that the bridge consumes from.\n bridge.forwarding-address=The address on the target server that the message will be forwarded to. If a forwarding address is not specified then the original destination of the message will be retained.\n bridge.ha=Whether or not this bridge should support high availability. True means it will connect to any available server in a cluster and support failover.\n-bridge.filter=An optional filter string. If specified then only messages which match the filter expression specified will be forwarded. The filter string follows the HornetQ filter expression syntax desribed in the HornetQ documentation.\n+bridge.filter=An optional filter string. If specified then only messages which match the filter expression specified will be forwarded. The filter string follows the HornetQ filter expression syntax described in the HornetQ documentation.\n bridge.transformer-class-name=The name of a user-defined class which implements the org.hornetq.core.server.cluster.Transformer interface.\n bridge.retry-interval=The period in milliseconds between subsequent reconnection attempts, if the connection to the target server has failed.\n bridge.retry-interval-multiplier=A multiplier to apply to the time since the last retry to compute the time to the next retry. This allows you to implement an exponential backoff between retry attempts.\n@@ -334,7 +334,7 @@ divert.remove=Operation removing a divert\n divert.routing-name=Routing name of the divert\n divert.divert-address=Address to divert from\n divert.forwarding-address=Address to divert to\n-divert.filter=An optional filter string. If specified then only messages which match the filter expression specified will be diverted. The filter string follows the HornetQ filter expression syntax desribed in the HornetQ documentation.\n+divert.filter=An optional filter string. If specified then only messages which match the filter expression specified will be diverted. The filter string follows the HornetQ filter expression syntax described in the HornetQ documentation.\n divert.exclusive=Whether the divert is exclusive, meaning that the message is diverted to the new address, and does not go to the old address at all.\n divert.transformer-class-name=The name of a class used to transform the message's body or properties before it is diverted.\n \n@@ -470,7 +470,7 @@ pooled-connection-factory.add=Adds a managed connection factory.\n pooled-connection-factory.remove=Removes managed a connection factory.\n \n connection-factory.auto-group=Whether or not message grouping is automatically used\n-connection-factory.block-on-acknowledge=True to set block on ackowledge.\n+connection-factory.block-on-acknowledge=True to set block on acknowledge.\n connection-factory.block-on-durable-send=True to set block on durable send.\n connection-factory.block-on-non-durable-send=True to set block on non durable send.\n connection-factory.cache-large-message-client=True to cache large messages.\n@@ -508,7 +508,7 @@ connection-factory.use-global-pools=True to use global pools.\n connection-factory.add-jndi=Adds the factory to another JNDI binding\n \n pooled-connection-factory.auto-group=The autogroup.\n-pooled-connection-factory.block-on-acknowledge=True to set block on ackowledge.\n+pooled-connection-factory.block-on-acknowledge=True to set block on acknowledge.\n pooled-connection-factory.block-on-durable-send=True to set block on durable send.\n pooled-connection-factory.block-on-non-durable-send=True to set block on non durable send.\n pooled-connection-factory.cache-large-message-client=True to cache large messages."},{"filename":"modcluster/src/main/java/org/jboss/as/modcluster/CommonAttributes.java","diff":"@@ -46,7 +46,7 @@\n     String STICKY_SESSION_REMOVE = \"sticky-session-remove\";\n     String STICKY_SESSION_FORCE = \"sticky-session-force\";\n     String WORKER_TIMEOUT = \"worker-timeout\";\n-    String MAX_ATTEMPTS = \"max-attemps\";\n+    String MAX_ATTEMPTS = \"max-attempts\";\n     String FLUSH_PACKETS = \"flush-packets\";\n     String FLUSH_WAIT = \"flush-wait\";\n     String PING = \"ping\";"},{"filename":"modcluster/src/main/java/org/jboss/as/modcluster/ModClusterSubsystemDescriptions.java","diff":"@@ -434,7 +434,7 @@ static ModelNode getConfigurationCommonDescription(final ModelNode node, final S\n         node.get(type, CommonAttributes.WORKER_TIMEOUT, ModelDescriptionConstants.UNIT).set(MeasurementUnit.SECONDS.getName());\n \n         node.get(type, CommonAttributes.MAX_ATTEMPTS, TYPE).set(ModelType.INT);\n-        node.get(type, CommonAttributes.MAX_ATTEMPTS, DESCRIPTION).set(bundle.getString(\"modcluster.configuration.max-attemps\"));\n+        node.get(type, CommonAttributes.MAX_ATTEMPTS, DESCRIPTION).set(bundle.getString(\"modcluster.configuration.max-attempts\"));\n         node.get(type, CommonAttributes.MAX_ATTEMPTS, REQUIRED).set(false);\n         node.get(type, CommonAttributes.MAX_ATTEMPTS, DEFAULT).set(1);\n "},{"filename":"modcluster/src/main/resources/org/jboss/as/modcluster/LocalDescriptions.properties","diff":"@@ -4,14 +4,14 @@ modcluster.remove=Operation removing the modcluster subsystem.\n modcluster.configuration=The common modcluster configuration.\n modcluster.proxy-host=Hostname of the proxy (Apache httpd)\n modcluster.proxy-port=Port where the proxy (Apache httpd) is receiving the MCMP\n-modcluster.proxy-list=List of proxies the node is connected to. Format (hostname:port) separed with comas.\n+modcluster.proxy-list=List of proxies the node is connected to. Format (hostname:port) separated with comas.\n modcluster.read-proxies-info=Send a INFO to httpd and display the result.\n modcluster.proxies-info=Result of the INFO command.\n modcluster.read-proxies-configuration=Send a DUMP to httpd and display the result.\n modcluster.proxies-configuration=Result of the DUMP command.\n-modcluster.list-proxies=Read the list of httpd contected to the node.\n-modcluster.add-proxy=Add the proxy to the list of httpd contected to the node.\n-modcluster.remove-proxy=Remove the proxy to the list of httpd contected to the node.\n+modcluster.list-proxies=Read the list of httpd connected to the node.\n+modcluster.add-proxy=Add the proxy to the list of httpd connected to the node.\n+modcluster.remove-proxy=Remove the proxy to the list of httpd connected to the node.\n modcluster.refresh=Refresh the node sending a new CONFIG message to Apache httpd.\n modcluster.reset=Reset the node connection to Apache httpd.\n modcluster.virtualhost=Name of the virtual-host containing the context.\n@@ -24,11 +24,11 @@ modcluster.enable=Tell Apache httpd that all contexts of the node are ready rece\n modcluster.stop=Tell Apache httpd that all contexts of the node can't process requests.\n modcluster.disable=Tell Apache httpd that all contexts of the node can't process new requests.\n modcluster.configuration.advertise-socket=Name of Socket binding to use for the Advertise socket.\n-modcluster.configuration.proxy-list=List of proxies, Format (hostname:port) separed with comas.\n+modcluster.configuration.proxy-list=List of proxies, Format (hostname:port) separated with comas.\n modcluster.configuration.proxy-url=Base URL for MCMP requests.\n modcluster.configuration.advertise=Use Advertise logic or not.\n modcluster.configuration.advertise-security-key=String containing the security key for the Advertise logic.\n-modcluster.configuration.excluded-contexts=List of contexts mod_cluster should ignore, Format String separed with comas.\n+modcluster.configuration.excluded-contexts=List of contexts mod_cluster should ignore, Format String separated with comas.\n modcluster.configuration.auto-enable-contexts=Enable contexts even if disabled in mod_cluster_manger (httpd).\n modcluster.configuration.stop-context-timeout=Max time to wait for context to process pending requests.\n modcluster.configuration.socket-timeout=Timeout to wait for httpd to answer a MCMP message.\n@@ -48,7 +48,7 @@ modcluster.configuration.ssl.ca-certificate-file=Certificate authority.\n modcluster.configuration.ssl.ca-revocation-url=Certificate authority revocation list.\n \n modcluster.configuration.worker-timeout=Timeout to wait in httpd for an available worker to process the requests.\n-modcluster.configuration.max-attemps=Max attempts to process an idempotent request.\n+modcluster.configuration.max-attempts=Max attempts to process an idempotent request.\n modcluster.configuration.flush-packets=Enables/disables packet flushing in httpd.\n modcluster.configuration.flush-wait=Time to wait before flushing packets in httpd.\n modcluster.configuration.ping=Time (in seconds) in which to wait for a pong answer to a ping."},{"filename":"naming/src/main/java/org/jboss/as/naming/InitialContextFactoryBuilder.java","diff":"@@ -46,7 +46,7 @@\n      *\n      * @param environment The environment\n      * @return An initial context factory\n-     * @throws NamingException If an error occurs loading the factroy class.\n+     * @throws NamingException If an error occurs loading the factory class.\n      */\n     public javax.naming.spi.InitialContextFactory createInitialContextFactory(Hashtable<?, ?> environment) throws NamingException {\n         if (environment == null)"},{"filename":"naming/src/main/java/org/jboss/as/naming/NamingLogger.java","diff":"@@ -49,7 +49,7 @@\n     NamingLogger ROOT_LOGGER = Logger.getMessageLogger(NamingLogger.class, NamingLogger.class.getPackage().getName());\n \n     /**\n-     * Logs an informational message indicating the naming subsystem is being actived.\n+     * Logs an informational message indicating the naming subsystem is being activated.\n      */\n     @LogMessage(level = INFO)\n     @Message(id = 11800, value = \"Activating Naming Subsystem\")\n@@ -90,7 +90,7 @@\n \n     @LogMessage(level = ERROR)\n     @Message(id = 11807, value = \"Unexpected internal error\")\n-    void unnexpectedError(@Cause Throwable t);\n+    void unexpectedError(@Cause Throwable t);\n \n     @LogMessage(level = ERROR)\n     @Message(id = 11808, value = \"Null correlationId so error not sent to client\")\n@@ -102,6 +102,6 @@\n \n \n     @LogMessage(level = ERROR)\n-    @Message(id = 11810, value = \"Unexpected parameter type - excpected: %d  received: %d\")\n+    @Message(id = 11810, value = \"Unexpected parameter type - expected: %d  received: %d\")\n     void unexpectedParameterType(byte expected, byte actual);\n }"},{"filename":"naming/src/main/java/org/jboss/as/naming/NamingMessages.java","diff":"@@ -106,7 +106,7 @@\n     IllegalStateException cannotObtain(@Cause Throwable cause, String name);\n \n     /**\n-     * Creates an exception indicating the service name could not be resoloved.\n+     * Creates an exception indicating the service name could not be resolved.\n      *\n      * @param serviceName the service name.\n      *"},{"filename":"naming/src/main/java/org/jboss/as/naming/remote/RemoteNamingLogger.java","diff":"@@ -53,7 +53,7 @@ public void closingChannelOnChannelEnd(final Channel channel) {\n     }\n \n     public void unnexpectedError(final Throwable t) {\n-        ROOT_LOGGER.unnexpectedError(t);\n+        ROOT_LOGGER.unexpectedError(t);\n     }\n \n     public void nullCorrelationId(final Throwable t) {"},{"filename":"network/src/main/java/org/jboss/as/network/ClientMapping.java","diff":"@@ -68,7 +68,7 @@ public InetAddress getSourceNetworkAddress() {\n \n     /**\n      * Source network the client connection binds on. A client should match this value with the ip returned by\n-     * {@link #getSourceNetworkAddress()} against the desiered client host network interface,  and if matched the\n+     * {@link #getSourceNetworkAddress()} against the desired client host network interface,  and if matched the\n      * client should connect to the corresponding destination values.\n      *\n      * @return the number of mask bits starting from the LSB"},{"filename":"network/src/main/java/org/jboss/as/network/OutboundSocketBinding.java","diff":"@@ -162,7 +162,7 @@ public boolean isFixedSourcePort() {\n      *\n      * @return\n      */\n-    public InetAddress getSourceAddresss() {\n+    public InetAddress getSourceAddress() {\n         return this.sourceNetworkInterface != null ? this.sourceNetworkInterface.getAddress() : this.socketBindingManager.getDefaultInterfaceAddress();\n     }\n \n@@ -233,7 +233,7 @@ private Socket createSocket() throws IOException {\n     }\n \n     private SocketAddress getOptionalSourceSocketAddress() {\n-        final InetAddress sourceAddress = this.getSourceAddresss();\n+        final InetAddress sourceAddress = this.getSourceAddress();\n         final Integer absoluteSourcePort = this.getAbsoluteSourcePort();\n         if (sourceAddress == null && absoluteSourcePort == null) {\n             return null;"},{"filename":"osgi/service/src/main/java/org/jboss/as/osgi/parser/BundleRuntimeHandler.java","diff":"@@ -73,8 +73,8 @@ void register(ManagementResourceRegistration registry) {\n             registry.registerOperationHandler(op, this, new DescriptionProvider() {\n                 @Override\n                 public ModelNode getModelDescription(Locale locale) {\n-                    ResourceBundle resouceBundle = OSGiSubsystemProviders.getResourceBundle(locale);\n-                    return CommonDescriptions.getDescriptionOnlyOperation(resouceBundle, op, ModelConstants.BUNDLE);\n+                    ResourceBundle resourceBundle = OSGiSubsystemProviders.getResourceBundle(locale);\n+                    return CommonDescriptions.getDescriptionOnlyOperation(resourceBundle, op, ModelConstants.BUNDLE);\n                 }\n             }, EnumSet.of(OperationEntry.Flag.RESTART_NONE));\n         }"},{"filename":"osgi/service/src/main/java/org/jboss/as/osgi/parser/OSGiSubsystemDescribeHandler.java"},{"filename":"osgi/service/src/main/java/org/jboss/as/osgi/service/AutoInstallIntegration.java"},{"filename":"osgi/service/src/main/java/org/jboss/as/osgi/service/BundleReferenceClassLoader.java"},{"filename":"osgi/service/src/main/java/org/jboss/as/osgi/service/FrameworkBootstrapService.java"},{"filename":"osgi/service/src/main/java/org/jboss/as/osgi/service/ModuleIdentityArtifactProvider.java"},{"filename":"osgi/service/src/main/java/org/jboss/as/osgi/service/ModuleLoaderIntegration.java"},{"filename":"platform-mbean/src/main/java/org/jboss/as/platform/mbean/PlatformMBeanDescriptions.java"},{"filename":"platform-mbean/src/main/java/org/jboss/as/platform/mbean/PlatformMBeanMessages.java"},{"filename":"platform-mbean/src/main/java/org/jboss/as/platform/mbean/ThreadMXBeanDumpAllThreadsHandler.java"},{"filename":"platform-mbean/src/main/java/org/jboss/as/platform/mbean/ThreadMXBeanThreadInfoHandler.java"},{"filename":"platform-mbean/src/main/java/org/jboss/as/platform/mbean/ThreadMXBeanThreadInfosHandler.java"},{"filename":"platform-mbean/src/main/resources/org/jboss/as/platform/mbean/LocalDescriptions.properties"},{"filename":"pojo/src/main/java/org/jboss/as/pojo/PojoMessages.java"},{"filename":"pojo/src/main/java/org/jboss/as/pojo/PojoSubsystemAdd.java"},{"filename":"pojo/src/main/java/org/jboss/as/pojo/descriptor/AbstractConfigVisitorNode.java"},{"filename":"pojo/src/main/java/org/jboss/as/pojo/service/BeanInfo.java"},{"filename":"pojo/src/main/java/org/jboss/as/pojo/service/BeanUtils.java"},{"filename":"pojo/src/main/java/org/jboss/as/pojo/service/Configurator.java"},{"filename":"pojo/src/main/java/org/jboss/as/pojo/service/DefaultBeanInfo.java"},{"filename":"process-controller/src/main/java/org/jboss/as/process/CommandLineConstants.java"},{"filename":"process-controller/src/main/java/org/jboss/as/process/Main.java"},{"filename":"process-controller/src/main/java/org/jboss/as/process/protocol/ProtocolServer.java"},{"filename":"remoting/src/main/java/org/jboss/as/remoting/AbstractOutboundConnectionService.java"},{"filename":"remoting/src/main/java/org/jboss/as/remoting/AbstractStreamServerService.java"},{"filename":"remoting/src/main/java/org/jboss/as/remoting/GenericOutboundConnectionAdd.java"},{"filename":"remoting/src/main/java/org/jboss/as/remoting/LocalOutboundConnectionAdd.java"},{"filename":"remoting/src/main/java/org/jboss/as/remoting/RemoteOutboundConnectionAdd.java"},{"filename":"remoting/src/main/java/org/jboss/as/remoting/RemoteOutboundConnectionWriteHandler.java"},{"filename":"remoting/src/main/java/org/jboss/as/remoting/RemotingExtension.java"},{"filename":"security/src/main/java/org/jboss/as/security/vault/VaultInteractiveSession.java"},{"filename":"security/src/main/resources/org/jboss/as/security/LocalDescriptions.properties"},{"filename":"server/src/main/java/org/jboss/as/server/deployment/Attachments.java"},{"filename":"server/src/main/java/org/jboss/as/server/deployment/Phase.java"},{"filename":"server/src/main/java/org/jboss/as/server/deployment/module/ManifestClassPathProcessor.java"},{"filename":"server/src/main/java/org/jboss/as/server/deployment/module/ModuleSpecProcessor.java"},{"filename":"server/src/main/java/org/jboss/as/server/deployment/module/ModuleSpecification.java"},{"filename":"server/src/main/java/org/jboss/as/server/deployment/module/descriptor/DeploymentStructureDescriptorParser.java"},{"filename":"server/src/main/java/org/jboss/as/server/deployment/module/descriptor/ModuleStructureSpec.java"},{"filename":"server/src/main/java/org/jboss/as/server/moduleservice/ExtensionIndexService.java"},{"filename":"subsystem-test/src/main/java/org/jboss/as/subsystem/test/ModelDescriptionValidator.java"},{"filename":"subsystem-test/src/test/java/org/jboss/as/subsystem/test/validation/subsystem/ValidateSubsystemExtension.java"},{"filename":"testsuite/domain/src/test/java/org/jboss/as/test/integration/domain/suites/ValidateOperationOperationTestCase.java"},{"filename":"testsuite/integration/basic/src/test/java/org/jboss/as/test/integration/ejb/timerservice/view/ViewTimerServiceTestCase.java"},{"filename":"testsuite/integration/basic/src/test/java/org/jboss/as/test/integration/management/api/ValidateOperationOperationTestCase.java"},{"filename":"testsuite/integration/basic/src/test/java/org/jboss/as/test/integration/management/api/web/ConnectorTestCase.java"},{"filename":"testsuite/integration/basic/src/test/java/org/jboss/as/test/integration/management/api/web/VirtualServerTestCase.java"},{"filename":"testsuite/integration/basic/src/test/java/org/jboss/as/test/integration/web/security/WebSecurityCERTTestCase.java"},{"filename":"testsuite/integration/basic/src/test/java/org/jboss/as/test/integration/web/security/WebSecurityFORMTestCase.java"},{"filename":"testsuite/integration/smoke/src/test/java/org/jboss/as/test/smoke/embedded/demos/webapp/WebAppTestCase.java"},{"filename":"testsuite/integration/smoke/src/test/java/org/jboss/as/test/smoke/embedded/deployment/rar/examples/InflowTestCase.java"},{"filename":"testsuite/integration/smoke/src/test/java/org/jboss/as/test/smoke/embedded/deployment/rar/examples/PureTestCase.java"},{"filename":"testsuite/shared/src/main/java/org/jboss/as/test/integration/common/HttpRequest.java"},{"filename":"testsuite/shared/src/main/java/org/jboss/as/test/integration/management/Connector.java"},{"filename":"testsuite/shared/src/main/java/org/jboss/as/test/integration/management/ServerManager.java"},{"filename":"testsuite/shared/src/main/java/org/jboss/as/test/integration/management/jca/DsMgmtTestBase.java"},{"filename":"testsuite/shared/src/main/java/org/jboss/as/test/integration/management/util/CLIWrapper.java"},{"filename":"web/src/main/java/org/jboss/as/web/Attribute.java"},{"filename":"web/src/main/java/org/jboss/as/web/Constants.java"},{"filename":"web/src/main/java/org/jboss/as/web/DefaultJspConfig.java"},{"filename":"web/src/main/java/org/jboss/as/web/SharedWebMetaDataBuilder.java"},{"filename":"web/src/main/java/org/jboss/as/web/WebConfigurationHandlerUtils.java"},{"filename":"web/src/main/java/org/jboss/as/web/WebExtension.java"},{"filename":"web/src/main/java/org/jboss/as/web/WebMessages.java"},{"filename":"web/src/main/java/org/jboss/as/web/WebSubsystemDescriptions.java"},{"filename":"web/src/main/java/org/jboss/as/web/WebSubsystemParser.java"},{"filename":"web/src/main/java/org/jboss/as/web/WebSubsystemServices.java"},{"filename":"web/src/main/java/org/jboss/as/web/deployment/WarDeploymentProcessor.java"},{"filename":"web/src/main/java/org/jboss/as/web/deployment/WarMetaDataProcessor.java"},{"filename":"web/src/main/java/org/jboss/as/web/deployment/WarStructureDeploymentProcessor.java"},{"filename":"web/src/main/java/org/jboss/as/web/deployment/WebCtxLoader.java"},{"filename":"web/src/main/java/org/jboss/as/web/deployment/jsf/JandexAnnotationProvider.java"},{"filename":"web/src/main/java/org/jboss/as/web/security/JBossWebRealm.java"},{"filename":"web/src/main/java/org/jboss/as/web/security/WarJaccService.java"},{"filename":"web/src/main/java/org/jboss/as/web/security/jaspi/WebJASPIAuthenticator.java"},{"filename":"web/src/main/java/org/jboss/as/web/session/AttributeBasedClusteredSession.java"},{"filename":"web/src/main/java/org/jboss/as/web/session/ClusteredSessionValve.java"},{"filename":"web/src/main/java/org/jboss/as/web/session/DistributableSessionManager.java"},{"filename":"web/src/main/java/org/jboss/as/web/session/DistributableSessionManagerMBean.java"},{"filename":"web/src/main/java/org/jboss/as/web/session/notification/ClusteredSessionNotificationCapability.java"},{"filename":"web/src/main/java/org/jboss/as/web/session/notification/ClusteredSessionNotificationCause.java"},{"filename":"web/src/main/resources/org/jboss/as/web/LocalDescriptions.properties"},{"filename":"webservices/server-integration/src/main/java/org/jboss/as/webservices/injection/InjectionDeploymentAspect.java"},{"filename":"webservices/server-integration/src/main/java/org/jboss/as/webservices/injection/WSHandlerChainAnnotationProcessor.java"},{"filename":"webservices/server-integration/src/main/java/org/jboss/as/webservices/invocation/AbstractInvocationHandlerEJB.java"},{"filename":"webservices/server-integration/src/main/java/org/jboss/as/webservices/tomcat/WebMetaDataCreator.java"},{"filename":"webservices/server-integration/src/main/java/org/jboss/as/webservices/util/WebMetaDataHelper.java"},{"filename":"weld/src/main/java/org/jboss/as/weld/WeldDeploymentMarker.java"},{"filename":"weld/src/main/java/org/jboss/as/weld/WeldMessages.java"},{"filename":"weld/src/main/java/org/jboss/as/weld/WeldModuleResourceLoader.java"},{"filename":"weld/src/main/java/org/jboss/as/weld/deployment/BeanDeploymentArchiveImpl.java"},{"filename":"weld/src/main/java/org/jboss/as/weld/deployment/WeldDeploymentMetadata.java"},{"filename":"weld/src/main/java/org/jboss/as/weld/deployment/processors/WeldPortableExtensionProcessor.java"},{"filename":"weld/src/main/java/org/jboss/as/weld/ejb/EjbRequestScopeActivationInterceptor.java"},{"filename":"weld/src/main/java/org/jboss/as/weld/injection/WeldInjectionInterceptor.java"},{"filename":"xts/src/main/java/org/jboss/as/xts/XTSSubsystemAdd.java"}]}}